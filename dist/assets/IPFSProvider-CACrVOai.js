var hy=Object.defineProperty;var t2=n=>{throw TypeError(n)};var dy=(n,t,e)=>t in n?hy(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var u=(n,t,e)=>dy(n,typeof t!="symbol"?t+"":t,e),bh=(n,t,e)=>t.has(n)||t2("Cannot "+e);var Q=(n,t,e)=>(bh(n,t,"read from private field"),e?e.call(n):t.get(n)),ve=(n,t,e)=>t.has(n)?t2("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(n):t.set(n,e),He=(n,t,e,r)=>(bh(n,t,"write to private field"),r?r.call(n,e):t.set(n,e),e),ie=(n,t,e)=>(bh(n,t,"access private method"),e);var Xr=(n,t,e,r)=>({set _(s){He(n,t,s,e)},get _(){return Q(n,t,r)}});import{a as Ze,S as fy,U as gy,a1 as Nd,z as vh,a7 as py,a2 as r2,f as U4,g as $4,h as z4,j as Or,l as ku,k as my,n as V4,Q as yy,o as H4,aj as wy,Y as by,a0 as kc,a8 as vy,m as vl,ad as Ey,ak as Fn}from"./hooks-BhuarnWy.js";function n2(n){return n.substring(2).toLowerCase()}function Sy(n,t){return t.documentElement.clientWidth<n.clientX||t.documentElement.clientHeight<n.clientY}function xy(n){const{children:t,disableReactTree:e=!1,mouseEvent:r="onClick",onClickAway:s,touchEvent:i="onTouchEnd"}=n,o=Ze.useRef(!1),a=Ze.useRef(null),c=Ze.useRef(!1),l=Ze.useRef(!1);Ze.useEffect(()=>(setTimeout(()=>{c.current=!0},0),()=>{c.current=!1}),[]);const h=fy(gy(t),a),d=Nd(y=>{const p=l.current;l.current=!1;const w=vh(a.current);if(!c.current||!a.current||"clientX"in y&&Sy(y,w))return;if(o.current){o.current=!1;return}let v;y.composedPath?v=y.composedPath().includes(a.current):v=!w.documentElement.contains(y.target)||a.current.contains(y.target),!v&&(e||!p)&&s(y)}),f=y=>p=>{l.current=!0;const w=t.props[y];w&&w(p)},g={ref:h};return i!==!1&&(g[i]=f(i)),Ze.useEffect(()=>{if(i!==!1){const y=n2(i),p=vh(a.current),w=()=>{o.current=!0};return p.addEventListener(y,d),p.addEventListener("touchmove",w),()=>{p.removeEventListener(y,d),p.removeEventListener("touchmove",w)}}},[d,i]),r!==!1&&(g[r]=f(r)),Ze.useEffect(()=>{if(r!==!1){const y=n2(r),p=vh(a.current);return p.addEventListener(y,d),()=>{p.removeEventListener(y,d)}}},[d,r]),Ze.cloneElement(t,g)}function _y(n={}){const{autoHideDuration:t=null,disableWindowBlurListener:e=!1,onClose:r,open:s,resumeHideDuration:i}=n,o=py();Ze.useEffect(()=>{if(!s)return;function v(x){x.defaultPrevented||x.key==="Escape"&&(r==null||r(x,"escapeKeyDown"))}return document.addEventListener("keydown",v),()=>{document.removeEventListener("keydown",v)}},[s,r]);const a=Nd((v,x)=>{r==null||r(v,x)}),c=Nd(v=>{!r||v==null||o.start(v,()=>{a(null,"timeout")})});Ze.useEffect(()=>(s&&c(t),o.clear),[s,t,c,o]);const l=v=>{r==null||r(v,"clickaway")},h=o.clear,d=Ze.useCallback(()=>{t!=null&&c(i??t*.5)},[t,i,c]),f=v=>x=>{const S=v.onBlur;S==null||S(x),d()},g=v=>x=>{const S=v.onFocus;S==null||S(x),h()},y=v=>x=>{const S=v.onMouseEnter;S==null||S(x),h()},p=v=>x=>{const S=v.onMouseLeave;S==null||S(x),d()};return Ze.useEffect(()=>{if(!e&&s)return window.addEventListener("focus",d),window.addEventListener("blur",h),()=>{window.removeEventListener("focus",d),window.removeEventListener("blur",h)}},[e,s,d,h]),{getRootProps:(v={})=>{const x={...r2(n),...r2(v)};return{role:"presentation",...v,...x,onBlur:f(x),onFocus:g(x),onMouseEnter:y(x),onMouseLeave:p(x)}},onClickAway:l}}function ky(n){return U4("MuiSnackbarContent",n)}$4("MuiSnackbarContent",["root","message","action"]);const Iy=n=>{const{classes:t}=n;return V4({root:["root"],action:["action"],message:["message"]},ky,t)},Ay=ku(yy,{name:"MuiSnackbarContent",slot:"Root",overridesResolver:(n,t)=>t.root})(H4(({theme:n})=>{const t=n.palette.mode==="light"?.8:.98,e=wy(n.palette.background.default,t);return{...n.typography.body2,color:n.vars?n.vars.palette.SnackbarContent.color:n.palette.getContrastText(e),backgroundColor:n.vars?n.vars.palette.SnackbarContent.bg:e,display:"flex",alignItems:"center",flexWrap:"wrap",padding:"6px 16px",borderRadius:(n.vars||n).shape.borderRadius,flexGrow:1,[n.breakpoints.up("sm")]:{flexGrow:"initial",minWidth:288}}})),Ty=ku("div",{name:"MuiSnackbarContent",slot:"Message",overridesResolver:(n,t)=>t.message})({padding:"8px 0"}),Cy=ku("div",{name:"MuiSnackbarContent",slot:"Action",overridesResolver:(n,t)=>t.action})({display:"flex",alignItems:"center",marginLeft:"auto",paddingLeft:16,marginRight:-8}),Py=Ze.forwardRef(function(t,e){const r=z4({props:t,name:"MuiSnackbarContent"}),{action:s,className:i,message:o,role:a="alert",...c}=r,l=r,h=Iy(l);return Or.jsxs(Ay,{role:a,square:!0,elevation:6,className:my(h.root,i),ownerState:l,ref:e,...c,children:[Or.jsx(Ty,{className:h.message,ownerState:l,children:o}),s?Or.jsx(Cy,{className:h.action,ownerState:l,children:s}):null]})});function Dy(n){return U4("MuiSnackbar",n)}$4("MuiSnackbar",["root","anchorOriginTopCenter","anchorOriginBottomCenter","anchorOriginTopRight","anchorOriginBottomRight","anchorOriginTopLeft","anchorOriginBottomLeft"]);const Ry=n=>{const{classes:t,anchorOrigin:e}=n,r={root:["root",`anchorOrigin${vl(e.vertical)}${vl(e.horizontal)}`]};return V4(r,Dy,t)},By=ku("div",{name:"MuiSnackbar",slot:"Root",overridesResolver:(n,t)=>{const{ownerState:e}=n;return[t.root,t[`anchorOrigin${vl(e.anchorOrigin.vertical)}${vl(e.anchorOrigin.horizontal)}`]]}})(H4(({theme:n})=>({zIndex:(n.vars||n).zIndex.snackbar,position:"fixed",display:"flex",left:8,right:8,justifyContent:"center",alignItems:"center",variants:[{props:({ownerState:t})=>t.anchorOrigin.vertical==="top",style:{top:8,[n.breakpoints.up("sm")]:{top:24}}},{props:({ownerState:t})=>t.anchorOrigin.vertical!=="top",style:{bottom:8,[n.breakpoints.up("sm")]:{bottom:24}}},{props:({ownerState:t})=>t.anchorOrigin.horizontal==="left",style:{justifyContent:"flex-start",[n.breakpoints.up("sm")]:{left:24,right:"auto"}}},{props:({ownerState:t})=>t.anchorOrigin.horizontal==="right",style:{justifyContent:"flex-end",[n.breakpoints.up("sm")]:{right:24,left:"auto"}}},{props:({ownerState:t})=>t.anchorOrigin.horizontal==="center",style:{[n.breakpoints.up("sm")]:{left:"50%",right:"auto",transform:"translateX(-50%)"}}}]}))),sz=Ze.forwardRef(function(t,e){const r=z4({props:t,name:"MuiSnackbar"}),s=by(),i={enter:s.transitions.duration.enteringScreen,exit:s.transitions.duration.leavingScreen},{action:o,anchorOrigin:{vertical:a,horizontal:c}={vertical:"bottom",horizontal:"left"},autoHideDuration:l=null,children:h,className:d,ClickAwayListenerProps:f,ContentProps:g,disableWindowBlurListener:y=!1,message:p,onBlur:w,onClose:v,onFocus:x,onMouseEnter:S,onMouseLeave:I,open:P,resumeHideDuration:A,slots:C={},slotProps:T={},TransitionComponent:k,transitionDuration:N=i,TransitionProps:{onEnter:$,onExited:z,...q}={},...U}=r,L={...r,anchorOrigin:{vertical:a,horizontal:c},autoHideDuration:l,disableWindowBlurListener:y,TransitionComponent:k,transitionDuration:N},M=Ry(L),{getRootProps:R,onClickAway:V}=_y({...L}),[F,K]=Ze.useState(!0),J=Le=>{K(!0),z&&z(Le)},re=(Le,ct)=>{K(!1),$&&$(Le,ct)},ae={slots:{transition:k,...C},slotProps:{content:g,clickAwayListener:f,transition:q,...T}},[j,oe]=kc("root",{ref:e,className:[M.root,d],elementType:By,getSlotProps:R,externalForwardedProps:{...ae,...U},ownerState:L}),[we,{ownerState:Pe,...De}]=kc("clickAwayListener",{elementType:xy,externalForwardedProps:ae,getSlotProps:Le=>({onClickAway:(...ct)=>{var lt;(lt=Le.onClickAway)==null||lt.call(Le,...ct),V(...ct)}}),ownerState:L}),[Me,ot]=kc("content",{elementType:Py,shouldForwardComponentProp:!0,externalForwardedProps:ae,additionalProps:{message:p,action:o},ownerState:L}),[Je,at]=kc("transition",{elementType:vy,externalForwardedProps:ae,getSlotProps:Le=>({onEnter:(...ct)=>{var lt;(lt=Le.onEnter)==null||lt.call(Le,...ct),re(...ct)},onExited:(...ct)=>{var lt;(lt=Le.onExited)==null||lt.call(Le,...ct),J(...ct)}}),additionalProps:{appear:!0,in:P,timeout:N,direction:a==="top"?"down":"up"},ownerState:L});return!P&&F?null:Or.jsx(we,{...De,...C.clickAwayListener&&{ownerState:Pe},children:Or.jsx(j,{...oe,children:Or.jsx(Je,{...at,children:h||Or.jsx(Me,{...ot})})})})}),iz=Ey(Or.jsx("path",{d:"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Close"),My=Symbol.for("@libp2p/connection"),yo=Symbol.for("@libp2p/content-routing"),El=Symbol.for("@libp2p/peer-discovery"),nf=Symbol.for("@libp2p/peer-id");function q4(n){return!!(n!=null&&n[nf])}const wo=Symbol.for("@libp2p/peer-routing"),Iu="keep-alive",Sl="StrictSign",sf="StrictNoSign";var xr;(function(n){n.Accept="accept",n.Ignore="ignore",n.Reject="reject"})(xr||(xr={}));const Au=Symbol.for("@libp2p/transport");var Ca;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(Ca||(Ca={}));var Pd;let ii=(Pd=class extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}},u(Pd,"name","AbortError"),Pd);class W4 extends Error{constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}}u(W4,"name","UnexpectedPeerError");var Dd;let Ny=(Dd=class extends Error{constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}},u(Dd,"name","InvalidCryptoExchangeError"),Dd);var Rd;let W=(Rd=class extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},u(Rd,"name","InvalidParametersError"),Rd);class Pa extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}u(Pa,"name","InvalidPublicKeyError");class of extends Error{constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}u(of,"name","InvalidPrivateKeyError");class K4 extends Error{constructor(t="The connection is closing"){super(t),this.name="ConnectionClosingError"}}u(K4,"name","ConnectionClosingError");class af extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}u(af,"name","ConnectionClosedError");class cf extends Error{constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}}u(cf,"name","ConnectionFailedError");class $s extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}u($s,"name","MuxerClosedError");class G4 extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}u(G4,"name","StreamResetError");class xl extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}u(xl,"name","StreamStateError");var Bd;let Nt=(Bd=class extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}},u(Bd,"name","NotFoundError"),Bd);class lf extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}u(lf,"name","InvalidPeerIdError");class Tu extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}}u(Tu,"name","InvalidMultiaddrError");class Q4 extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}u(Q4,"name","InvalidCIDError");class Cu extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}u(Cu,"name","InvalidMultihashError");class ic extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}u(ic,"name","UnsupportedProtocolError");class We extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}u(We,"name","InvalidMessageError");class Y4 extends Error{constructor(t="Protocol error"){super(t),this.name="ProtocolError"}}u(Y4,"name","ProtocolError");var Md;let Pu=(Md=class extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}},u(Md,"name","TimeoutError"),Md);class bo extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}u(bo,"name","NotStartedError");class eo extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}u(eo,"name","DialError");class _l extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}u(_l,"name","ListenError");class uf extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}u(uf,"name","LimitedConnectionError");class X4 extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}u(X4,"name","TooManyInboundProtocolStreamsError");class Du extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}u(Du,"name","TooManyOutboundProtocolStreamsError");class bi extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}u(bi,"name","UnsupportedKeyTypeError");var on;class Et extends EventTarget{constructor(){super();ve(this,on,new Map)}listenerCount(e){const r=Q(this,on).get(e);return r==null?0:r.length}addEventListener(e,r,s){super.addEventListener(e,r,s);let i=Q(this,on).get(e);i==null&&(i=[],Q(this,on).set(e,i)),i.push({callback:r,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(e,r,s){super.removeEventListener(e.toString(),r??null,s);let i=Q(this,on).get(e);i!=null&&(i=i.filter(({callback:o})=>o!==r),Q(this,on).set(e,i))}dispatchEvent(e){const r=super.dispatchEvent(e);let s=Q(this,on).get(e.type);return s==null||(s=s.filter(({once:i})=>!i),Q(this,on).set(e.type,s)),r}safeDispatchEvent(e,r={}){return this.dispatchEvent(new CustomEvent(e,r))}}on=new WeakMap;function hf(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}async function Ln(...n){const t=[];for(const e of n)hf(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function Cs(...n){const t=[];for(const e of n)hf(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}const Pt=Symbol.for("@libp2p/service-capabilities"),ms=Symbol.for("@libp2p/service-dependencies");function Ne(n){const t=new globalThis.AbortController;function e(){t.abort();for(const i of n)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}for(const i of n){if((i==null?void 0:i.aborted)===!0){e();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",e)}function r(){for(const i of n)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}const s=t.signal;return s.clear=r,s}function me(){const n={};return n.promise=new Promise((t,e)=>{n.resolve=t,n.reject=e}),n}class s2{constructor(t){u(this,"buffer");u(this,"mask");u(this,"top");u(this,"btm");u(this,"next");if(!(t>0)||(t-1&t)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){const t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}}class Eh{constructor(t={}){u(this,"size");u(this,"hwm");u(this,"head");u(this,"tail");this.hwm=t.splitLimit??16,this.head=new s2(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return(t==null?void 0:t.byteLength)!=null?t.byteLength:1}push(t){if((t==null?void 0:t.value)!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){const e=this.head;this.head=e.next=new s2(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return(t==null?void 0:t.value)!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}let Ly=class extends Error{constructor(e,r){super(e??"The operation was aborted");u(this,"type");u(this,"code");this.type="aborted",this.code=r??"ABORT_ERR"}};function gn(n={}){return Oy(e=>{const r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function Oy(n,t){t=t??{};let e=t.onEnd,r=new Eh,s,i,o,a=me();const c=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((w,v)=>{i=x=>{i=null,r.push(x);try{w(n(r))}catch(S){v(S)}return s}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=me()})}},l=w=>i!=null?i(w):(r.push(w),s),h=w=>(r=new Eh,i!=null?i({error:w}):(r.push({error:w}),s)),d=w=>{if(o)return s;if((t==null?void 0:t.objectMode)!==!0&&(w==null?void 0:w.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:w})},f=w=>o?s:(o=!0,w!=null?h(w):l({done:!0})),g=()=>(r=new Eh,f(),{done:!0}),y=w=>(f(w),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:g,throw:y,push:d,end:f,get readableLength(){return r.size},onEmpty:async w=>{const v=w==null?void 0:w.signal;if(v==null||v.throwIfAborted(),r.isEmpty())return;let x,S;v!=null&&(x=new Promise((I,P)=>{S=()=>{P(new Ly)},v.addEventListener("abort",S)}));try{await Promise.race([a.promise,x])}finally{S!=null&&v!=null&&(v==null||v.removeEventListener("abort",S))}}},e==null)return s;const p=s;return s={[Symbol.asyncIterator](){return this},next(){return p.next()},throw(w){return p.throw(w),e!=null&&(e(w),e=void 0),{done:!0}},return(){return p.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(w){return p.end(w),e!=null&&(e(w),e=void 0),s},get readableLength(){return p.readableLength},onEmpty:w=>p.onEmpty(w)},s}let Fy=class extends Error{constructor(e,r){super(e??"The operation was aborted");u(this,"type");u(this,"code");this.type="aborted",this.name="AbortError",this.code=r??"ABORT_ERR"}};async function _r(n,t,e,r){const s=new Fy(r==null?void 0:r.errorMessage,r==null?void 0:r.errorCode);return(e==null?void 0:e.aborted)===!0?Promise.reject(s):new Promise((i,o)=>{function a(){e==null||e.removeEventListener("abort",h),n.removeEventListener(t,c),(r==null?void 0:r.errorEvent)!=null&&n.removeEventListener(r.errorEvent,l)}const c=d=>{var f;try{if(((f=r==null?void 0:r.filter)==null?void 0:f.call(r,d))===!1)return}catch(g){a(),o(g);return}a(),i(d)},l=d=>{a(),o(d.detail)},h=()=>{a(),o(s)};e==null||e.addEventListener("abort",h),n.addEventListener(t,c),(r==null?void 0:r.errorEvent)!=null&&n.addEventListener(r.errorEvent,l)})}class Uy extends Error{constructor(e="Rate limit exceeded",r){super(e);u(this,"remainingPoints");u(this,"msBeforeNext");u(this,"consumedPoints");u(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=r.remainingPoints,this.msBeforeNext=r.msBeforeNext,this.consumedPoints=r.consumedPoints,this.isFirstInDuration=r.isFirstInDuration}}class Z4 extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}}u(Z4,"name","QueueFullError");let i2=class extends Error{constructor(e,r,s){super(e??"The operation was aborted");u(this,"type");u(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=r??"ABORT_ERR"}};async function fr(n,t,e){if(t==null)return n;if(t.aborted)return n.catch(()=>{}),Promise.reject(new i2(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let r;const s=new i2(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([n,new Promise((i,o)=>{r=()=>{o(s)},t.addEventListener("abort",r)})])}finally{r!=null&&t.removeEventListener("abort",r)}}class $y{constructor(t){u(this,"deferred");u(this,"signal");var e;this.signal=t,this.deferred=me(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new ii)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}}function zy(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class Vy{constructor(t,e){u(this,"id");u(this,"fn");u(this,"options");u(this,"recipients");u(this,"status");u(this,"timeline");u(this,"controller");this.id=zy(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,r)=>{var s;return e&&((s=r.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new ii),this.cleanup())}async join(t={}){var r;const e=new $y(t.signal);return this.recipients.push(e),(r=t.signal)==null||r.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await fr(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}}class oi extends Et{constructor(e={}){var r;super();u(this,"concurrency");u(this,"maxSize");u(this,"queue");u(this,"pending");u(this,"sort");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&((r=e.metrics)==null||r.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=e.sort,this.queue=[]}tryToStartAnother(){if(this.size===0)return queueMicrotask(()=>{this.safeDispatchEvent("empty")}),this.running===0&&queueMicrotask(()=>{this.safeDispatchEvent("idle")}),!1;if(this.pending<this.concurrency){let e;for(const r of this.queue)if(r.status==="queued"){e=r;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let r=0;r<this.queue.length;r++)if(this.queue[r]===e){this.queue.splice(r,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,r){var i;if((i=r==null?void 0:r.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Z4;const s=new Vy(e,r);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(r).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("error",{detail:o}),this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new ii)}),this.clear()}async onEmpty(e){this.size!==0&&await _r(this,"empty",e==null?void 0:e.signal)}async onSizeLessThan(e,r){this.size<e||await _r(this,"next",r==null?void 0:r.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await _r(this,"idle",e==null?void 0:e.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var l,h,d;(l=e==null?void 0:e.signal)==null||l.throwIfAborted();const r=gn({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),r.end(f)},i=f=>{f.detail!=null&&r.push(f.detail)},o=f=>{s(f.detail)},a=()=>{s()},c=()=>{s(new ii("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("error",o),this.addEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.addEventListener("abort",c);try{yield*r}finally{this.removeEventListener("completed",i),this.removeEventListener("error",o),this.removeEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.removeEventListener("abort",c),s()}}}class ys extends oi{has(t){return this.find(t)!=null}find(t){return this.queue.find(e=>t.equals(e.options.peerId))}}function Hy(n){return n[Symbol.asyncIterator]!=null}function ws(n){if(Hy(n))return(async()=>{for await(const t of n);})();for(const t of n);}function Ee(n=0){return new Uint8Array(n)}function sr(n=0){return new Uint8Array(n)}const qy=Math.pow(2,7),Wy=Math.pow(2,14),Ky=Math.pow(2,21),df=Math.pow(2,28),ff=Math.pow(2,35),gf=Math.pow(2,42),pf=Math.pow(2,49),Re=128,Rt=127;function $e(n){if(n<qy)return 1;if(n<Wy)return 2;if(n<Ky)return 3;if(n<df)return 4;if(n<ff)return 5;if(n<gf)return 6;if(n<pf)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function J4(n,t,e=0){switch($e(n)){case 8:t[e++]=n&255|Re,n/=128;case 7:t[e++]=n&255|Re,n/=128;case 6:t[e++]=n&255|Re,n/=128;case 5:t[e++]=n&255|Re,n/=128;case 4:t[e++]=n&255|Re,n>>>=7;case 3:t[e++]=n&255|Re,n>>>=7;case 2:t[e++]=n&255|Re,n>>>=7;case 1:{t[e++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return t}function Gy(n,t,e=0){switch($e(n)){case 8:t.set(e++,n&255|Re),n/=128;case 7:t.set(e++,n&255|Re),n/=128;case 6:t.set(e++,n&255|Re),n/=128;case 5:t.set(e++,n&255|Re),n/=128;case 4:t.set(e++,n&255|Re),n>>>=7;case 3:t.set(e++,n&255|Re),n>>>=7;case 2:t.set(e++,n&255|Re),n>>>=7;case 1:{t.set(e++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return t}function j4(n,t){let e=n[t],r=0;if(r+=e&Rt,e<Re||(e=n[t+1],r+=(e&Rt)<<7,e<Re)||(e=n[t+2],r+=(e&Rt)<<14,e<Re)||(e=n[t+3],r+=(e&Rt)<<21,e<Re)||(e=n[t+4],r+=(e&Rt)*df,e<Re)||(e=n[t+5],r+=(e&Rt)*ff,e<Re)||(e=n[t+6],r+=(e&Rt)*gf,e<Re)||(e=n[t+7],r+=(e&Rt)*pf,e<Re))return r;throw new RangeError("Could not decode varint")}function Qy(n,t){let e=n.get(t),r=0;if(r+=e&Rt,e<Re||(e=n.get(t+1),r+=(e&Rt)<<7,e<Re)||(e=n.get(t+2),r+=(e&Rt)<<14,e<Re)||(e=n.get(t+3),r+=(e&Rt)<<21,e<Re)||(e=n.get(t+4),r+=(e&Rt)*df,e<Re)||(e=n.get(t+5),r+=(e&Rt)*ff,e<Re)||(e=n.get(t+6),r+=(e&Rt)*gf,e<Re)||(e=n.get(t+7),r+=(e&Rt)*pf,e<Re))return r;throw new RangeError("Could not decode varint")}function Lt(n,t,e=0){return t==null&&(t=sr($e(n))),t instanceof Uint8Array?J4(n,t,e):Gy(n,t,e)}function yn(n,t=0){return n instanceof Uint8Array?j4(n,t):Qy(n,t)}function ft(n,t){t==null&&(t=n.reduce((s,i)=>s+i.length,0));const e=sr(t);let r=0;for(const s of n)e.set(s,r),r+=s.length;return e}function _e(n,t){if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0}const e6=Symbol.for("@achingbrain/uint8arraylist");function o2(n,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(const r of n){const s=e+r.byteLength;if(t<s)return{buf:r,index:t-e};e=s}throw new RangeError("index is out of bounds")}function ua(n){return!!(n!=null&&n[e6])}var T3;class ye{constructor(...t){u(this,"bufs");u(this,"length");u(this,T3,!0);this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[(T3=e6,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(const r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(ua(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(const r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(ua(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){const e=o2(this.bufs,t);return e.buf[e.index]}set(t,e){const r=o2(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(ua(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){const{bufs:r,length:s}=this._subList(t,e);return ft(r,s)}subarray(t,e){const{bufs:r,length:s}=this._subList(t,e);return r.length===1?r[0]:ft(r,s)}sublist(t,e){const{bufs:r,length:s}=this._subList(t,e),i=new ye;return i.length=s,i.bufs=[...r],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,t>=c)continue;const l=t>=a&&t<c,h=e>a&&e<=c;if(l&&h){if(t===a&&e===c){r.push(o);break}const d=t-a;r.push(o.subarray(d,d+(e-t)));break}if(l){if(t===0){r.push(o);continue}r.push(o.subarray(t-a));continue}if(h){if(e===c){r.push(o);break}r.push(o.subarray(0,e-a));break}r.push(o)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!ua(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[r[d]]=d;const a=o,c=this.byteLength-r.byteLength,l=r.byteLength-1;let h;for(let d=e;d<=c;d+=h){h=0;for(let f=l;f>=0;f--){const g=this.get(d+f);if(r[f]!==g){h=Math.max(1,f-a[g]);break}}if(h===0)return d}return-1}getInt8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){const r=sr(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){const s=Ee(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,e,r),this.write(s,t)}getInt32(t,e){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){const s=Ee(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,e,r),this.write(s,t)}getBigInt64(t,e){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){const s=Ee(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,e,r),this.write(s,t)}getUint8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){const r=sr(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){const s=Ee(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,e,r),this.write(s,t)}getUint32(t,e){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){const s=Ee(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,e,r),this.write(s,t)}getBigUint64(t,e){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){const s=Ee(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,e,r),this.write(s,t)}getFloat32(t,e){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){const s=Ee(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,e,r),this.write(s,t)}getFloat64(t,e){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){const s=Ee(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,e,r),this.write(s,t)}equals(t){if(t==null||!(t instanceof ye)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!_e(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){const r=new ye;return r.bufs=t,e==null&&(e=t.reduce((s,i)=>s+i.byteLength,0)),r.length=e,r}}const Yy=8,mf=1024*1024*4;let Xy=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidMessageLengthError");u(this,"code","ERR_INVALID_MSG_LENGTH")}},t6=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthError");u(this,"code","ERR_MSG_DATA_TOO_LONG")}},Zy=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthLengthError");u(this,"code","ERR_MSG_LENGTH_TOO_LONG")}},a2=class extends Error{constructor(){super(...arguments);u(this,"name","UnexpectedEOFError");u(this,"code","ERR_UNEXPECTED_EOF")}};function r6(n){return n[Symbol.asyncIterator]!=null}function n6(n,t){if(n.byteLength>t)throw new t6("Message length too long")}const Ru=n=>{const t=$e(n),e=sr(t);return Lt(n,e),Ru.bytes=t,e};Ru.bytes=0;function vo(n,t){t=t??{};const e=t.lengthEncoder??Ru,r=(t==null?void 0:t.maxDataLength)??mf;function*s(i){n6(i,r);const o=e(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return r6(n)?async function*(){for await(const i of n)yield*s(i)}():function*(){for(const i of n)yield*s(i)}()}vo.single=(n,t)=>{t=t??{};const e=t.lengthEncoder??Ru,r=(t==null?void 0:t.maxDataLength)??mf;return n6(n,r),new ye(e(n.byteLength),n)};var zs;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(zs||(zs={}));const yf=n=>{const t=yn(n);return yf.bytes=$e(t),t};yf.bytes=0;function Eo(n,t){const e=new ye;let r=zs.LENGTH,s=-1;const i=(t==null?void 0:t.lengthDecoder)??yf,o=(t==null?void 0:t.maxLengthLength)??Yy,a=(t==null?void 0:t.maxDataLength)??mf;function*c(){for(;e.byteLength>0;){if(r===zs.LENGTH)try{if(s=i(e),s<0)throw new Xy("Invalid message length");if(s>a)throw new t6("Message length too long");const l=i.bytes;e.consume(l),(t==null?void 0:t.onLength)!=null&&t.onLength(s),r=zs.DATA}catch(l){if(l instanceof RangeError){if(e.byteLength>o)throw new Zy("Message length length too long");break}throw l}if(r===zs.DATA){if(e.byteLength<s)break;const l=e.sublist(0,s);e.consume(s),(t==null?void 0:t.onData)!=null&&t.onData(l),yield l,r=zs.LENGTH}}}return r6(n)?async function*(){for await(const l of n)e.append(l),yield*c();if(e.byteLength>0)throw new a2("Unexpected end of input")}():function*(){for(const l of n)e.append(l),yield*c();if(e.byteLength>0)throw new a2("Unexpected end of input")}()}Eo.fromReader=(n,t)=>{let e=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(e);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{e=1}}();return Eo(r,{...t??{},onLength:i=>{e=i}})};function wf(n){const[t,e]=n[Symbol.asyncIterator]!=null?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:s=>{r.push(s)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[e](){return this}}}function Jy(n){return n[Symbol.asyncIterator]!=null}function Un(n,t){let e=0;if(Jy(n))return async function*(){for await(const c of n)yield t(c,e++)}();const r=wf(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof o.then=="function")return async function*(){yield await o;for await(const c of r)yield t(c,e++)}();const a=t;return function*(){yield o;for(const c of r)yield a(c,e++)}()}let jy=class{constructor(){u(this,"readNext");u(this,"haveNext");u(this,"ended");u(this,"nextResult");u(this,"error");this.ended=!1,this.readNext=me(),this.haveNext=me()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=me(),t}async throw(t){return this.ended=!0,this.error=t,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){const t={done:!0,value:void 0};return this.ended=!0,this.nextResult=t,this.haveNext.resolve(),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=me(),await fr(this.readNext.promise,e==null?void 0:e.signal,e)}};function ew(){return new jy}function tw(n){return n[Symbol.asyncIterator]!=null}async function rw(n,t){try{await Promise.all(n.map(async e=>{for await(const r of e)await t.push(r)})),await t.end()}catch(e){await t.end(e).catch(()=>{})}}async function*nw(n){const t=ew();rw(n,t).catch(()=>{}),yield*t}function*sw(n){for(const t of n)yield*t}function us(...n){const t=[];for(const e of n)tw(e)||t.push(e);return t.length===n.length?sw(t):nw(n)}function It(n,...t){if(n==null)throw new Error("Empty pipeline");if(Sh(n)){const r=n;n=()=>r.source}else if(i6(n)||s6(n)){const r=n;n=()=>r}const e=[n,...t];if(e.length>1&&Sh(e[e.length-1])&&(e[e.length-1]=e[e.length-1].sink),e.length>2)for(let r=1;r<e.length-1;r++)Sh(e[r])&&(e[r]=ow(e[r]));return iw(...e)}const iw=(...n)=>{let t;for(;n.length>0;)t=n.shift()(t);return t},s6=n=>(n==null?void 0:n[Symbol.asyncIterator])!=null,i6=n=>(n==null?void 0:n[Symbol.iterator])!=null,Sh=n=>n==null?!1:n.sink!=null&&n.source!=null,ow=n=>t=>{const e=n.sink(t);if((e==null?void 0:e.then)!=null){const r=gn({objectMode:!0});e.then(()=>{r.end()},o=>{r.end(o)});let s;const i=n.source;if(s6(i))s=async function*(){yield*i,r.end()};else if(i6(i))s=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return us(r,s())}return n.source};function aw(n){return n[Symbol.asyncIterator]!=null}function kl(n,t){return aw(n)?async function*(){let e=0;if(!(t<1)){for await(const r of n)if(yield r,e++,e===t)return}}():function*(){let e=0;if(!(t<1)){for(const r of n)if(yield r,e++,e===t)return}}()}class se extends Event{constructor(e,r){super(e);u(this,"type");u(this,"detail");this.type=e,this.detail=r}}const Ic="/ipfs/bitswap/1.2.0",cw=1024,lw=1024,uw=1024,hw=5e3,dw=10,fw=50,gw=!1,pw=3,o6=1024*1024*4,mw=o6,bf=new Float32Array([-0]),is=new Uint8Array(bf.buffer);function yw(n,t,e){bf[0]=n,t[e]=is[0],t[e+1]=is[1],t[e+2]=is[2],t[e+3]=is[3]}function ww(n,t){return is[0]=n[t],is[1]=n[t+1],is[2]=n[t+2],is[3]=n[t+3],bf[0]}const vf=new Float64Array([-0]),Bt=new Uint8Array(vf.buffer);function bw(n,t,e){vf[0]=n,t[e]=Bt[0],t[e+1]=Bt[1],t[e+2]=Bt[2],t[e+3]=Bt[3],t[e+4]=Bt[4],t[e+5]=Bt[5],t[e+6]=Bt[6],t[e+7]=Bt[7]}function vw(n,t){return Bt[0]=n[t],Bt[1]=n[t+1],Bt[2]=n[t+2],Bt[3]=n[t+3],Bt[4]=n[t+4],Bt[5]=n[t+5],Bt[6]=n[t+6],Bt[7]=n[t+7],vf[0]}const Ew=BigInt(Number.MAX_SAFE_INTEGER),Sw=BigInt(Number.MIN_SAFE_INTEGER);class Mt{constructor(t,e){u(this,"lo");u(this,"hi");this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const e=~this.lo+1>>>0;let r=~this.hi>>>0;return e===0&&(r=r+1>>>0),-(e+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const e=~this.lo+1>>>0;let r=~this.hi>>>0;return e===0&&(r=r+1>>>0),-(BigInt(e)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:r<128?9:10}static fromBigInt(t){if(t===0n)return js;if(t<Ew&&t>Sw)return this.fromNumber(Number(t));const e=t<0n;e&&(t=-t);let r=t>>32n,s=t-(r<<32n);return e&&(r=~r|0n,s=~s|0n,++s>c2&&(s=0n,++r>c2&&(r=0n))),new Mt(Number(s),Number(r))}static fromNumber(t){if(t===0)return js;const e=t<0;e&&(t=-t);let r=t>>>0,s=(t-r)/4294967296>>>0;return e&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new Mt(r,s)}static from(t){return typeof t=="number"?Mt.fromNumber(t):typeof t=="bigint"?Mt.fromBigInt(t):typeof t=="string"?Mt.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new Mt(t.low>>>0,t.high>>>0):js}}const js=new Mt(0,0);js.toBigInt=function(){return 0n};js.zzEncode=js.zzDecode=function(){return this};js.length=function(){return 1};const c2=4294967296n;function xw(n){let t=0,e=0;for(let r=0;r<n.length;++r)e=n.charCodeAt(r),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,t+=4):t+=3;return t}function _w(n,t,e){if(e-t<1)return"";let s;const i=[];let o=0,a;for(;t<e;)a=n[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|n[t++]&63:a>239&&a<365?(a=((a&7)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(n[t++]&63)<<6|n[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function a6(n,t,e){const r=e;let s,i;for(let o=0;o<n.length;++o)s=n.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=n.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-r}function Tr(n,t){return RangeError(`index out of range: ${n.pos} + ${t??1} > ${n.len}`)}function Ac(n,t){return(n[t-4]|n[t-3]<<8|n[t-2]<<16|n[t-1]<<24)>>>0}class kw{constructor(t){u(this,"buf");u(this,"pos");u(this,"len");u(this,"_slice",Uint8Array.prototype.subarray);this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,Tr(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Tr(this,4);return Ac(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Tr(this,4);return Ac(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Tr(this,4);const t=ww(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw Tr(this,4);const t=vw(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),e=this.pos,r=this.pos+t;if(r>this.len)throw Tr(this,t);return this.pos+=t,e===r?new Uint8Array(0):this.buf.subarray(e,r)}string(){const t=this.bytes();return _w(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw Tr(this,t);this.pos+=t}else do if(this.pos>=this.len)throw Tr(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new Mt(0,0);let e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Tr(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw Tr(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Tr(this,8);const t=Ac(this.buf,this.pos+=4),e=Ac(this.buf,this.pos+=4);return new Mt(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=j4(this.buf,this.pos);return this.pos+=$e(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Iw(n){return new kw(n instanceof Uint8Array?n:n.subarray())}function ue(n,t,e){const r=Iw(n);return t.decode(r,void 0,e)}const Aw=new Uint8Array(0);function Tw(n){const t=n.match(/../g);return t!=null?new Uint8Array(t.map(e=>parseInt(e,16))):Aw}function Cw(n,t){if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0}function Ho(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function Pw(n){return new TextEncoder().encode(n)}function Dw(n){return new TextDecoder().decode(n)}function Rw(n,t){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var s=0;s<n.length;s++){var i=n.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var a=n.length,c=n.charAt(0),l=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function d(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var p=0,w=0,v=0,x=y.length;v!==x&&y[v]===0;)v++,p++;for(var S=(x-v)*h+1>>>0,I=new Uint8Array(S);v!==x;){for(var P=y[v],A=0,C=S-1;(P!==0||A<w)&&C!==-1;C--,A++)P+=256*I[C]>>>0,I[C]=P%a>>>0,P=P/a>>>0;if(P!==0)throw new Error("Non-zero carry");w=A,v++}for(var T=S-w;T!==S&&I[T]===0;)T++;for(var k=c.repeat(p);T<S;++T)k+=n.charAt(I[T]);return k}function f(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;var p=0;if(y[p]!==" "){for(var w=0,v=0;y[p]===c;)w++,p++;for(var x=(y.length-p)*l+1>>>0,S=new Uint8Array(x);y[p];){var I=e[y.charCodeAt(p)];if(I===255)return;for(var P=0,A=x-1;(I!==0||P<v)&&A!==-1;A--,P++)I+=a*S[A]>>>0,S[A]=I%256>>>0,I=I/256>>>0;if(I!==0)throw new Error("Non-zero carry");v=P,p++}if(y[p]!==" "){for(var C=x-v;C!==x&&S[C]===0;)C++;for(var T=new Uint8Array(w+(x-C)),k=w;C!==x;)T[k++]=S[C++];return T}}}function g(y){var p=f(y);if(p)return p;throw new Error(`Non-${t} character`)}return{encode:d,decodeUnsafe:f,decode:g}}var Bw=Rw,Mw=Bw;let Nw=class{constructor(t,e,r){u(this,"name");u(this,"prefix");u(this,"baseEncode");this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Lw=class{constructor(t,e,r){u(this,"name");u(this,"prefix");u(this,"baseDecode");u(this,"prefixCodePoint");this.name=t,this.prefix=e;const s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return c6(this,t)}};class Ow{constructor(t){u(this,"decoders");this.decoders=t}or(t){return c6(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r!=null)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function c6(n,t){return new Ow({...n.decoders??{[n.prefix]:n},...t.decoders??{[t.prefix]:t}})}class Fw{constructor(t,e,r,s){u(this,"name");u(this,"prefix");u(this,"baseEncode");u(this,"baseDecode");u(this,"encoder");u(this,"decoder");this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=s,this.encoder=new Nw(t,e,r),this.decoder=new Lw(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function Bu({name:n,prefix:t,encode:e,decode:r}){return new Fw(n,t,e,r)}function oc({name:n,prefix:t,alphabet:e}){const{encode:r,decode:s}=Mw(e,n);return Bu({prefix:t,name:n,encode:r,decode:i=>Ho(s(i))})}function Uw(n,t,e,r){const s={};for(let h=0;h<t.length;++h)s[t[h]]=h;let i=n.length;for(;n[i-1]==="=";)--i;const o=new Uint8Array(i*e/8|0);let a=0,c=0,l=0;for(let h=0;h<i;++h){const d=s[n[h]];if(d===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<e|d,a+=e,a>=8&&(a-=8,o[l++]=255&c>>a)}if(a>=e||(255&c<<8-a)!==0)throw new SyntaxError("Unexpected end of data");return o}function $w(n,t,e){const r=t[t.length-1]==="=",s=(1<<e)-1;let i="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>e;)o-=e,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<e-o]),r)for(;(i.length*e&7)!==0;)i+="=";return i}function Dt({name:n,prefix:t,bitsPerChar:e,alphabet:r}){return Bu({prefix:t,name:n,encode(s){return $w(s,r,e)},decode(s){return Uw(s,r,e,n)}})}const zw=oc({prefix:"9",name:"base10",alphabet:"0123456789"}),Vw=Object.freeze(Object.defineProperty({__proto__:null,base10:zw},Symbol.toStringTag,{value:"Module"})),Hw=Dt({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),qw=Dt({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Ww=Object.freeze(Object.defineProperty({__proto__:null,base16:Hw,base16upper:qw},Symbol.toStringTag,{value:"Module"})),Kw=Dt({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Gw=Object.freeze(Object.defineProperty({__proto__:null,base2:Kw},Symbol.toStringTag,{value:"Module"})),l6=Array.from(""),Qw=l6.reduce((n,t,e)=>(n[e]=t,n),[]),Yw=l6.reduce((n,t,e)=>{const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);return n[r]=e,n},[]);function Xw(n){return n.reduce((t,e)=>(t+=Qw[e],t),"")}function Zw(n){const t=[];for(const e of n){const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);const s=Yw[r];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}const Jw=Bu({prefix:"",name:"base256emoji",encode:Xw,decode:Zw}),jw=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Jw},Symbol.toStringTag,{value:"Module"})),er=Dt({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),eb=Dt({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),tb=Dt({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),rb=Dt({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),nb=Dt({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),sb=Dt({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ib=Dt({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ob=Dt({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ab=Dt({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),cb=Object.freeze(Object.defineProperty({__proto__:null,base32:er,base32hex:nb,base32hexpad:ib,base32hexpadupper:ob,base32hexupper:sb,base32pad:tb,base32padupper:rb,base32upper:eb,base32z:ab},Symbol.toStringTag,{value:"Module"})),ei=oc({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),lb=oc({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),ub=Object.freeze(Object.defineProperty({__proto__:null,base36:ei,base36upper:lb},Symbol.toStringTag,{value:"Module"})),ht=oc({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),hb=oc({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),db=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ht,base58flickr:hb},Symbol.toStringTag,{value:"Module"})),kr=Dt({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),fb=Dt({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ef=Dt({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),gb=Dt({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),pb=Object.freeze(Object.defineProperty({__proto__:null,base64:kr,base64pad:fb,base64url:Ef,base64urlpad:gb},Symbol.toStringTag,{value:"Module"})),mb=Dt({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),yb=Object.freeze(Object.defineProperty({__proto__:null,base8:mb},Symbol.toStringTag,{value:"Module"})),wb=Bu({prefix:"\0",name:"identity",encode:n=>Dw(n),decode:n=>Pw(n)}),bb=Object.freeze(Object.defineProperty({__proto__:null,identity:wb},Symbol.toStringTag,{value:"Module"})),vb=new TextEncoder,Eb=new TextDecoder,Sb="json",Mu=512;function u6(n){return vb.encode(JSON.stringify(n))}function Sf(n){return JSON.parse(Eb.decode(n))}const xb=Object.freeze(Object.defineProperty({__proto__:null,code:Mu,decode:Sf,encode:u6,name:Sb},Symbol.toStringTag,{value:"Module"})),_b="raw",qr=85;function kb(n){return Ho(n)}function Ib(n){return Ho(n)}const xf=Object.freeze(Object.defineProperty({__proto__:null,code:qr,decode:Ib,encode:kb,name:_b},Symbol.toStringTag,{value:"Module"}));var Ab=h6,l2=128,Tb=-128,Cb=Math.pow(2,31);function h6(n,t,e){t=t||[],e=e||0;for(var r=e;n>=Cb;)t[e++]=n&255|l2,n/=128;for(;n&Tb;)t[e++]=n&255|l2,n>>>=7;return t[e]=n|0,h6.bytes=e-r+1,t}var Pb=Ld,Db=128,u2=127;function Ld(n,r){var e=0,r=r||0,s=0,i=r,o,a=n.length;do{if(i>=a)throw Ld.bytes=0,new RangeError("Could not decode varint");o=n[i++],e+=s<28?(o&u2)<<s:(o&u2)*Math.pow(2,s),s+=7}while(o>=Db);return Ld.bytes=i-r,e}var Rb=Math.pow(2,7),Bb=Math.pow(2,14),Mb=Math.pow(2,21),Nb=Math.pow(2,28),Lb=Math.pow(2,35),Ob=Math.pow(2,42),Fb=Math.pow(2,49),Ub=Math.pow(2,56),$b=Math.pow(2,63),zb=function(n){return n<Rb?1:n<Bb?2:n<Mb?3:n<Nb?4:n<Lb?5:n<Ob?6:n<Fb?7:n<Ub?8:n<$b?9:10},Vb={encode:Ab,decode:Pb,encodingLength:zb},Il=Vb;function Od(n,t=0){return[Il.decode(n,t),Il.decode.bytes]}function Al(n,t,e=0){return Il.encode(n,t,e),t}function Tl(n){return Il.encodingLength(n)}function On(n,t){const e=t.byteLength,r=Tl(n),s=r+Tl(e),i=new Uint8Array(s+e);return Al(n,i,0),Al(e,i,r),i.set(t,s),new _f(n,e,t,i)}function bt(n){const t=Ho(n),[e,r]=Od(t),[s,i]=Od(t.subarray(r)),o=t.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new _f(e,s,o,t)}function Hb(n,t){if(n===t)return!0;{const e=t;return n.code===e.code&&n.size===e.size&&e.bytes instanceof Uint8Array&&Cw(n.bytes,e.bytes)}}class _f{constructor(t,e,r,s){u(this,"code");u(this,"size");u(this,"digest");u(this,"bytes");this.code=t,this.size=e,this.digest=r,this.bytes=s}}const d6=0,qb="identity",f6=Ho;function Wb(n){return On(d6,f6(n))}const bs={code:d6,name:qb,encode:f6,digest:Wb};function kf({name:n,code:t,encode:e}){return new Kb(n,t,e)}class Kb{constructor(t,e,r){u(this,"name");u(this,"code");u(this,"encode");this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){const e=this.encode(t);return e instanceof Uint8Array?On(this.code,e):e.then(r=>On(this.code,r))}else throw Error("Unknown type, must be binary type")}}function g6(n){return async t=>new Uint8Array(await crypto.subtle.digest(n,t))}const gt=kf({name:"sha2-256",code:18,encode:g6("SHA-256")}),h2=kf({name:"sha2-512",code:19,encode:g6("SHA-512")});function d2(n,t){const{bytes:e,version:r}=n;switch(r){case 0:return Qb(e,Fd(n),t??ht.encoder);default:return Yb(e,Fd(n),t??er.encoder)}}const f2=new WeakMap;function Fd(n){const t=f2.get(n);if(t==null){const e=new Map;return f2.set(n,e),e}return t}var C3;class te{constructor(t,e,r,s){u(this,"code");u(this,"version");u(this,"multihash");u(this,"bytes");u(this,"/");u(this,C3,"CID");this.code=e,this.version=t,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==na)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Xb)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return te.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,r=On(t,e);return te.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return te.equals(this,t)}static equals(t,e){const r=e;return r!=null&&t.code===r.code&&t.version===r.version&&Hb(t.multihash,r.multihash)}toString(t){return d2(this,t)}toJSON(){return{"/":d2(this)}}link(){return this}[(C3=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof te)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:r,code:s,multihash:i,bytes:o}=e;return new te(r,s,i,o??g2(r,s,i.bytes))}else if(e[Zb]===!0){const{version:r,multihash:s,code:i}=e,o=bt(s);return te.create(r,i,o)}else return null}static create(t,e,r){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==na)throw new Error(`Version 0 CID must use dag-pb (code: ${na}) block encoding`);return new te(t,e,r,r.bytes)}case 1:{const s=g2(t,e,r.bytes);return new te(t,e,r,s)}default:throw new Error("Invalid version")}}static createV0(t){return te.create(0,na,t)}static createV1(t,e){return te.create(1,t,e)}static decode(t){const[e,r]=te.decodeFirst(t);if(r.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=te.inspectBytes(t),r=e.size-e.multihashSize,s=Ho(t.subarray(r,r+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=s.subarray(e.multihashSize-e.digestSize),o=new _f(e.multihashCode,e.digestSize,i,s);return[e.version===0?te.createV0(o):te.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const r=()=>{const[d,f]=Od(t.subarray(e));return e+=f,d};let s=r(),i=na;if(s===18?(s=0,e=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=e,a=r(),c=r(),l=e+c,h=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:h,size:l}}static parse(t,e){const[r,s]=Gb(t,e),i=te.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Fd(i).set(r,t),i}}function Gb(n,t){switch(n[0]){case"Q":{const e=t??ht;return[ht.prefix,e.decode(`${ht.prefix}${n}`)]}case ht.prefix:{const e=t??ht;return[ht.prefix,e.decode(n)]}case er.prefix:{const e=t??er;return[er.prefix,e.decode(n)]}case ei.prefix:{const e=t??ei;return[ei.prefix,e.decode(n)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],t.decode(n)]}}}function Qb(n,t,e){const{prefix:r}=e;if(r!==ht.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const s=t.get(r);if(s==null){const i=e.encode(n).slice(1);return t.set(r,i),i}else return s}function Yb(n,t,e){const{prefix:r}=e,s=t.get(r);if(s==null){const i=e.encode(n);return t.set(r,i),i}else return s}const na=112,Xb=18;function g2(n,t,e){const r=Tl(n),s=r+Tl(t),i=new Uint8Array(s+e.byteLength);return Al(n,i,0),Al(t,i,r),i.set(e,s),i}const Zb=Symbol.for("@ipld/js-cid/CID"),Cl={...bb,...Gw,...yb,...Vw,...Ww,...cb,...ub,...db,...pb,...jw};function p6(n,t,e,r){return{name:n,prefix:t,encoder:{name:n,prefix:t,encode:e},decoder:{decode:r}}}const p2=p6("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),xh=p6("ascii","a",n=>{let t="a";for(let e=0;e<n.length;e++)t+=String.fromCharCode(n[e]);return t},n=>{n=n.substring(1);const t=sr(n.length);for(let e=0;e<n.length;e++)t[e]=n.charCodeAt(e);return t}),m6={utf8:p2,"utf-8":p2,hex:Cl.base16,latin1:xh,ascii:xh,binary:xh,...Cl};function Y(n,t="utf8"){const e=m6[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${n}`)}function Jb(n){let r,s=8192;return function(o){if(o<1||o>4096)return sr(o);s+o>8192&&(r=sr(8192),s=0);const a=r.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class ha{constructor(t,e,r){u(this,"fn");u(this,"len");u(this,"next");u(this,"val");this.fn=t,this.len=e,this.next=void 0,this.val=r}}function _h(){}class jb{constructor(t){u(this,"head");u(this,"tail");u(this,"len");u(this,"next");this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const ev=Jb();function tv(n){return globalThis.Buffer!=null?sr(n):ev(n)}class Ud{constructor(){u(this,"len");u(this,"head");u(this,"tail");u(this,"states");this.len=0,this.head=new ha(_h,0,0),this.tail=this.head,this.states=null}_push(t,e,r){return this.tail=this.tail.next=new ha(t,e,r),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new nv((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Tc,10,Mt.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const e=Mt.fromBigInt(t);return this._push(Tc,e.length(),e)}uint64Number(t){return this._push(J4,$e(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const e=Mt.fromBigInt(t).zzEncode();return this._push(Tc,e.length(),e)}sint64Number(t){const e=Mt.fromNumber(t).zzEncode();return this._push(Tc,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(kh,1,t?1:0)}fixed32(t){return this._push(sa,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const e=Mt.fromBigInt(t);return this._push(sa,4,e.lo)._push(sa,4,e.hi)}fixed64Number(t){const e=Mt.fromNumber(t);return this._push(sa,4,e.lo)._push(sa,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(yw,4,t)}double(t){return this._push(bw,8,t)}bytes(t){const e=t.length>>>0;return e===0?this._push(kh,1,0):this.uint32(e)._push(sv,e,t)}string(t){const e=xw(t);return e!==0?this.uint32(e)._push(a6,e,t):this._push(kh,1,0)}fork(){return this.states=new jb(this),this.head=this.tail=new ha(_h,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ha(_h,0,0),this.len=0),this}ldelim(){const t=this.head,e=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=t.next,this.tail=e,this.len+=r),this}finish(){let t=this.head.next;const e=tv(this.len);let r=0;for(;t!=null;)t.fn(t.val,e,r),r+=t.len,t=t.next;return e}}function kh(n,t,e){t[e]=n&255}function rv(n,t,e){for(;n>127;)t[e++]=n&127|128,n>>>=7;t[e]=n}class nv extends ha{constructor(e,r){super(rv,e,r);u(this,"next");this.next=void 0}}function Tc(n,t,e){for(;n.hi!==0;)t[e++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)t[e++]=n.lo&127|128,n.lo=n.lo>>>7;t[e++]=n.lo}function sa(n,t,e){t[e]=n&255,t[e+1]=n>>>8&255,t[e+2]=n>>>16&255,t[e+3]=n>>>24}function sv(n,t,e){t.set(n,e)}globalThis.Buffer!=null&&(Ud.prototype.bytes=function(n){const t=n.length>>>0;return this.uint32(t),t>0&&this._push(iv,t,n),this},Ud.prototype.string=function(n){const t=globalThis.Buffer.byteLength(n);return this.uint32(t),t>0&&this._push(ov,t,n),this});function iv(n,t,e){t.set(n,e)}function ov(n,t,e){n.length<40?a6(n,t,e):t.utf8Write!=null?t.utf8Write(n,e):t.set(Y(n),e)}function av(){return new Ud}function he(n,t){const e=av();return t.encode(n,e,{lengthDelimited:!1}),e.finish()}var Pl;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(Pl||(Pl={}));function y6(n,t,e,r){return{name:n,type:t,encode:e,decode:r}}function Ht(n){function t(s){if(n[s.toString()]==null)throw new Error("Invalid enum value");return n[s]}const e=function(i,o){const a=t(i);o.int32(a)},r=function(i){const o=i.int32();return t(o)};return y6("enum",Pl.VARINT,e,r)}function de(n,t){return y6("message",Pl.LENGTH_DELIMITED,n,t)}class Fe extends Error{constructor(){super(...arguments);u(this,"code","ERR_MAX_LENGTH");u(this,"name","MaxLengthError")}}class m2 extends Error{constructor(){super(...arguments);u(this,"code","ERR_MAX_SIZE");u(this,"name","MaxSizeError")}}var _t;(function(n){n.WantBlock="WantBlock",n.WantHave="WantHave"})(_t||(_t={}));var $d;(function(n){n[n.WantBlock=0]="WantBlock",n[n.WantHave=1]="WantHave"})($d||($d={}));(function(n){n.codec=()=>Ht($d)})(_t||(_t={}));var Da;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.cid!=null&&e.cid.byteLength>0&&(r.uint32(10),r.bytes(e.cid)),e.priority!=null&&e.priority!==0&&(r.uint32(16),r.int32(e.priority)),e.cancel!=null&&(r.uint32(24),r.bool(e.cancel)),e.wantType!=null&&(r.uint32(32),_t.codec().encode(e.wantType,r)),e.sendDontHave!=null&&(r.uint32(40),r.bool(e.sendDontHave)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={cid:Ee(0),priority:0},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.cid=e.bytes();break}case 2:{i.priority=e.int32();break}case 3:{i.cancel=e.bool();break}case 4:{i.wantType=_t.codec().decode(e);break}case 5:{i.sendDontHave=e.bool();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Da||(Da={}));var Dl;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.entries!=null)for(const i of e.entries)r.uint32(10),Da.codec().encode(i,r);e.full!=null&&(r.uint32(16),r.bool(e.full)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c;const i={entries:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const l=e.uint32();switch(l>>>3){case 1:{if(((a=s.limits)==null?void 0:a.entries)!=null&&i.entries.length===s.limits.entries)throw new Fe('Decode error - map field "entries" had too many elements');i.entries.push(Da.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.entries$}));break}case 2:{i.full=e.bool();break}default:{e.skipType(l&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Dl||(Dl={}));var Ra;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.prefix!=null&&e.prefix.byteLength>0&&(r.uint32(10),r.bytes(e.prefix)),e.data!=null&&e.data.byteLength>0&&(r.uint32(18),r.bytes(e.data)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={prefix:Ee(0),data:Ee(0)},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.prefix=e.bytes();break}case 2:{i.data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Ra||(Ra={}));var hn;(function(n){n.HaveBlock="HaveBlock",n.DoNotHaveBlock="DoNotHaveBlock"})(hn||(hn={}));var Rl;(function(n){n[n.HaveBlock=0]="HaveBlock",n[n.DoNotHaveBlock=1]="DoNotHaveBlock"})(Rl||(Rl={}));(function(n){n.codec=()=>Ht(Rl)})(hn||(hn={}));var Ba;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.cid!=null&&e.cid.byteLength>0&&(r.uint32(10),r.bytes(e.cid)),e.type!=null&&Rl[e.type]!==0&&(r.uint32(16),hn.codec().encode(e.type,r)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={cid:Ee(0),type:hn.HaveBlock},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.cid=e.bytes();break}case 2:{i.type=hn.codec().decode(e);break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Ba||(Ba={}));var Ma;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.wantlist!=null&&(r.uint32(10),Dl.codec().encode(e.wantlist,r)),e.blocks!=null)for(const i of e.blocks)r.uint32(26),Ra.codec().encode(i,r);if(e.blockPresences!=null)for(const i of e.blockPresences)r.uint32(34),Ba.codec().encode(i,r);e.pendingBytes!=null&&e.pendingBytes!==0&&(r.uint32(40),r.int32(e.pendingBytes)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c,l,h,d;const i={blocks:[],blockPresences:[],pendingBytes:0},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const f=e.uint32();switch(f>>>3){case 1:{i.wantlist=Dl.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.wantlist});break}case 3:{if(((c=s.limits)==null?void 0:c.blocks)!=null&&i.blocks.length===s.limits.blocks)throw new Fe('Decode error - map field "blocks" had too many elements');i.blocks.push(Ra.codec().decode(e,e.uint32(),{limits:(l=s.limits)==null?void 0:l.blocks$}));break}case 4:{if(((h=s.limits)==null?void 0:h.blockPresences)!=null&&i.blockPresences.length===s.limits.blockPresences)throw new Fe('Decode error - map field "blockPresences" had too many elements');i.blockPresences.push(Ba.codec().decode(e,e.uint32(),{limits:(d=s.limits)==null?void 0:d.blockPresences$}));break}case 5:{i.pendingBytes=e.int32();break}default:{e.skipType(f&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Ma||(Ma={}));function cv(n,t){for(const[e,r]of t.wantlist.entries()){const s=n.wantlist.get(e);s!=null&&(s.priority>r.priority&&(r.priority=s.priority),r.cancel=r.cancel??s.cancel,r.wantType=r.wantType??s.wantType,r.sendDontHave=r.sendDontHave??s.sendDontHave),n.wantlist.set(e,r)}for(const[e,r]of t.blockPresences.entries())n.blockPresences.set(e,r);for(const[e,r]of t.blocks.entries())n.blocks.set(e,r);return t.full&&!n.full&&(n.full=!0),n}class w6 extends Error{constructor(t="Block too large"){super(t),this.name="BlockTooLargeError"}}u(w6,"name","BlockTooLargeError");const lv=4193648,uv=lv+16;function*hv(n,t){const e=[...n.wantlist.values()],r=[...n.blockPresences.values()],s=[...n.blocks.values()];let i=0,o=0,a=0,c=!1;for(;;){const l={wantlist:{full:n.full??!1,entries:[]},blockPresences:[],blocks:[],pendingBytes:0};let h=Ma.encode(l).byteLength,{added:d,hasMore:f,newSize:g}=Ih(s,l.blocks,a,t,h,dv);a+=d,h=g;const y=f;({added:d,hasMore:f,newSize:g}=Ih(r,l.blockPresences,o,t,h,fv)),o+=d,h=g;const p=f;if({added:d,hasMore:f,newSize:g}=Ih(e,l.wantlist.entries,i,t,h,gv),i+=d,h=g,c=!y&&!p&&!f,c||(l.wantlist.full=!1),yield Ma.encode(l),c)break}}function Ih(n,t,e,r,s,i){let o=0,a=!1;for(let c=e;c<n.length;c++){const l=n[c],h=i(l);if(h>uv)throw new w6("Cannot send block as after encoding it is over the max message size");const d=s+h;if(d>r){a=!0;break}t.push(l),o++,s=d}return{hasMore:a,added:o,newSize:s}}function dv(n){return If(3,Ra.encode(n))}function fv(n){return If(4,Ba.encode(n))}function gv(n){return If(1,Da.encode(n))}function If(n,t){const e=$e(n),r=$e(t.byteLength);return e+r+t.byteLength}let pv=class extends Et{constructor(e,r={}){var s,i;super();u(this,"log");u(this,"libp2p");u(this,"routing");u(this,"protocols");u(this,"running");u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"messageReceiveTimeout");u(this,"registrarIds");u(this,"metrics");u(this,"sendQueue");u(this,"runOnLimitedConnections");u(this,"maxOutgoingMessageSize");u(this,"maxIncomingMessageSize");this.log=e.logger.forComponent("helia:bitswap:network"),this.libp2p=e.libp2p,this.routing=e.routing,this.protocols=r.protocols??[Ic],this.registrarIds=[],this.running=!1,this._onStream=this._onStream.bind(this),this.maxInboundStreams=r.maxInboundStreams??lw,this.maxOutboundStreams=r.maxOutboundStreams??uw,this.messageReceiveTimeout=r.messageReceiveTimeout??hw,this.runOnLimitedConnections=r.runOnLimitedConnections??gw,this.maxIncomingMessageSize=r.maxIncomingMessageSize??o6,this.maxOutgoingMessageSize=r.maxOutgoingMessageSize??r.maxIncomingMessageSize??mw,this.metrics={blocksSent:(s=e.metrics)==null?void 0:s.registerCounter("helia_bitswap_sent_blocks_total"),dataSent:(i=e.metrics)==null?void 0:i.registerCounter("helia_bitswap_sent_data_bytes_total")},this.sendQueue=new ys({concurrency:r.messageSendConcurrency??fw,metrics:e.metrics,metricName:"helia_bitswap_message_send_queue"}),this.sendQueue.addEventListener("error",o=>{this.log.error("error sending wantlist to peer",o.detail)})}async start(){if(this.running)return;this.running=!0,await this.libp2p.handle(this.protocols,this._onStream,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnections});const e={onConnect:r=>{this.safeDispatchEvent("peer:connected",{detail:r})},onDisconnect:r=>{this.safeDispatchEvent("peer:disconnected",{detail:r})}};this.registrarIds=[];for(const r of this.protocols)this.registrarIds.push(await this.libp2p.register(r,e));this.libp2p.getConnections().forEach(r=>{this.safeDispatchEvent("peer:connected",{detail:r.remotePeer})})}async stop(){if(this.running=!1,await this.libp2p.unhandle(this.protocols),this.registrarIds!=null){for(const e of this.registrarIds)this.libp2p.unregister(e);this.registrarIds=[]}}_onStream(e){if(!this.running)return;const{stream:r,connection:s}=e;Promise.resolve().then(async()=>{this.log("incoming new bitswap %s stream from %p",r.protocol,s.remotePeer);const i=()=>{r.status==="open"?r.abort(new Pu(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`)):this.log("stream aborted with status %s",r.status)};let o=AbortSignal.timeout(this.messageReceiveTimeout);o.addEventListener("abort",i),await r.closeWrite(),await It(r,a=>Eo(a,{maxDataLength:this.maxIncomingMessageSize}),async a=>{for await(const c of a)try{const l=Ma.decode(c);this.log("incoming new bitswap %s message from %p on stream",r.protocol,s.remotePeer,r.id),this.safeDispatchEvent("bitswap:message",{detail:{peer:s.remotePeer,message:l}}),o.removeEventListener("abort",i),o=AbortSignal.timeout(this.messageReceiveTimeout),o.addEventListener("abort",i)}catch(l){this.log.error("error reading incoming bitswap message from %p on stream",s.remotePeer,r.id,l),r.abort(l);break}})}).catch(i=>{this.log.error("error handling incoming stream from %p",s.remotePeer,i),r.abort(i)})}async*findProviders(e,r){var s;(s=r==null?void 0:r.onProgress)==null||s.call(r,new se("bitswap:network:find-providers",e));for await(const i of this.routing.findProviders(e,r))await this.libp2p.isDialable(i.multiaddrs,{runOnLimitedConnection:this.runOnLimitedConnections})&&(yield i)}async findAndConnect(e,r){await ws(Un(kl(this.findProviders(e,r),(r==null?void 0:r.maxProviders)??pw),async s=>this.connectTo(s.id,r))).catch(s=>{this.log.error(s)})}async sendMessage(e,r,s){if(!this.running)throw new Error("network isn't running");const i=this.sendQueue.queue.find(o=>e.equals(o.options.peerId)&&o.status==="queued");if(i!=null){i.options.message=cv(i.options.message,r),await i.join({signal:s==null?void 0:s.signal});return}await this.sendQueue.add(async o=>{var l,h;const a=o==null?void 0:o.message;if(a==null)throw new W("No message to send");this.log("sendMessage to %p",e),(l=o==null?void 0:o.onProgress)==null||l.call(o,new se("bitswap:network:send-wantlist",e));const c=await this.libp2p.dialProtocol(e,Ic,o);await c.closeRead();try{await It(hv(a,this.maxOutgoingMessageSize),d=>vo(d),c),await c.close(o)}catch(d){(h=o==null?void 0:o.onProgress)==null||h.call(o,new se("bitswap:network:send-wantlist:error",{peer:e,error:d})),this.log.error("error sending message to %p",e,d),c.abort(d)}this._updateSentStats(a.blocks)},{peerId:e,signal:s==null?void 0:s.signal,message:r})}async connectTo(e,r){var i;if(!this.running)throw new bo("Network isn't running");(i=r==null?void 0:r.onProgress)==null||i.call(r,new se("bitswap:network:dial",e));const[s]=await Promise.all([this.libp2p.dial(e,r),_r(this.libp2p,"peer:identify",r==null?void 0:r.signal,{filter:o=>{if(!o.detail.peerId.equals(e))return!1;if(o.detail.protocols.includes(Ic))return!0;throw new ic(`${e} did not support ${Ic}`)}})]);return s}_updateSentStats(e){var s,i;let r=0;for(const o of e.values())r+=o.data.byteLength;(s=this.metrics.dataSent)==null||s.increment(r),(i=this.metrics.blocksSent)==null||i.increment(e.size)}};function to(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function mv(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function Nu(n,...t){if(!mv(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function Lu(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");to(n.outputLen),to(n.blockLen)}function Bl(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function yv(n,t){Nu(n);const e=t.outputLen;if(n.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}const Pi=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ba(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Zr(n,t){return n<<32-t|n>>>t}function Ah(n,t){return n<<t|n>>>32-t>>>0}const wv=async()=>{};async function bv(n,t,e){let r=Date.now();for(let s=0;s<n;s++){e(s);const i=Date.now()-r;i>=0&&i<t||(await wv(),r+=i)}}function vv(n){if(typeof n!="string")throw new Error("utf8ToBytes expected string, got "+typeof n);return new Uint8Array(new TextEncoder().encode(n))}function ai(n){return typeof n=="string"&&(n=vv(n)),Nu(n),n}function Ev(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];Nu(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const i=n[r];e.set(i,s),s+=i.length}return e}class b6{clone(){return this._cloneInto()}}function Sv(n,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(n,t)}function Af(n){const t=r=>n().update(ai(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function Ou(n=32){if(Pi&&typeof Pi.getRandomValues=="function")return Pi.getRandomValues(new Uint8Array(n));if(Pi&&typeof Pi.randomBytes=="function")return Pi.randomBytes(n);throw new Error("crypto.getRandomValues must be defined")}function xv(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(e>>s&i),a=Number(e&i),c=r?4:0,l=r?0:4;n.setUint32(t+c,o,r),n.setUint32(t+l,a,r)}function v6(n,t,e){return n&t^~n&e}function E6(n,t,e){return n&t^n&e^t&e}class Tf extends b6{constructor(t,e,r,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ba(this.buffer)}update(t){Bl(this);const{view:e,buffer:r,blockLen:s}=this;t=ai(t);const i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=ba(t);for(;s<=i-o;o+=s)this.process(c,o);continue}r.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Bl(this),yv(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>s-o&&(this.process(r,0),o=0);for(let d=o;d<s;d++)e[d]=0;xv(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=ba(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,h=this.get();if(l>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,h[d],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return t.length=s,t.pos=a,t.finished=i,t.destroyed=o,s%e&&t.buffer.set(r),t}}const Cc=BigInt(2**32-1),zd=BigInt(32);function S6(n,t=!1){return t?{h:Number(n&Cc),l:Number(n>>zd&Cc)}:{h:Number(n>>zd&Cc)|0,l:Number(n&Cc)|0}}function _v(n,t=!1){let e=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:i,l:o}=S6(n[s],t);[e[s],r[s]]=[i,o]}return[e,r]}const kv=(n,t)=>BigInt(n>>>0)<<zd|BigInt(t>>>0),Iv=(n,t,e)=>n>>>e,Av=(n,t,e)=>n<<32-e|t>>>e,Tv=(n,t,e)=>n>>>e|t<<32-e,Cv=(n,t,e)=>n<<32-e|t>>>e,Pv=(n,t,e)=>n<<64-e|t>>>e-32,Dv=(n,t,e)=>n>>>e-32|t<<64-e,Rv=(n,t)=>t,Bv=(n,t)=>n,Mv=(n,t,e)=>n<<e|t>>>32-e,Nv=(n,t,e)=>t<<e|n>>>32-e,Lv=(n,t,e)=>t<<e-32|n>>>64-e,Ov=(n,t,e)=>n<<e-32|t>>>64-e;function Fv(n,t,e,r){const s=(t>>>0)+(r>>>0);return{h:n+e+(s/2**32|0)|0,l:s|0}}const Uv=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),$v=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,zv=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),Vv=(n,t,e,r,s)=>t+e+r+s+(n/2**32|0)|0,Hv=(n,t,e,r,s)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(s>>>0),qv=(n,t,e,r,s,i)=>t+e+r+s+i+(n/2**32|0)|0,pe={fromBig:S6,split:_v,toBig:kv,shrSH:Iv,shrSL:Av,rotrSH:Tv,rotrSL:Cv,rotrBH:Pv,rotrBL:Dv,rotr32H:Rv,rotr32L:Bv,rotlSH:Mv,rotlSL:Nv,rotlBH:Lv,rotlBL:Ov,add:Fv,add3L:Uv,add3H:$v,add4L:zv,add4H:Vv,add5H:qv,add5L:Hv},[Wv,Kv]=pe.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),Wn=new Uint32Array(80),Kn=new Uint32Array(80);class Gv extends Tf{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:h,Fh:d,Fl:f,Gh:g,Gl:y,Hh:p,Hl:w}=this;return[t,e,r,s,i,o,a,c,l,h,d,f,g,y,p,w]}set(t,e,r,s,i,o,a,c,l,h,d,f,g,y,p,w){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=h|0,this.Fh=d|0,this.Fl=f|0,this.Gh=g|0,this.Gl=y|0,this.Hh=p|0,this.Hl=w|0}process(t,e){for(let S=0;S<16;S++,e+=4)Wn[S]=t.getUint32(e),Kn[S]=t.getUint32(e+=4);for(let S=16;S<80;S++){const I=Wn[S-15]|0,P=Kn[S-15]|0,A=pe.rotrSH(I,P,1)^pe.rotrSH(I,P,8)^pe.shrSH(I,P,7),C=pe.rotrSL(I,P,1)^pe.rotrSL(I,P,8)^pe.shrSL(I,P,7),T=Wn[S-2]|0,k=Kn[S-2]|0,N=pe.rotrSH(T,k,19)^pe.rotrBH(T,k,61)^pe.shrSH(T,k,6),$=pe.rotrSL(T,k,19)^pe.rotrBL(T,k,61)^pe.shrSL(T,k,6),z=pe.add4L(C,$,Kn[S-7],Kn[S-16]),q=pe.add4H(z,A,N,Wn[S-7],Wn[S-16]);Wn[S]=q|0,Kn[S]=z|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:h,Eh:d,El:f,Fh:g,Fl:y,Gh:p,Gl:w,Hh:v,Hl:x}=this;for(let S=0;S<80;S++){const I=pe.rotrSH(d,f,14)^pe.rotrSH(d,f,18)^pe.rotrBH(d,f,41),P=pe.rotrSL(d,f,14)^pe.rotrSL(d,f,18)^pe.rotrBL(d,f,41),A=d&g^~d&p,C=f&y^~f&w,T=pe.add5L(x,P,C,Kv[S],Kn[S]),k=pe.add5H(T,v,I,A,Wv[S],Wn[S]),N=T|0,$=pe.rotrSH(r,s,28)^pe.rotrBH(r,s,34)^pe.rotrBH(r,s,39),z=pe.rotrSL(r,s,28)^pe.rotrBL(r,s,34)^pe.rotrBL(r,s,39),q=r&i^r&a^i&a,U=s&o^s&c^o&c;v=p|0,x=w|0,p=g|0,w=y|0,g=d|0,y=f|0,{h:d,l:f}=pe.add(l|0,h|0,k|0,N|0),l=a|0,h=c|0,a=i|0,c=o|0,i=r|0,o=s|0;const L=pe.add3L(N,z,U);r=pe.add3H(L,k,$,q),s=L|0}({h:r,l:s}=pe.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=pe.add(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=pe.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:h}=pe.add(this.Dh|0,this.Dl|0,l|0,h|0),{h:d,l:f}=pe.add(this.Eh|0,this.El|0,d|0,f|0),{h:g,l:y}=pe.add(this.Fh|0,this.Fl|0,g|0,y|0),{h:p,l:w}=pe.add(this.Gh|0,this.Gl|0,p|0,w|0),{h:v,l:x}=pe.add(this.Hh|0,this.Hl|0,v|0,x|0),this.set(r,s,i,o,a,c,l,h,d,f,g,y,p,w,v,x)}roundClean(){Wn.fill(0),Kn.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Fu=Af(()=>new Gv);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Uu=BigInt(0),$u=BigInt(1),Qv=BigInt(2);function ci(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function ac(n){if(!ci(n))throw new Error("Uint8Array expected")}function Bn(n,t){if(typeof t!="boolean")throw new Error(n+" boolean expected, got "+t)}const Yv=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function li(n){ac(n);let t="";for(let e=0;e<n.length;e++)t+=Yv[n[e]];return t}function Ui(n){const t=n.toString(16);return t.length&1?"0"+t:t}function Cf(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Uu:BigInt("0x"+n)}const vn={_0:48,_9:57,A:65,F:70,a:97,f:102};function y2(n){if(n>=vn._0&&n<=vn._9)return n-vn._0;if(n>=vn.A&&n<=vn.F)return n-(vn.A-10);if(n>=vn.a&&n<=vn.f)return n-(vn.a-10)}function So(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=y2(n.charCodeAt(i)),a=y2(n.charCodeAt(i+1));if(o===void 0||a===void 0){const c=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=o*16+a}return r}function ti(n){return Cf(li(n))}function hs(n){return ac(n),Cf(li(Uint8Array.from(n).reverse()))}function xo(n,t){return So(n.toString(16).padStart(t*2,"0"))}function _o(n,t){return xo(n,t).reverse()}function Xv(n){return So(Ui(n))}function st(n,t,e){let r;if(typeof t=="string")try{r=So(t)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(ci(t))r=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(n+" of length "+e+" expected, got "+s);return r}function ui(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];ac(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const i=n[r];e.set(i,s),s+=i.length}return e}function Zv(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0}function Jv(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}const Th=n=>typeof n=="bigint"&&Uu<=n;function zu(n,t,e){return Th(n)&&Th(t)&&Th(e)&&t<=n&&n<e}function tr(n,t,e,r){if(!zu(t,e,r))throw new Error("expected valid "+n+": "+e+" <= n < "+r+", got "+t)}function x6(n){let t;for(t=0;n>Uu;n>>=$u,t+=1);return t}function jv(n,t){return n>>BigInt(t)&$u}function eE(n,t,e){return n|(e?$u:Uu)<<BigInt(t)}const Pf=n=>(Qv<<BigInt(n-1))-$u,Ch=n=>new Uint8Array(n),w2=n=>Uint8Array.from(n);function _6(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ch(n),s=Ch(n),i=0;const o=()=>{r.fill(1),s.fill(0),i=0},a=(...d)=>e(s,r,...d),c=(d=Ch())=>{s=a(w2([0]),d),r=a(),d.length!==0&&(s=a(w2([1]),d),r=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const f=[];for(;d<t;){r=a();const g=r.slice();f.push(g),d+=r.length}return ui(...f)};return(d,f)=>{o(),c(d);let g;for(;!(g=f(l()));)c();return o(),g}}const tE={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||ci(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function vi(n,t,e={}){const r=(s,i,o)=>{const a=tE[i];if(typeof a!="function")throw new Error("invalid validator function");const c=n[s];if(!(o&&c===void 0)&&!a(c,n))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(t))r(s,i,!1);for(const[s,i]of Object.entries(e))r(s,i,!0);return n}const rE=()=>{throw new Error("not implemented")};function Na(n){const t=new WeakMap;return(e,...r)=>{const s=t.get(e);if(s!==void 0)return s;const i=n(e,...r);return t.set(e,i),i}}const nE=Object.freeze(Object.defineProperty({__proto__:null,aInRange:tr,abool:Bn,abytes:ac,bitGet:jv,bitLen:x6,bitMask:Pf,bitSet:eE,bytesToHex:li,bytesToNumberBE:ti,bytesToNumberLE:hs,concatBytes:ui,createHmacDrbg:_6,ensureBytes:st,equalBytes:Zv,hexToBytes:So,hexToNumber:Cf,inRange:zu,isBytes:ci,memoized:Na,notImplemented:rE,numberToBytesBE:xo,numberToBytesLE:_o,numberToHexUnpadded:Ui,numberToVarBytesBE:Xv,utf8ToBytes:Jv,validateObject:vi},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt=BigInt(0),et=BigInt(1),Vs=BigInt(2),sE=BigInt(3),Vd=BigInt(4),b2=BigInt(5),v2=BigInt(8);function qe(n,t){const e=n%t;return e>=kt?e:t+e}function k6(n,t,e){if(t<kt)throw new Error("invalid exponent, negatives unsupported");if(e<=kt)throw new Error("invalid modulus");if(e===et)return kt;let r=et;for(;t>kt;)t&et&&(r=r*n%e),n=n*n%e,t>>=et;return r}function je(n,t,e){let r=n;for(;t-- >kt;)r*=r,r%=e;return r}function Hd(n,t){if(n===kt)throw new Error("invert: expected non-zero number");if(t<=kt)throw new Error("invert: expected positive modulus, got "+t);let e=qe(n,t),r=t,s=kt,i=et;for(;e!==kt;){const a=r/e,c=r%e,l=s-i*a;r=e,e=c,s=i,i=l}if(r!==et)throw new Error("invert: does not exist");return qe(s,t)}function iE(n){const t=(n-et)/Vs;let e,r,s;for(e=n-et,r=0;e%Vs===kt;e/=Vs,r++);for(s=Vs;s<n&&k6(s,t,n)!==n-et;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const o=(n+et)/Vd;return function(c,l){const h=c.pow(l,o);if(!c.eql(c.sqr(h),l))throw new Error("Cannot find square root");return h}}const i=(e+et)/Vs;return function(a,c){if(a.pow(c,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=r,h=a.pow(a.mul(a.ONE,s),e),d=a.pow(c,i),f=a.pow(c,e);for(;!a.eql(f,a.ONE);){if(a.eql(f,a.ZERO))return a.ZERO;let g=1;for(let p=a.sqr(f);g<l&&!a.eql(p,a.ONE);g++)p=a.sqr(p);const y=a.pow(h,et<<BigInt(l-g-1));h=a.sqr(y),d=a.mul(d,y),f=a.mul(f,h),l=g}return d}}function oE(n){if(n%Vd===sE){const t=(n+et)/Vd;return function(r,s){const i=r.pow(s,t);if(!r.eql(r.sqr(i),s))throw new Error("Cannot find square root");return i}}if(n%v2===b2){const t=(n-b2)/v2;return function(r,s){const i=r.mul(s,Vs),o=r.pow(i,t),a=r.mul(s,o),c=r.mul(r.mul(a,Vs),o),l=r.mul(a,r.sub(c,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return iE(n)}const aE=(n,t)=>(qe(n,t)&et)===et,cE=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function lE(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=cE.reduce((r,s)=>(r[s]="function",r),t);return vi(n,e)}function uE(n,t,e){if(e<kt)throw new Error("invalid exponent, negatives unsupported");if(e===kt)return n.ONE;if(e===et)return t;let r=n.ONE,s=t;for(;e>kt;)e&et&&(r=n.mul(r,s)),s=n.sqr(s),e>>=et;return r}function hE(n,t){const e=new Array(t.length),r=t.reduce((i,o,a)=>n.is0(o)?i:(e[a]=i,n.mul(i,o)),n.ONE),s=n.inv(r);return t.reduceRight((i,o,a)=>n.is0(o)?i:(e[a]=n.mul(i,e[a]),n.mul(i,o)),s),e}function I6(n,t){const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Vu(n,t,e=!1,r={}){if(n<=kt)throw new Error("invalid field: expected ORDER > 0, got "+n);const{nBitLength:s,nByteLength:i}=I6(n,t);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:n,isLE:e,BITS:s,BYTES:i,MASK:Pf(s),ZERO:kt,ONE:et,create:c=>qe(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return kt<=c&&c<n},is0:c=>c===kt,isOdd:c=>(c&et)===et,neg:c=>qe(-c,n),eql:(c,l)=>c===l,sqr:c=>qe(c*c,n),add:(c,l)=>qe(c+l,n),sub:(c,l)=>qe(c-l,n),mul:(c,l)=>qe(c*l,n),pow:(c,l)=>uE(a,c,l),div:(c,l)=>qe(c*Hd(l,n),n),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Hd(c,n),sqrt:r.sqrt||(c=>(o||(o=oE(n)),o(a,c))),invertBatch:c=>hE(a,c),cmov:(c,l,h)=>h?l:c,toBytes:c=>e?_o(c,i):xo(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return e?hs(c):ti(c)}});return Object.freeze(a)}function A6(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function T6(n){const t=A6(n);return t+Math.ceil(t/2)}function dE(n,t,e=!1){const r=n.length,s=A6(t),i=T6(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=e?hs(n):ti(n),a=qe(o,t-et)+et;return e?_o(a,s):xo(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const E2=BigInt(0),Pc=BigInt(1);function Ph(n,t){const e=t.negate();return n?e:t}function C6(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function Dh(n,t){C6(n,t);const e=Math.ceil(t/n)+1,r=2**(n-1);return{windows:e,windowSize:r}}function fE(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function gE(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const Rh=new WeakMap,P6=new WeakMap;function Bh(n){return P6.get(n)||1}function D6(n,t){return{constTimeNegate:Ph,hasPrecomputes(e){return Bh(e)!==1},unsafeLadder(e,r,s=n.ZERO){let i=e;for(;r>E2;)r&Pc&&(s=s.add(i)),i=i.double(),r>>=Pc;return s},precomputeWindow(e,r){const{windows:s,windowSize:i}=Dh(r,t),o=[];let a=e,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let h=1;h<i;h++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(e,r,s){const{windows:i,windowSize:o}=Dh(e,t);let a=n.ZERO,c=n.BASE;const l=BigInt(2**e-1),h=2**e,d=BigInt(e);for(let f=0;f<i;f++){const g=f*o;let y=Number(s&l);s>>=d,y>o&&(y-=h,s+=Pc);const p=g,w=g+Math.abs(y)-1,v=f%2!==0,x=y<0;y===0?c=c.add(Ph(v,r[p])):a=a.add(Ph(x,r[w]))}return{p:a,f:c}},wNAFUnsafe(e,r,s,i=n.ZERO){const{windows:o,windowSize:a}=Dh(e,t),c=BigInt(2**e-1),l=2**e,h=BigInt(e);for(let d=0;d<o;d++){const f=d*a;if(s===E2)break;let g=Number(s&c);if(s>>=h,g>a&&(g-=l,s+=Pc),g===0)continue;let y=r[f+Math.abs(g)-1];g<0&&(y=y.negate()),i=i.add(y)}return i},getPrecomputes(e,r,s){let i=Rh.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&Rh.set(r,s(i))),i},wNAFCached(e,r,s){const i=Bh(e);return this.wNAF(i,this.getPrecomputes(i,e,s),r)},wNAFCachedUnsafe(e,r,s,i){const o=Bh(e);return o===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,e,s),r,i)},setWindowSize(e,r){C6(r,t),P6.set(e,r),Rh.delete(e)}}}function R6(n,t,e,r){if(fE(e,n),gE(r,t),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=n.ZERO,i=x6(BigInt(e.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=(1<<o)-1,c=new Array(a+1).fill(s),l=Math.floor((t.BITS-1)/o)*o;let h=s;for(let d=l;d>=0;d-=o){c.fill(s);for(let g=0;g<r.length;g++){const y=r[g],p=Number(y>>BigInt(d)&BigInt(a));c[p]=c[p].add(e[g])}let f=s;for(let g=c.length-1,y=s;g>0;g--)y=y.add(c[g]),f=f.add(y);if(h=h.add(f),d!==0)for(let g=0;g<o;g++)h=h.double()}return h}function Df(n){return lE(n.Fp),vi(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...I6(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Cr=BigInt(0),Gt=BigInt(1),Dc=BigInt(2),pE=BigInt(8),mE={zip215:!0};function yE(n){const t=Df(n);return vi(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function wE(n){const t=yE(n),{Fp:e,n:r,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=t,l=Dc<<BigInt(a*8)-Gt,h=e.create,d=Vu(t.n,t.nBitLength),f=t.uvRatio||((M,R)=>{try{return{isValid:!0,value:e.sqrt(M*e.inv(R))}}catch{return{isValid:!1,value:Cr}}}),g=t.adjustScalarBytes||(M=>M),y=t.domain||((M,R,V)=>{if(Bn("phflag",V),R.length||V)throw new Error("Contexts/pre-hash are not supported");return M});function p(M,R){tr("coordinate "+M,R,Cr,l)}function w(M){if(!(M instanceof S))throw new Error("ExtendedPoint expected")}const v=Na((M,R)=>{const{ex:V,ey:F,ez:K}=M,J=M.is0();R==null&&(R=J?pE:e.inv(K));const re=h(V*R),ae=h(F*R),j=h(K*R);if(J)return{x:Cr,y:Gt};if(j!==Gt)throw new Error("invZ was invalid");return{x:re,y:ae}}),x=Na(M=>{const{a:R,d:V}=t;if(M.is0())throw new Error("bad point: ZERO");const{ex:F,ey:K,ez:J,et:re}=M,ae=h(F*F),j=h(K*K),oe=h(J*J),we=h(oe*oe),Pe=h(ae*R),De=h(oe*h(Pe+j)),Me=h(we+h(V*h(ae*j)));if(De!==Me)throw new Error("bad point: equation left != right (1)");const ot=h(F*K),Je=h(J*re);if(ot!==Je)throw new Error("bad point: equation left != right (2)");return!0});class S{constructor(R,V,F,K){this.ex=R,this.ey=V,this.ez=F,this.et=K,p("x",R),p("y",V),p("z",F),p("t",K),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(R){if(R instanceof S)throw new Error("extended point not allowed");const{x:V,y:F}=R||{};return p("x",V),p("y",F),new S(V,F,Gt,h(V*F))}static normalizeZ(R){const V=e.invertBatch(R.map(F=>F.ez));return R.map((F,K)=>F.toAffine(V[K])).map(S.fromAffine)}static msm(R,V){return R6(S,d,R,V)}_setWindowSize(R){A.setWindowSize(this,R)}assertValidity(){x(this)}equals(R){w(R);const{ex:V,ey:F,ez:K}=this,{ex:J,ey:re,ez:ae}=R,j=h(V*ae),oe=h(J*K),we=h(F*ae),Pe=h(re*K);return j===oe&&we===Pe}is0(){return this.equals(S.ZERO)}negate(){return new S(h(-this.ex),this.ey,this.ez,h(-this.et))}double(){const{a:R}=t,{ex:V,ey:F,ez:K}=this,J=h(V*V),re=h(F*F),ae=h(Dc*h(K*K)),j=h(R*J),oe=V+F,we=h(h(oe*oe)-J-re),Pe=j+re,De=Pe-ae,Me=j-re,ot=h(we*De),Je=h(Pe*Me),at=h(we*Me),Le=h(De*Pe);return new S(ot,Je,Le,at)}add(R){w(R);const{a:V,d:F}=t,{ex:K,ey:J,ez:re,et:ae}=this,{ex:j,ey:oe,ez:we,et:Pe}=R;if(V===BigInt(-1)){const Ti=h((J-K)*(oe+j)),xc=h((J+K)*(oe-j)),ta=h(xc-Ti);if(ta===Cr)return this.double();const ra=h(re*Dc*Pe),Ns=h(ae*Dc*we),ar=Ns+ra,Ci=xc+Ti,_c=Ns-ra,Yr=h(ar*ta),wh=h(Ci*_c),E=h(ar*_c),m=h(ta*Ci);return new S(Yr,wh,m,E)}const De=h(K*j),Me=h(J*oe),ot=h(ae*F*Pe),Je=h(re*we),at=h((K+J)*(j+oe)-De-Me),Le=Je-ot,ct=Je+ot,lt=h(Me-V*De),qn=h(at*Le),Ms=h(ct*lt),mh=h(at*lt),yh=h(Le*ct);return new S(qn,Ms,yh,mh)}subtract(R){return this.add(R.negate())}wNAF(R){return A.wNAFCached(this,R,S.normalizeZ)}multiply(R){const V=R;tr("scalar",V,Gt,r);const{p:F,f:K}=this.wNAF(V);return S.normalizeZ([F,K])[0]}multiplyUnsafe(R,V=S.ZERO){const F=R;return tr("scalar",F,Cr,r),F===Cr?P:this.is0()||F===Gt?this:A.wNAFCachedUnsafe(this,F,S.normalizeZ,V)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return A.unsafeLadder(this,r).is0()}toAffine(R){return v(this,R)}clearCofactor(){const{h:R}=t;return R===Gt?this:this.multiplyUnsafe(R)}static fromHex(R,V=!1){const{d:F,a:K}=t,J=e.BYTES;R=st("pointHex",R,J),Bn("zip215",V);const re=R.slice(),ae=R[J-1];re[J-1]=ae&-129;const j=hs(re),oe=V?l:e.ORDER;tr("pointHex.y",j,Cr,oe);const we=h(j*j),Pe=h(we-Gt),De=h(F*we-K);let{isValid:Me,value:ot}=f(Pe,De);if(!Me)throw new Error("Point.fromHex: invalid y coordinate");const Je=(ot&Gt)===Gt,at=(ae&128)!==0;if(!V&&ot===Cr&&at)throw new Error("Point.fromHex: x=0 and x_0=1");return at!==Je&&(ot=h(-ot)),S.fromAffine({x:ot,y:j})}static fromPrivateKey(R){return k(R).point}toRawBytes(){const{x:R,y:V}=this.toAffine(),F=_o(V,e.BYTES);return F[F.length-1]|=R&Gt?128:0,F}toHex(){return li(this.toRawBytes())}}S.BASE=new S(t.Gx,t.Gy,Gt,h(t.Gx*t.Gy)),S.ZERO=new S(Cr,Gt,Gt,Cr);const{BASE:I,ZERO:P}=S,A=D6(S,a*8);function C(M){return qe(M,r)}function T(M){return C(hs(M))}function k(M){const R=e.BYTES;M=st("private key",M,R);const V=st("hashed private key",i(M),2*R),F=g(V.slice(0,R)),K=V.slice(R,2*R),J=T(F),re=I.multiply(J),ae=re.toRawBytes();return{head:F,prefix:K,scalar:J,point:re,pointBytes:ae}}function N(M){return k(M).pointBytes}function $(M=new Uint8Array,...R){const V=ui(...R);return T(i(y(V,st("context",M),!!s)))}function z(M,R,V={}){M=st("message",M),s&&(M=s(M));const{prefix:F,scalar:K,pointBytes:J}=k(R),re=$(V.context,F,M),ae=I.multiply(re).toRawBytes(),j=$(V.context,ae,J,M),oe=C(re+j*K);tr("signature.s",oe,Cr,r);const we=ui(ae,_o(oe,e.BYTES));return st("result",we,e.BYTES*2)}const q=mE;function U(M,R,V,F=q){const{context:K,zip215:J}=F,re=e.BYTES;M=st("signature",M,2*re),R=st("message",R),V=st("publicKey",V,re),J!==void 0&&Bn("zip215",J),s&&(R=s(R));const ae=hs(M.slice(re,2*re));let j,oe,we;try{j=S.fromHex(V,J),oe=S.fromHex(M.slice(0,re),J),we=I.multiplyUnsafe(ae)}catch{return!1}if(!J&&j.isSmallOrder())return!1;const Pe=$(K,oe.toRawBytes(),j.toRawBytes(),R);return oe.add(j.multiplyUnsafe(Pe)).subtract(we).clearCofactor().equals(S.ZERO)}return I._setWindowSize(8),{CURVE:t,getPublicKey:N,sign:z,verify:U,ExtendedPoint:S,utils:{getExtendedPublicKey:k,randomPrivateKey:()=>o(e.BYTES),precompute(M=8,R=S.BASE){return R._setWindowSize(M),R.multiply(BigInt(3)),R}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Di=BigInt(0),Mh=BigInt(1);function bE(n){return vi(n,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n})}function vE(n){const t=bE(n),{P:e}=t,r=x=>qe(x,e),s=t.montgomeryBits,i=Math.ceil(s/8),o=t.nByteLength,a=t.adjustScalarBytes||(x=>x),c=t.powPminus2||(x=>k6(x,e-BigInt(2),e));function l(x,S,I){const P=r(x*(S-I));return S=r(S-P),I=r(I+P),[S,I]}const h=(t.a-BigInt(2))/BigInt(4);function d(x,S){tr("u",x,Di,e),tr("scalar",S,Di,e);const I=S,P=x;let A=Mh,C=Di,T=x,k=Mh,N=Di,$;for(let q=BigInt(s-1);q>=Di;q--){const U=I>>q&Mh;N^=U,$=l(N,A,T),A=$[0],T=$[1],$=l(N,C,k),C=$[0],k=$[1],N=U;const L=A+C,M=r(L*L),R=A-C,V=r(R*R),F=M-V,K=T+k,J=T-k,re=r(J*L),ae=r(K*R),j=re+ae,oe=re-ae;T=r(j*j),k=r(P*r(oe*oe)),A=r(M*V),C=r(F*(M+r(h*F)))}$=l(N,A,T),A=$[0],T=$[1],$=l(N,C,k),C=$[0],k=$[1];const z=c(C);return r(A*z)}function f(x){return _o(r(x),i)}function g(x){const S=st("u coordinate",x,i);return o===32&&(S[31]&=127),hs(S)}function y(x){const S=st("scalar",x),I=S.length;if(I!==i&&I!==o){let P=""+i+" or "+o;throw new Error("invalid scalar, expected "+P+" bytes, got "+I)}return hs(a(S))}function p(x,S){const I=g(S),P=y(x),A=d(I,P);if(A===Di)throw new Error("invalid private or public key received");return f(A)}const w=f(t.Gu);function v(x){return p(x,w)}return{scalarMult:p,scalarMultBase:v,getSharedSecret:(x,S)=>p(x,S),getPublicKey:x=>v(x),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:w}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const La=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),S2=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const EE=BigInt(1),x2=BigInt(2),SE=BigInt(3),xE=BigInt(5),_E=BigInt(8);function B6(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),i=La,a=n*n%i*n%i,c=je(a,x2,i)*a%i,l=je(c,EE,i)*n%i,h=je(l,xE,i)*l%i,d=je(h,t,i)*h%i,f=je(d,e,i)*d%i,g=je(f,r,i)*f%i,y=je(g,s,i)*g%i,p=je(y,s,i)*g%i,w=je(p,t,i)*h%i;return{pow_p_5_8:je(w,x2,i)*n%i,b2:a}}function M6(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function kE(n,t){const e=La,r=qe(t*t*t,e),s=qe(r*r*t,e),i=B6(n*s).pow_p_5_8;let o=qe(n*r*i,e);const a=qe(t*o*o,e),c=o,l=qe(o*S2,e),h=a===n,d=a===qe(-n,e),f=a===qe(-n*S2,e);return h&&(o=c),(d||f)&&(o=l),aE(o,e)&&(o=qe(-o,e)),{isValid:h||d,value:o}}const IE=Vu(La,void 0,!0),AE={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:IE,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:_E,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Fu,randomBytes:Ou,adjustScalarBytes:M6,uvRatio:kE},Ml=wE(AE),Rc=vE({P:La,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:n=>{const t=La,{pow_p_5_8:e,b2:r}=B6(n);return qe(je(e,SE,t)*r,t)},adjustScalarBytes:M6,randomBytes:Ou}),Nl=32,Zn=64,qd=32;function TE(){const n=Ml.utils.randomPrivateKey(),t=Ml.getPublicKey(n);return{privateKey:DE(n,t),publicKey:t}}function CE(n,t){const e=n.subarray(0,qd);return Ml.sign(t instanceof Uint8Array?t:t.subarray(),e)}function PE(n,t,e){return Ml.verify(t,e instanceof Uint8Array?e:e.subarray(),n)}function DE(n,t){const e=new Uint8Array(Zn);for(let r=0;r<qd;r++)e[r]=n[r],e[qd+r]=t[r];return e}class N6{constructor(t){u(this,"type","Ed25519");u(this,"raw");this.raw=Oa(t,Nl)}toMultihash(){return bs.digest(Ur(this))}toCID(){return te.createV1(114,this.toMultihash())}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:_e(this.raw,t.raw)}verify(t,e){return PE(this.raw,e,t)}}class Wd{constructor(t,e){u(this,"type","Ed25519");u(this,"raw");u(this,"publicKey");this.raw=Oa(t,Zn),this.publicKey=new N6(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:_e(this.raw,t.raw)}sign(t){return CE(this.raw,t)}}function L6(n){if(n.length>Zn){n=Oa(n,Zn+Nl);const r=n.subarray(0,Zn),s=n.subarray(Zn,n.length);return new Wd(r,s)}n=Oa(n,Zn);const t=n.subarray(0,Zn),e=n.subarray(Nl);return new Wd(t,e)}function O6(n){return n=Oa(n,Nl),new N6(n)}async function RE(){const{privateKey:n,publicKey:t}=TE();return new Wd(n,t)}function Oa(n,t){if(n=Uint8Array.from(n??[]),n.length!==t)throw new W(`Key must be a Uint8Array of length ${t}, got ${n.length}`);return n}var dt;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.secp256k1="secp256k1"})(dt||(dt={}));var Kd;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.secp256k1=2]="secp256k1"})(Kd||(Kd={}));(function(n){n.codec=()=>Ht(Kd)})(dt||(dt={}));var vs;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.Type!=null&&(r.uint32(8),dt.codec().encode(e.Type,r)),e.Data!=null&&(r.uint32(18),r.bytes(e.Data)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=dt.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(vs||(vs={}));var Ll;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.Type!=null&&(r.uint32(8),dt.codec().encode(e.Type,r)),e.Data!=null&&(r.uint32(18),r.bytes(e.Data)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=dt.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Ll||(Ll={}));const BE=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Gn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Qn=new Uint32Array(64);class ME extends Tf{constructor(){super(64,32,8,!1),this.A=Gn[0]|0,this.B=Gn[1]|0,this.C=Gn[2]|0,this.D=Gn[3]|0,this.E=Gn[4]|0,this.F=Gn[5]|0,this.G=Gn[6]|0,this.H=Gn[7]|0}get(){const{A:t,B:e,C:r,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,r,s,i,o,a,c]}set(t,e,r,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let d=0;d<16;d++,e+=4)Qn[d]=t.getUint32(e,!1);for(let d=16;d<64;d++){const f=Qn[d-15],g=Qn[d-2],y=Zr(f,7)^Zr(f,18)^f>>>3,p=Zr(g,17)^Zr(g,19)^g>>>10;Qn[d]=p+Qn[d-7]+y+Qn[d-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:c,G:l,H:h}=this;for(let d=0;d<64;d++){const f=Zr(a,6)^Zr(a,11)^Zr(a,25),g=h+f+v6(a,c,l)+BE[d]+Qn[d]|0,p=(Zr(r,2)^Zr(r,13)^Zr(r,22))+E6(r,s,i)|0;h=l,l=c,c=a,a=o+g|0,o=i,i=s,s=r,r=g+p|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,h=h+this.H|0,this.set(r,s,i,o,a,c,l,h)}roundClean(){Qn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const ds=Af(()=>new ME);function Z(n,t="utf8"){const e=m6[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(n).substring(1)}const NE=parseInt("11111",2),Gd=parseInt("10000000",2),LE=parseInt("01111111",2),_2={2:OE,3:$E,5:UE,6:FE,16:Nh,22:Nh,48:Nh};function Hu(n,t={offset:0}){const e=n[t.offset]&NE;if(t.offset++,_2[e]!=null)return _2[e](n,t);throw new Error("No decoder for tag "+e)}function qu(n,t){let e=0;if((n[t.offset]&Gd)===Gd){const r=n[t.offset]&LE;let s="0x";t.offset++;for(let i=0;i<r;i++,t.offset++)s+=n[t.offset].toString(16).padStart(2,"0");e=parseInt(s,16)}else e=n[t.offset],t.offset++;return e}function Nh(n,t){qu(n,t);const e=[];for(;!(t.offset>=n.byteLength);){const r=Hu(n,t);if(r===null)break;e.push(r)}return e}function OE(n,t){const e=qu(n,t),r=t.offset,s=t.offset+e,i=[];for(let o=r;o<s;o++)o===r&&n[o]===0||i.push(n[o]);return t.offset+=e,Uint8Array.from(i)}function FE(n,t){const e=qu(n,t);return t.offset+=e,["oid-unimplemented"]}function UE(n,t){return t.offset++,null}function $E(n,t){const e=qu(n,t),r=n[t.offset];t.offset++;const s=n.subarray(t.offset,t.offset+e);if(t.offset+=e,r!==0)throw new Error("Unused bits in bit string is unimplemented");return Hu(s,{offset:0})}function zE(n){let t=n.toString(16);t.length%2===1&&(t="0"+t);const e=new ye;for(let r=0;r<t.length;r+=2)e.append(Uint8Array.from([parseInt(`${t[r]}${t[r+1]}`,16)]));return e}function Rf(n){if(n.byteLength<128)return Uint8Array.from([n.byteLength]);const t=zE(n.byteLength);return new ye(Uint8Array.from([t.byteLength|Gd]),t)}function Rr(n){const t=new ye,e=parseInt("10000000",2);return(n.subarray()[0]&e)===e&&t.append(Uint8Array.from([0])),t.append(n),new ye(Uint8Array.from([2]),Rf(t),t)}function VE(n){const t=Uint8Array.from([0]),e=new ye(t,n);return new ye(Uint8Array.from([3]),Rf(e),e)}function Qd(n){const t=new ye;for(const e of n)t.append(e);return new ye(Uint8Array.from([48]),Rf(t),t)}function Es(n){if(isNaN(n)||n<=0)throw new W("random bytes length must be a Number bigger than 0");return Ou(n)}class k2 extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class I2 extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class HE extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const pn={get(n=globalThis){const t=n.crypto;if((t==null?void 0:t.subtle)==null)throw new HE("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};async function qE(n){const t=await pn.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:n,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),e=await GE(t);return{privateKey:e[0],publicKey:e[1]}}async function WE(n,t){const e=await pn.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await pn.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},e,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(r,0,r.byteLength)}async function KE(n,t,e){const r=await pn.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return pn.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,e instanceof Uint8Array?e:e.subarray())}async function GE(n){if(n.privateKey==null||n.publicKey==null)throw new W("Private and public key are required");return Promise.all([pn.get().subtle.exportKey("jwk",n.privateKey),pn.get().subtle.exportKey("jwk",n.publicKey)])}function QE(n){if(n.kty!=="RSA")throw new W("invalid key type");if(n.n==null)throw new W("invalid key modulus");return Y(n.n,"base64url").length*8}class Bf{constructor(t,e){u(this,"type","RSA");u(this,"_key");u(this,"_raw");u(this,"_multihash");this._key=t,this._multihash=e}get raw(){return this._raw==null&&(this._raw=Nf(this._key)),this._raw}toMultihash(){return this._multihash}toCID(){return te.createV1(114,this._multihash)}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:_e(this.raw,t.raw)}verify(t,e){return KE(this._key,e,t)}}class F6{constructor(t,e){u(this,"type","RSA");u(this,"_key");u(this,"_raw");u(this,"publicKey");this._key=t,this.publicKey=e}get raw(){return this._raw==null&&(this._raw=jE(this._key)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:_e(this.raw,t.raw)}sign(t){return WE(this._key,t)}}const YE=8192,Mf=18,XE=1062,ZE=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function JE(n){const t=Hu(n);return{n:Z(t[1],"base64url"),e:Z(t[2],"base64url"),d:Z(t[3],"base64url"),p:Z(t[4],"base64url"),q:Z(t[5],"base64url"),dp:Z(t[6],"base64url"),dq:Z(t[7],"base64url"),qi:Z(t[8],"base64url"),kty:"RSA"}}function jE(n){if(n.n==null||n.e==null||n.d==null||n.p==null||n.q==null||n.dp==null||n.dq==null||n.qi==null)throw new W("JWK was missing components");return Qd([Rr(Uint8Array.from([0])),Rr(Y(n.n,"base64url")),Rr(Y(n.e,"base64url")),Rr(Y(n.d,"base64url")),Rr(Y(n.p,"base64url")),Rr(Y(n.q,"base64url")),Rr(Y(n.dp,"base64url")),Rr(Y(n.dq,"base64url")),Rr(Y(n.qi,"base64url"))]).subarray()}function eS(n){const t=Hu(n,{offset:0});return{kty:"RSA",n:Z(t[1][0],"base64url"),e:Z(t[1][1],"base64url")}}function Nf(n){if(n.n==null||n.e==null)throw new W("JWK was missing components");return Qd([ZE,VE(Qd([Rr(Y(n.n,"base64url")),Rr(Y(n.e,"base64url"))]))]).subarray()}function U6(n){const t=JE(n);return rS(t)}function tS(n,t){if(n.byteLength>=XE)throw new Pa("Key size is too large");const e=eS(n);if(t==null){const r=ds(vs.encode({Type:dt.RSA,Data:n}));t=On(Mf,r)}return new Bf(e,t)}function rS(n){if(QE(n)>YE)throw new W("Key size is too large");const t=sS(n),e=ds(vs.encode({Type:dt.RSA,Data:Nf(t.publicKey)})),r=On(Mf,e);return new F6(t.privateKey,new Bf(t.publicKey,r))}async function nS(n){const t=await qE(n),e=ds(vs.encode({Type:dt.RSA,Data:Nf(t.publicKey)})),r=On(Mf,e);return new F6(t.privateKey,new Bf(t.publicKey,r))}function sS(n){if(n==null)throw new W("Missing key parameter");return{privateKey:n,publicKey:{kty:n.kty,n:n.n,e:n.e}}}class $6 extends b6{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Lu(t);const r=ai(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?t.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=t.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),i.fill(0)}update(t){return Bl(this),this.iHash.update(t),this}digestInto(t){Bl(this),Nu(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const cc=(n,t,e)=>new $6(n,t).update(e).digest();cc.create=(n,t)=>new $6(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function A2(n){n.lowS!==void 0&&Bn("lowS",n.lowS),n.prehash!==void 0&&Bn("prehash",n.prehash)}function iS(n){const t=Df(n);vi(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=t;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:oS,hexToBytes:aS}=nE;class cS extends Error{constructor(t=""){super(t)}}const An={Err:cS,_tlv:{encode:(n,t)=>{const{Err:e}=An;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const r=t.length/2,s=Ui(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?Ui(s.length/2|128):"";return Ui(n)+i+s+t},decode(n,t){const{Err:e}=An;let r=0;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[r++]!==n)throw new e("tlv.decode: wrong tlv");const s=t[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const l=t.subarray(r,r+c);if(l.length!==c)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const h of l)o=o<<8|h;if(r+=c,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(r,r+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(r+o)}}},_int:{encode(n){const{Err:t}=An;if(n<Cn)throw new t("integer: negative integers are not allowed");let e=Ui(n);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(n){const{Err:t}=An;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return oS(n)}},toSig(n){const{Err:t,_int:e,_tlv:r}=An,s=typeof n=="string"?aS(n):n;ac(s);const{v:i,l:o}=r.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:l,l:h}=r.decode(2,c);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(l)}},hexFromSig(n){const{_tlv:t,_int:e}=An,r=t.encode(2,e.encode(n.r)),s=t.encode(2,e.encode(n.s)),i=r+s;return t.encode(48,i)}},Cn=BigInt(0),xt=BigInt(1);BigInt(2);const T2=BigInt(3);BigInt(4);function lS(n){const t=iS(n),{Fp:e}=t,r=Vu(t.n,t.nBitLength),s=t.toBytes||((p,w,v)=>{const x=w.toAffine();return ui(Uint8Array.from([4]),e.toBytes(x.x),e.toBytes(x.y))}),i=t.fromBytes||(p=>{const w=p.subarray(1),v=e.fromBytes(w.subarray(0,e.BYTES)),x=e.fromBytes(w.subarray(e.BYTES,2*e.BYTES));return{x:v,y:x}});function o(p){const{a:w,b:v}=t,x=e.sqr(p),S=e.mul(x,p);return e.add(e.add(S,e.mul(p,w)),v)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function a(p){return zu(p,xt,t.n)}function c(p){const{allowedPrivateKeyLengths:w,nByteLength:v,wrapPrivateKey:x,n:S}=t;if(w&&typeof p!="bigint"){if(ci(p)&&(p=li(p)),typeof p!="string"||!w.includes(p.length))throw new Error("invalid private key");p=p.padStart(v*2,"0")}let I;try{I=typeof p=="bigint"?p:ti(st("private key",p,v))}catch{throw new Error("invalid private key, expected hex or "+v+" bytes, got "+typeof p)}return x&&(I=qe(I,S)),tr("private key",I,xt,S),I}function l(p){if(!(p instanceof f))throw new Error("ProjectivePoint expected")}const h=Na((p,w)=>{const{px:v,py:x,pz:S}=p;if(e.eql(S,e.ONE))return{x:v,y:x};const I=p.is0();w==null&&(w=I?e.ONE:e.inv(S));const P=e.mul(v,w),A=e.mul(x,w),C=e.mul(S,w);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(C,e.ONE))throw new Error("invZ was invalid");return{x:P,y:A}}),d=Na(p=>{if(p.is0()){if(t.allowInfinityPoint&&!e.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:w,y:v}=p.toAffine();if(!e.isValid(w)||!e.isValid(v))throw new Error("bad point: x or y not FE");const x=e.sqr(v),S=o(w);if(!e.eql(x,S))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class f{constructor(w,v,x){if(this.px=w,this.py=v,this.pz=x,w==null||!e.isValid(w))throw new Error("x required");if(v==null||!e.isValid(v))throw new Error("y required");if(x==null||!e.isValid(x))throw new Error("z required");Object.freeze(this)}static fromAffine(w){const{x:v,y:x}=w||{};if(!w||!e.isValid(v)||!e.isValid(x))throw new Error("invalid affine point");if(w instanceof f)throw new Error("projective point not allowed");const S=I=>e.eql(I,e.ZERO);return S(v)&&S(x)?f.ZERO:new f(v,x,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(w){const v=e.invertBatch(w.map(x=>x.pz));return w.map((x,S)=>x.toAffine(v[S])).map(f.fromAffine)}static fromHex(w){const v=f.fromAffine(i(st("pointHex",w)));return v.assertValidity(),v}static fromPrivateKey(w){return f.BASE.multiply(c(w))}static msm(w,v){return R6(f,r,w,v)}_setWindowSize(w){y.setWindowSize(this,w)}assertValidity(){d(this)}hasEvenY(){const{y:w}=this.toAffine();if(e.isOdd)return!e.isOdd(w);throw new Error("Field doesn't support isOdd")}equals(w){l(w);const{px:v,py:x,pz:S}=this,{px:I,py:P,pz:A}=w,C=e.eql(e.mul(v,A),e.mul(I,S)),T=e.eql(e.mul(x,A),e.mul(P,S));return C&&T}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:w,b:v}=t,x=e.mul(v,T2),{px:S,py:I,pz:P}=this;let A=e.ZERO,C=e.ZERO,T=e.ZERO,k=e.mul(S,S),N=e.mul(I,I),$=e.mul(P,P),z=e.mul(S,I);return z=e.add(z,z),T=e.mul(S,P),T=e.add(T,T),A=e.mul(w,T),C=e.mul(x,$),C=e.add(A,C),A=e.sub(N,C),C=e.add(N,C),C=e.mul(A,C),A=e.mul(z,A),T=e.mul(x,T),$=e.mul(w,$),z=e.sub(k,$),z=e.mul(w,z),z=e.add(z,T),T=e.add(k,k),k=e.add(T,k),k=e.add(k,$),k=e.mul(k,z),C=e.add(C,k),$=e.mul(I,P),$=e.add($,$),k=e.mul($,z),A=e.sub(A,k),T=e.mul($,N),T=e.add(T,T),T=e.add(T,T),new f(A,C,T)}add(w){l(w);const{px:v,py:x,pz:S}=this,{px:I,py:P,pz:A}=w;let C=e.ZERO,T=e.ZERO,k=e.ZERO;const N=t.a,$=e.mul(t.b,T2);let z=e.mul(v,I),q=e.mul(x,P),U=e.mul(S,A),L=e.add(v,x),M=e.add(I,P);L=e.mul(L,M),M=e.add(z,q),L=e.sub(L,M),M=e.add(v,S);let R=e.add(I,A);return M=e.mul(M,R),R=e.add(z,U),M=e.sub(M,R),R=e.add(x,S),C=e.add(P,A),R=e.mul(R,C),C=e.add(q,U),R=e.sub(R,C),k=e.mul(N,M),C=e.mul($,U),k=e.add(C,k),C=e.sub(q,k),k=e.add(q,k),T=e.mul(C,k),q=e.add(z,z),q=e.add(q,z),U=e.mul(N,U),M=e.mul($,M),q=e.add(q,U),U=e.sub(z,U),U=e.mul(N,U),M=e.add(M,U),z=e.mul(q,M),T=e.add(T,z),z=e.mul(R,M),C=e.mul(L,C),C=e.sub(C,z),z=e.mul(L,q),k=e.mul(R,k),k=e.add(k,z),new f(C,T,k)}subtract(w){return this.add(w.negate())}is0(){return this.equals(f.ZERO)}wNAF(w){return y.wNAFCached(this,w,f.normalizeZ)}multiplyUnsafe(w){const{endo:v,n:x}=t;tr("scalar",w,Cn,x);const S=f.ZERO;if(w===Cn)return S;if(this.is0()||w===xt)return this;if(!v||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,w,f.normalizeZ);let{k1neg:I,k1:P,k2neg:A,k2:C}=v.splitScalar(w),T=S,k=S,N=this;for(;P>Cn||C>Cn;)P&xt&&(T=T.add(N)),C&xt&&(k=k.add(N)),N=N.double(),P>>=xt,C>>=xt;return I&&(T=T.negate()),A&&(k=k.negate()),k=new f(e.mul(k.px,v.beta),k.py,k.pz),T.add(k)}multiply(w){const{endo:v,n:x}=t;tr("scalar",w,xt,x);let S,I;if(v){const{k1neg:P,k1:A,k2neg:C,k2:T}=v.splitScalar(w);let{p:k,f:N}=this.wNAF(A),{p:$,f:z}=this.wNAF(T);k=y.constTimeNegate(P,k),$=y.constTimeNegate(C,$),$=new f(e.mul($.px,v.beta),$.py,$.pz),S=k.add($),I=N.add(z)}else{const{p:P,f:A}=this.wNAF(w);S=P,I=A}return f.normalizeZ([S,I])[0]}multiplyAndAddUnsafe(w,v,x){const S=f.BASE,I=(A,C)=>C===Cn||C===xt||!A.equals(S)?A.multiplyUnsafe(C):A.multiply(C),P=I(this,v).add(I(w,x));return P.is0()?void 0:P}toAffine(w){return h(this,w)}isTorsionFree(){const{h:w,isTorsionFree:v}=t;if(w===xt)return!0;if(v)return v(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:w,clearCofactor:v}=t;return w===xt?this:v?v(f,this):this.multiplyUnsafe(t.h)}toRawBytes(w=!0){return Bn("isCompressed",w),this.assertValidity(),s(f,this,w)}toHex(w=!0){return Bn("isCompressed",w),li(this.toRawBytes(w))}}f.BASE=new f(t.Gx,t.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const g=t.nBitLength,y=D6(f,t.endo?Math.ceil(g/2):g);return{CURVE:t,ProjectivePoint:f,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function uS(n){const t=Df(n);return vi(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function hS(n){const t=uS(n),{Fp:e,n:r}=t,s=e.BYTES+1,i=2*e.BYTES+1;function o(U){return qe(U,r)}function a(U){return Hd(U,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:h,isWithinCurveOrder:d}=lS({...t,toBytes(U,L,M){const R=L.toAffine(),V=e.toBytes(R.x),F=ui;return Bn("isCompressed",M),M?F(Uint8Array.from([L.hasEvenY()?2:3]),V):F(Uint8Array.from([4]),V,e.toBytes(R.y))},fromBytes(U){const L=U.length,M=U[0],R=U.subarray(1);if(L===s&&(M===2||M===3)){const V=ti(R);if(!zu(V,xt,e.ORDER))throw new Error("Point is not on curve");const F=h(V);let K;try{K=e.sqrt(F)}catch(ae){const j=ae instanceof Error?": "+ae.message:"";throw new Error("Point is not on curve"+j)}const J=(K&xt)===xt;return(M&1)===1!==J&&(K=e.neg(K)),{x:V,y:K}}else if(L===i&&M===4){const V=e.fromBytes(R.subarray(0,e.BYTES)),F=e.fromBytes(R.subarray(e.BYTES,2*e.BYTES));return{x:V,y:F}}else{const V=s,F=i;throw new Error("invalid Point, expected length of "+V+", or uncompressed "+F+", got "+L)}}}),f=U=>li(xo(U,t.nByteLength));function g(U){const L=r>>xt;return U>L}function y(U){return g(U)?o(-U):U}const p=(U,L,M)=>ti(U.slice(L,M));class w{constructor(L,M,R){this.r=L,this.s=M,this.recovery=R,this.assertValidity()}static fromCompact(L){const M=t.nByteLength;return L=st("compactSignature",L,M*2),new w(p(L,0,M),p(L,M,2*M))}static fromDER(L){const{r:M,s:R}=An.toSig(st("DER",L));return new w(M,R)}assertValidity(){tr("r",this.r,xt,r),tr("s",this.s,xt,r)}addRecoveryBit(L){return new w(this.r,this.s,L)}recoverPublicKey(L){const{r:M,s:R,recovery:V}=this,F=A(st("msgHash",L));if(V==null||![0,1,2,3].includes(V))throw new Error("recovery id invalid");const K=V===2||V===3?M+t.n:M;if(K>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const J=(V&1)===0?"02":"03",re=c.fromHex(J+f(K)),ae=a(K),j=o(-F*ae),oe=o(R*ae),we=c.BASE.multiplyAndAddUnsafe(re,j,oe);if(!we)throw new Error("point at infinify");return we.assertValidity(),we}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return So(this.toDERHex())}toDERHex(){return An.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return So(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const v={isValidPrivateKey(U){try{return l(U),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const U=T6(t.n);return dE(t.randomBytes(U),t.n)},precompute(U=8,L=c.BASE){return L._setWindowSize(U),L.multiply(BigInt(3)),L}};function x(U,L=!0){return c.fromPrivateKey(U).toRawBytes(L)}function S(U){const L=ci(U),M=typeof U=="string",R=(L||M)&&U.length;return L?R===s||R===i:M?R===2*s||R===2*i:U instanceof c}function I(U,L,M=!0){if(S(U))throw new Error("first arg must be private key");if(!S(L))throw new Error("second arg must be public key");return c.fromHex(L).multiply(l(U)).toRawBytes(M)}const P=t.bits2int||function(U){if(U.length>8192)throw new Error("input is too large");const L=ti(U),M=U.length*8-t.nBitLength;return M>0?L>>BigInt(M):L},A=t.bits2int_modN||function(U){return o(P(U))},C=Pf(t.nBitLength);function T(U){return tr("num < 2^"+t.nBitLength,U,Cn,C),xo(U,t.nByteLength)}function k(U,L,M=N){if(["recovered","canonical"].some(De=>De in M))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:V}=t;let{lowS:F,prehash:K,extraEntropy:J}=M;F==null&&(F=!0),U=st("msgHash",U),A2(M),K&&(U=st("prehashed msgHash",R(U)));const re=A(U),ae=l(L),j=[T(ae),T(re)];if(J!=null&&J!==!1){const De=J===!0?V(e.BYTES):J;j.push(st("extraEntropy",De))}const oe=ui(...j),we=re;function Pe(De){const Me=P(De);if(!d(Me))return;const ot=a(Me),Je=c.BASE.multiply(Me).toAffine(),at=o(Je.x);if(at===Cn)return;const Le=o(ot*o(we+at*ae));if(Le===Cn)return;let ct=(Je.x===at?0:2)|Number(Je.y&xt),lt=Le;return F&&g(Le)&&(lt=y(Le),ct^=1),new w(at,lt,ct)}return{seed:oe,k2sig:Pe}}const N={lowS:t.lowS,prehash:!1},$={lowS:t.lowS,prehash:!1};function z(U,L,M=N){const{seed:R,k2sig:V}=k(U,L,M),F=t;return _6(F.hash.outputLen,F.nByteLength,F.hmac)(R,V)}c.BASE._setWindowSize(8);function q(U,L,M,R=$){var ct;const V=U;L=st("msgHash",L),M=st("publicKey",M);const{lowS:F,prehash:K,format:J}=R;if(A2(R),"strict"in R)throw new Error("options.strict was renamed to lowS");if(J!==void 0&&J!=="compact"&&J!=="der")throw new Error("format must be compact or der");const re=typeof V=="string"||ci(V),ae=!re&&!J&&typeof V=="object"&&V!==null&&typeof V.r=="bigint"&&typeof V.s=="bigint";if(!re&&!ae)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,oe;try{if(ae&&(j=new w(V.r,V.s)),re){try{J!=="compact"&&(j=w.fromDER(V))}catch(lt){if(!(lt instanceof An.Err))throw lt}!j&&J!=="der"&&(j=w.fromCompact(V))}oe=c.fromHex(M)}catch{return!1}if(!j||F&&j.hasHighS())return!1;K&&(L=t.hash(L));const{r:we,s:Pe}=j,De=A(L),Me=a(Pe),ot=o(De*Me),Je=o(we*Me),at=(ct=c.BASE.multiplyAndAddUnsafe(oe,ot,Je))==null?void 0:ct.toAffine();return at?o(at.x)===we:!1}return{CURVE:t,getPublicKey:x,getSharedSecret:I,sign:z,verify:q,ProjectivePoint:c,Signature:w,utils:v}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function dS(n){return{hash:n,hmac:(t,...e)=>cc(n,t,Ev(...e)),randomBytes:Ou}}function fS(n,t){const e=r=>hS({...n,...dS(r)});return{...e(t),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const z6=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),C2=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),gS=BigInt(1),Yd=BigInt(2),P2=(n,t)=>(n+t/Yd)/t;function pS(n){const t=z6,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=n*n*n%t,h=l*l*n%t,d=je(h,e,t)*h%t,f=je(d,e,t)*h%t,g=je(f,Yd,t)*l%t,y=je(g,s,t)*g%t,p=je(y,i,t)*y%t,w=je(p,a,t)*p%t,v=je(w,c,t)*w%t,x=je(v,a,t)*p%t,S=je(x,e,t)*h%t,I=je(S,o,t)*y%t,P=je(I,r,t)*l%t,A=je(P,Yd,t);if(!Xd.eql(Xd.sqr(A),n))throw new Error("Cannot find square root");return A}const Xd=Vu(z6,void 0,void 0,{sqrt:pS}),mn=fS({a:BigInt(0),b:BigInt(7),Fp:Xd,n:C2,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=C2,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-gS*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,o=BigInt("0x100000000000000000000000000000000"),a=P2(i*n,t),c=P2(-r*n,t);let l=qe(n-a*e-c*s,t),h=qe(-a*r-c*i,t);const d=l>o,f=h>o;if(d&&(l=t-l),f&&(h=t-h),l>o||h>o)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:d,k1:l,k2neg:f,k2:h}}}},ds);BigInt(0);mn.ProjectivePoint;function V6(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function mS(n,t){const e=gt.digest(t instanceof Uint8Array?t:t.subarray());if(V6(e))return e.then(({digest:r})=>mn.sign(r,n).toDERRawBytes()).catch(r=>{throw new k2(String(r))});try{return mn.sign(e.digest,n).toDERRawBytes()}catch(r){throw new k2(String(r))}}function yS(n,t,e){const r=gt.digest(e instanceof Uint8Array?e:e.subarray());if(V6(r))return r.then(({digest:s})=>mn.verify(t,s,n)).catch(s=>{throw new I2(String(s))});try{return mn.verify(t,r.digest,n)}catch(s){throw new I2(String(s))}}class H6{constructor(t){u(this,"type","secp256k1");u(this,"raw");u(this,"_key");this._key=ES(t),this.raw=bS(this._key)}toMultihash(){return bs.digest(Ur(this))}toCID(){return te.createV1(114,this.toMultihash())}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:_e(this.raw,t.raw)}verify(t,e){return yS(this._key,e,t)}}class q6{constructor(t,e){u(this,"type","secp256k1");u(this,"raw");u(this,"publicKey");this.raw=vS(t),this.publicKey=new H6(e??SS(t))}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:_e(this.raw,t.raw)}sign(t){return mS(this.raw,t)}}function W6(n){return new q6(n)}function K6(n){return new H6(n)}async function wS(){const n=xS();return new q6(n)}function bS(n){return mn.ProjectivePoint.fromHex(n).toRawBytes(!0)}function vS(n){try{return mn.getPublicKey(n,!0),n}catch(t){throw new of(String(t))}}function ES(n){try{return mn.ProjectivePoint.fromHex(n),n}catch(t){throw new Pa(String(t))}}function SS(n){try{return mn.getPublicKey(n,!0)}catch(t){throw new of(String(t))}}function xS(){return mn.utils.randomPrivateKey()}async function G6(n,t){if(n==="Ed25519")return RE();if(n==="secp256k1")return wS();if(n==="RSA")return nS(2048);throw new bi}function ir(n,t){const{Type:e,Data:r}=vs.decode(n),s=r??new Uint8Array;switch(e){case dt.RSA:return tS(s,t);case dt.Ed25519:return O6(s);case dt.secp256k1:return K6(s);default:throw new bi}}function Q6(n){const{Type:t,Data:e}=vs.decode(n.digest),r=e??new Uint8Array;switch(t){case dt.Ed25519:return O6(r);case dt.secp256k1:return K6(r);default:throw new bi}}function Ur(n){return vs.encode({Type:dt[n.type],Data:n.raw})}function _S(n){const t=Ll.decode(n),e=t.Data??new Uint8Array;switch(t.Type){case dt.RSA:return U6(e);case dt.Ed25519:return L6(e);case dt.secp256k1:return W6(e);default:throw new bi}}function kS(n){return n.byteLength===64?L6(n):n.byteLength===32?W6(n):U6(n)}function Wu(n){return Ll.encode({Type:dt[n.type],Data:n.raw})}const Y6=Symbol.for("nodejs.util.inspect.custom"),IS=114;var P3;class Lf{constructor(t){u(this,"type");u(this,"multihash");u(this,"publicKey");u(this,"string");u(this,P3,!0);this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=ht.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return te.createV1(IS,this.multihash)}toJSON(){return this.toString()}equals(t){var e;if(t==null)return!1;if(t instanceof Uint8Array)return _e(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(((e=t==null?void 0:t.toMultihash())==null?void 0:e.bytes)!=null)return _e(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[(P3=nf,Y6)](){return`PeerId(${this.toString()})`}}class X6 extends Lf{constructor(e){super({...e,type:"RSA"});u(this,"type","RSA");u(this,"publicKey");this.publicKey=e.publicKey}}class Z6 extends Lf{constructor(e){super({...e,type:"Ed25519"});u(this,"type","Ed25519");u(this,"publicKey");this.publicKey=e.publicKey}}class J6 extends Lf{constructor(e){super({...e,type:"secp256k1"});u(this,"type","secp256k1");u(this,"publicKey");this.publicKey=e.publicKey}}const AS=2336;var D3,R3;class j6{constructor(t){u(this,"type","url");u(this,"multihash");u(this,"publicKey");u(this,"url");u(this,D3,!0);this.url=t.toString(),this.multihash=bs.digest(Y(this.url))}[(R3=Y6,D3=nf,R3)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return te.createV1(AS,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=Z(t)),t.toString()===this.toString())}}const TS=114,D2=2336;function ut(n,t){let e;if(n.charAt(0)==="1"||n.charAt(0)==="Q")e=bt(ht.decode(`z${n}`));else{if(n.startsWith("k51qzi5uqu5")||n.startsWith("kzwfwjn5ji4")||n.startsWith("k2k4r8")||n.startsWith("bafz"))return qo(te.parse(n));throw new W('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return pr(e)}function ko(n){if(n.type==="Ed25519")return new Z6({multihash:n.toCID().multihash,publicKey:n});if(n.type==="secp256k1")return new J6({multihash:n.toCID().multihash,publicKey:n});if(n.type==="RSA")return new X6({multihash:n.toCID().multihash,publicKey:n});throw new bi}function CS(n){return ko(n.publicKey)}function pr(n){if(DS(n))return new X6({multihash:n});if(PS(n))try{const t=Q6(n);if(t.type==="Ed25519")return new Z6({multihash:n,publicKey:t});if(t.type==="secp256k1")return new J6({multihash:n,publicKey:t})}catch{const e=Z(n.digest);return new j6(new URL(e))}throw new Cu("Supplied PeerID Multihash is invalid")}function qo(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==TS&&n.code!==D2)throw new Q4("Supplied PeerID CID is invalid");if(n.code===D2){const t=Z(n.multihash.digest);return new j6(new URL(t))}return pr(n.multihash)}function PS(n){return n.code===bs.code}function DS(n){return n.code===gt.code}function va(n,t){const e={[Symbol.iterator]:()=>e,next:()=>{const r=n.next(),s=r.value;return r.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:t(s)}}};return e}function Lh(n){const t=bt(ht.decode(`z${n}`));return pr(t)}class Ps{constructor(t){u(this,"map");if(this.map=new Map,t!=null)for(const[e,r]of t.entries())this.map.set(e.toString(),{key:e,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(t){return this.map.delete(t.toString())}entries(){return va(this.map.entries(),t=>[t[1].key,t[1].value])}forEach(t){this.map.forEach((e,r)=>{t(e.value,e.key,this)})}get(t){var e;return(e=this.map.get(t.toString()))==null?void 0:e.value}has(t){return this.map.has(t.toString())}set(t,e){this.map.set(t.toString(),{key:t,value:e})}keys(){return va(this.map.values(),t=>t.key)}values(){return va(this.map.values(),t=>t.value)}get size(){return this.map.size}}class $r{constructor(t){u(this,"set");if(this.set=new Set,t!=null)for(const e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return va(this.set.entries(),t=>{const e=Lh(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{const r=Lh(e);t(r,r,this)})}has(t){return this.set.has(t.toString())}values(){return va(this.set.values(),t=>Lh(t))}intersection(t){const e=new $r;for(const r of t)this.has(r)&&e.add(r);return e}difference(t){const e=new $r;for(const r of this)t.has(r)||e.add(r);return e}union(t){const e=new $r;for(const r of t)e.add(r);for(const r of this)e.add(r);return e}}function RS(){return new $r}function e5(n,t,e,r){Lu(n);const s=Sv({dkLen:32,asyncTick:10},r),{c:i,dkLen:o,asyncTick:a}=s;if(to(i),to(o),to(a),i<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const c=ai(t),l=ai(e),h=new Uint8Array(o),d=cc.create(n,c),f=d._cloneInto().update(l);return{c:i,dkLen:o,asyncTick:a,DK:h,PRF:d,PRFSalt:f}}function t5(n,t,e,r,s){return n.destroy(),t.destroy(),r&&r.destroy(),s.fill(0),e}function BS(n,t,e,r){const{c:s,dkLen:i,DK:o,PRF:a,PRFSalt:c}=e5(n,t,e,r);let l;const h=new Uint8Array(4),d=ba(h),f=new Uint8Array(a.outputLen);for(let g=1,y=0;y<i;g++,y+=a.outputLen){const p=o.subarray(y,y+a.outputLen);d.setInt32(0,g,!1),(l=c._cloneInto(l)).update(h).digestInto(f),p.set(f.subarray(0,p.length));for(let w=1;w<s;w++){a._cloneInto(l).update(f).digestInto(f);for(let v=0;v<p.length;v++)p[v]^=f[v]}}return t5(a,c,o,l,f)}async function r5(n,t,e,r){const{c:s,dkLen:i,asyncTick:o,DK:a,PRF:c,PRFSalt:l}=e5(n,t,e,r);let h;const d=new Uint8Array(4),f=ba(d),g=new Uint8Array(c.outputLen);for(let y=1,p=0;p<i;y++,p+=c.outputLen){const w=a.subarray(p,p+c.outputLen);f.setInt32(0,y,!1),(h=l._cloneInto(h)).update(d).digestInto(g),w.set(g.subarray(0,w.length)),await bv(s-1,o,()=>{c._cloneInto(h).update(g).digestInto(g);for(let v=0;v<w.length;v++)w[v]^=g[v]})}return t5(c,l,a,h,g)}const ia=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),Yn=new Uint32Array(80);class MS extends Tf{constructor(){super(64,20,8,!1),this.A=ia[0]|0,this.B=ia[1]|0,this.C=ia[2]|0,this.D=ia[3]|0,this.E=ia[4]|0}get(){const{A:t,B:e,C:r,D:s,E:i}=this;return[t,e,r,s,i]}set(t,e,r,s,i){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=i|0}process(t,e){for(let c=0;c<16;c++,e+=4)Yn[c]=t.getUint32(e,!1);for(let c=16;c<80;c++)Yn[c]=Ah(Yn[c-3]^Yn[c-8]^Yn[c-14]^Yn[c-16],1);let{A:r,B:s,C:i,D:o,E:a}=this;for(let c=0;c<80;c++){let l,h;c<20?(l=v6(s,i,o),h=1518500249):c<40?(l=s^i^o,h=1859775393):c<60?(l=E6(s,i,o),h=2400959708):(l=s^i^o,h=3395469782);const d=Ah(r,5)+l+a+h+Yn[c]|0;a=o,o=i,i=Ah(s,30),s=r,r=d}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,this.set(r,s,i,o,a)}roundClean(){Yn.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}}const NS=Af(()=>new MS),R2={sha1:NS,"sha2-256":ds,"sha2-512":Fu};function B2(n,t,e,r,s){if(s!=="sha1"&&s!=="sha2-256"&&s!=="sha2-512"){const a=Object.keys(R2).join(" / ");throw new W(`Hash '${s}' is unknown or not supported. Must be ${a}`)}const i=R2[s],o=BS(i,n,t,{c:e,dkLen:r});return kr.encode(o).substring(1)}const Of={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},n5={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},s5=new globalThis.TextEncoder;function LS(n,t){const e=Of[t];let r=n5[t];for(let s=0;s<n.length;s++)r^=BigInt(n[s]),r=BigInt.asUintN(t,r*e);return r}function OS(n,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const r=Of[t];let s=n5[t],i=n;for(;i.length>0;){const o=s5.encodeInto(i,e);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(e[a]),s=BigInt.asUintN(t,s*r)}return s}function FS(n,{size:t=32,utf8Buffer:e}={}){if(!Of[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof n=="string"){if(e)return OS(n,t,e);n=s5.encode(n)}return LS(n,t)}const Ff={hash:n=>Number(FS(n,{size:32})),hashV:(n,t)=>US(Ff.hash(n,t))};function US(n){let t=n.toString(16);return t.length%2===1&&(t=`0${t}`),Y(t,"base16")}const i5=64;class Ks{constructor(t,e,r,s=2){u(this,"fp");u(this,"h");u(this,"seed");if(s>i5)throw new TypeError("Invalid Fingerprint Size");const i=e.hashV(t,r),o=Ee(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=e,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return(t==null?void 0:t.fp)instanceof Uint8Array?_e(this.fp,t.fp):!1}}function Ol(n,t){return Math.floor(Math.random()*(t-n))+n}let Bc=class{constructor(t){u(this,"contents");this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof Ks))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof Ks))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof Ks))throw new TypeError("Invalid Fingerprint");const e=Ol(0,this.contents.length-1),r=this.contents[e];return this.contents[e]=t,r}remove(t){if(!(t instanceof Ks))throw new TypeError("Invalid Fingerprint");const e=this.contents.findIndex(r=>t.equals(r));return e>-1?(this.contents[e]=null,!0):!1}};const $S=500;class M2{constructor(t){u(this,"bucketSize");u(this,"filterSize");u(this,"fingerprintSize");u(this,"buckets");u(this,"count");u(this,"hash");u(this,"seed");this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??Ff,this.seed=t.seed??Ol(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=Y(t));const e=new Ks(t,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(t,this.seed)%this.filterSize,s=(r^e.hash())%this.filterSize;if(this.buckets[r]==null&&(this.buckets[r]=new Bc(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Bc(this.bucketSize)),this.buckets[r].add(e)||this.buckets[s].add(e))return this.count++,!0;const i=[r,s];let o=i[Ol(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Bc(this.bucketSize));for(let a=0;a<$S;a++){const c=this.buckets[o].swap(e);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Bc(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(t){var o,a;typeof t=="string"&&(t=Y(t));const e=new Ks(t,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(t,this.seed)%this.filterSize,s=((o=this.buckets[r])==null?void 0:o.has(e))??!1;if(s)return s;const i=(r^e.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(e))??!1}remove(t){var a,c;typeof t=="string"&&(t=Y(t));const e=new Ks(t,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(t,this.seed)%this.filterSize,s=((a=this.buckets[r])==null?void 0:a.remove(e))??!1;if(s)return this.count--,s;const i=(r^e.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(e))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const zS={1:.5,2:.84,4:.95,8:.98};function VS(n=.001){return n>.002?2:n>1e-5?4:8}function HS(n,t=.001){const e=VS(t),r=zS[e],s=Math.round(n/r),i=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),i5);return{filterSize:s,bucketSize:e,fingerprintSize:i}}class o5{constructor(t){u(this,"filterSize");u(this,"bucketSize");u(this,"fingerprintSize");u(this,"scale");u(this,"filterSeries");u(this,"hash");u(this,"seed");this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??Ff,this.seed=t.seed??Ol(0,Math.pow(2,10)),this.filterSeries=[new M2({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=Y(t)),this.has(t))return!0;let e=this.filterSeries.find(r=>r.reliable);if(e==null){const r=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new M2({filterSize:r,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=Y(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=Y(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}}function hi(n,t=.001,e){return new o5({...HS(n,t)})}class qS{constructor(t,e){u(this,"filter");this.filter=hi(t,e)}has(t){return this.filter.has(t.toMultihash().bytes)}add(t){this.filter.add(t.toMultihash().bytes)}remove(t){var e,r;(r=(e=this.filter).remove)==null||r.call(e,t.toMultihash().bytes)}}function WS(n,t=.001){return new qS(n,t)}class KS extends Ps{constructor(e){super();u(this,"metric");const{name:r,metrics:s}=e;this.metric=s.registerMetric(r),this.updateComponentMetric()}set(e,r){return super.set(e,r),this.updateComponentMetric(),this}delete(e){const r=super.delete(e);return this.updateComponentMetric(),r}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function a5(n){const{name:t,metrics:e}=n;let r;return e!=null?r=new KS({name:t,metrics:e}):r=new Ps,r}class da{constructor(t=!1,e=0){u(this,"full");u(this,"pendingBytes");u(this,"wantlist");u(this,"blocks");u(this,"blockPresences");this.full=t,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}addWantlistEntry(t,e){const r=kr.encode(t.multihash.bytes);this.wantlist.set(r,e)}addBlockPresence(t,e){const r=kr.encode(t.multihash.bytes);this.blockPresences.set(r,e)}addBlock(t,e){const r=kr.encode(t.multihash.bytes);this.blocks.set(r,e)}}function GS(n){let t=new Uint8Array(n.reduce((r,s)=>r+$e(s),0)),e=0;for(const r of n)t=Lt(r,t,e),e+=$e(r);return t}function N2(n){return GS([n.version,n.code,n.multihash.code,n.multihash.digest.byteLength])}class QS{constructor(t,e){u(this,"peerId");u(this,"blockstore");u(this,"network");u(this,"wants");u(this,"exchangeCount");u(this,"bytesSent");u(this,"bytesReceived");u(this,"lastExchange");u(this,"maxSizeReplaceHasWithBlock");u(this,"log");this.peerId=t.peerId,this.blockstore=t.blockstore,this.network=t.network,this.wants=new Map,this.log=t.logger.forComponent(`helia:bitswap:ledger:${t.peerId}`),this.exchangeCount=0,this.bytesSent=0,this.bytesReceived=0,this.maxSizeReplaceHasWithBlock=e.maxSizeReplaceHasWithBlock??cw}sentBytes(t){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.bytesSent+=t}receivedBytes(t){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.bytesReceived+=t}debtRatio(){return this.bytesSent/(this.bytesReceived+1)}async sendBlocksToPeer(t){const e=new da,r=new Set;for(const[s,i]of this.wants.entries())try{const o=await this.blockstore.get(i.cid,t);i.wantType===_t.WantHave?o.byteLength<this.maxSizeReplaceHasWithBlock?(this.log("sending have and block for %c",i.cid),r.add(s),e.addBlock(i.cid,{data:o,prefix:N2(i.cid)})):(this.log("sending have for %c",i.cid),e.addBlockPresence(i.cid,{cid:i.cid.bytes,type:hn.HaveBlock})):(this.log("sending block for %c",i.cid),r.add(s),e.addBlock(i.cid,{data:o,prefix:N2(i.cid)}))}catch(o){if(o.name!=="NotFoundError")throw o;if(this.log("do not have block for %c",i.cid),!i.sendDontHave||i.sentDoNotHave===!0)continue;i.sentDoNotHave=!0,e.addBlockPresence(i.cid,{cid:i.cid.bytes,type:hn.DoNotHaveBlock})}if(e.blocks.size>0||e.blockPresences.size>0){this.log("sending message"),await this.network.sendMessage(this.peerId,e,t),this.log("sent message"),this.sentBytes([...e.blocks.values()].reduce((s,i)=>s+i.data.byteLength,0));for(const s of r)this.wants.delete(s)}}}class YS{constructor(t,e={}){u(this,"blockstore");u(this,"network");u(this,"ledgerMap");u(this,"maxSizeReplaceHasWithBlock");u(this,"log");u(this,"logger");this.blockstore=t.blockstore,this.network=t.network,this.maxSizeReplaceHasWithBlock=e.maxSizeReplaceHasWithBlock,this.log=t.logger.forComponent("helia:bitswap:peer-want-lists"),this.logger=t.logger,this.ledgerMap=a5({name:"helia_bitswap_ledger_map",metrics:t.metrics}),this.network.addEventListener("bitswap:message",r=>{this.receiveMessage(r.detail.peer,r.detail.message).catch(s=>{this.log.error("error receiving bitswap message from %p",r.detail.peer,s)})}),this.network.addEventListener("peer:disconnected",r=>{this.peerDisconnected(r.detail)})}ledgerForPeer(t){const e=this.ledgerMap.get(t);if(e!=null)return{peer:e.peerId,value:e.debtRatio(),sent:e.bytesSent,received:e.bytesReceived,exchanged:e.exchangeCount}}wantListForPeer(t){const e=this.ledgerMap.get(t);if(e!=null)return[...e.wants.values()]}peers(){return Array.from(this.ledgerMap.values()).map(t=>t.peerId)}async receiveMessage(t,e){var s;let r=this.ledgerMap.get(t);if(r==null&&(r=new QS({peerId:t,blockstore:this.blockstore,network:this.network,logger:this.logger},{maxSizeReplaceHasWithBlock:this.maxSizeReplaceHasWithBlock}),this.ledgerMap.set(t,r)),r.receivedBytes(((s=e.blocks)==null?void 0:s.reduce((i,o)=>i+o.data.byteLength,0))??0),e.wantlist!=null){e.wantlist.full===!0&&r.wants.clear();for(const i of e.wantlist.entries){const o=te.decode(i.cid),a=Z(o.multihash.bytes,"base64");i.cancel===!0?(this.log("peer %p cancelled want of block for %c",t,o),r.wants.delete(a)):(i.wantType===_t.WantHave?this.log("peer %p wanted block presence for %c",t,o):this.log("peer %p wanted block for %c",t,o),r.wants.set(a,{cid:o,priority:i.priority,wantType:i.wantType??_t.WantBlock,sendDontHave:i.sendDontHave??!1}))}}this.log("send blocks to peer"),await r.sendBlocksToPeer()}async receivedBlock(t,e){const r=Z(t.multihash.bytes,"base64"),s=[];for(const i of this.ledgerMap.values())i.wants.has(r)&&s.push(i);await Promise.all(s.map(async i=>i.sendBlocksToPeer(e)))}peerDisconnected(t){this.ledgerMap.delete(t)}}const Io=1e3,Ao=Io*60,To=Ao*60,di=To*24,XS=di*7,ZS=di*365.25;function c5(n,t){try{if(typeof n=="string"&&n.length>0)return JS(n);if(typeof n=="number"&&isFinite(n))return t!=null&&t.long?ex(n):jS(n);throw new Error("Value is not a string or number.")}catch(e){const r=tx(e)?`${e.message}. value=${JSON.stringify(n)}`:"An unknown error has occured.";throw new Error(r)}}function JS(n){if(n=String(n),n.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const t=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);if(!t)return NaN;const e=parseFloat(t[1]),r=(t[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return e*ZS;case"weeks":case"week":case"w":return e*XS;case"days":case"day":case"d":return e*di;case"hours":case"hour":case"hrs":case"hr":case"h":return e*To;case"minutes":case"minute":case"mins":case"min":case"m":return e*Ao;case"seconds":case"second":case"secs":case"sec":case"s":return e*Io;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return e;default:throw new Error(`The unit ${r} was matched, but no matching case exists.`)}}function jS(n){const t=Math.abs(n);return t>=di?`${Math.round(n/di)}d`:t>=To?`${Math.round(n/To)}h`:t>=Ao?`${Math.round(n/Ao)}m`:t>=Io?`${Math.round(n/Io)}s`:`${n}ms`}function ex(n){const t=Math.abs(n);return t>=di?Mc(n,t,di,"day"):t>=To?Mc(n,t,To,"hour"):t>=Ao?Mc(n,t,Ao,"minute"):t>=Io?Mc(n,t,Io,"second"):`${n} ms`}function Mc(n,t,e,r){const s=t>=e*1.5;return`${Math.round(n/e)} ${r}${s?"s":""}`}function tx(n){return typeof n=="object"&&n!==null&&"message"in n}function rx(n){e.debug=e,e.default=e,e.coerce=c,e.disable=i,e.enable=s,e.enabled=o,e.humanize=c5,e.destroy=l,Object.keys(n).forEach(h=>{e[h]=n[h]}),e.names=[],e.skips=[],e.formatters={};function t(h){let d=0;for(let f=0;f<h.length;f++)d=(d<<5)-d+h.charCodeAt(f),d|=0;return e.colors[Math.abs(d)%e.colors.length]}e.selectColor=t;function e(h){let d,f=null,g,y;function p(...w){if(!p.enabled)return;const v=p,x=Number(new Date),S=x-(d||x);v.diff=S,v.prev=d,v.curr=x,d=x,w[0]=e.coerce(w[0]),typeof w[0]!="string"&&w.unshift("%O");let I=0;w[0]=w[0].replace(/%([a-zA-Z%])/g,(A,C)=>{if(A==="%%")return"%";I++;const T=e.formatters[C];if(typeof T=="function"){const k=w[I];A=T.call(v,k),w.splice(I,1),I--}return A}),e.formatArgs.call(v,w),(v.log||e.log).apply(v,w)}return p.namespace=h,p.useColors=e.useColors(),p.color=e.selectColor(h),p.extend=r,p.destroy=e.destroy,Object.defineProperty(p,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(g!==e.namespaces&&(g=e.namespaces,y=e.enabled(h)),y),set:w=>{f=w}}),typeof e.init=="function"&&e.init(p),p}function r(h,d){const f=e(this.namespace+(typeof d>"u"?":":d)+h);return f.log=this.log,f}function s(h){e.save(h),e.namespaces=h,e.names=[],e.skips=[];let d;const f=(typeof h=="string"?h:"").split(/[\s,]+/),g=f.length;for(d=0;d<g;d++)f[d]&&(h=f[d].replace(/\*/g,".*?"),h[0]==="-"?e.skips.push(new RegExp("^"+h.substr(1)+"$")):e.names.push(new RegExp("^"+h+"$")))}function i(){const h=[...e.names.map(a),...e.skips.map(a).map(d=>"-"+d)].join(",");return e.enable(""),h}function o(h){if(h[h.length-1]==="*")return!0;let d,f;for(d=0,f=e.skips.length;d<f;d++)if(e.skips[d].test(h))return!1;for(d=0,f=e.names.length;d<f;d++)if(e.names[d].test(h))return!0;return!1}function a(h){return h.toString().substring(2,h.toString().length-2).replace(/\.\*\?$/,"*")}function c(h){return h instanceof Error?h.stack??h.message:h}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return e.setupFormatters(e.formatters),e.enable(e.load()),e}var nx={};const an=ux(),sx=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function ix(){var n,t,e,r,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((e=(t=document.documentElement)==null?void 0:t.style)==null?void 0:e.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function ox(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+c5(this.diff),!this.useColors)return;const t="color: "+this.color;n.splice(1,0,t,"color: inherit");let e=0,r=0;n[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(e++,s==="%c"&&(r=e))}),n.splice(r,0,t)}const ax=console.debug??console.log??(()=>{});function cx(n){try{n?an==null||an.setItem("debug",n):an==null||an.removeItem("debug")}catch{}}function lx(){let n;try{n=an==null?void 0:an.getItem("debug")}catch{}return!n&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(n=nx.DEBUG),n}function ux(){try{return localStorage}catch{}}function hx(n){n.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}const dr=rx({formatArgs:ox,save:cx,load:lx,useColors:ix,setupFormatters:hx,colors:sx,storage:an,log:ax});dr.formatters.b=n=>n==null?"undefined":ht.baseEncode(n);dr.formatters.t=n=>n==null?"undefined":er.baseEncode(n);dr.formatters.m=n=>n==null?"undefined":kr.baseEncode(n);dr.formatters.p=n=>n==null?"undefined":n.toString();dr.formatters.c=n=>n==null?"undefined":n.toString();dr.formatters.k=n=>n==null?"undefined":n.toString();dr.formatters.a=n=>n==null?"undefined":n.toString();dr.formatters.e=n=>n==null?"undefined":L2(n.stack)??L2(n.message)??n.toString();function dx(n){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=n,t.destroy=()=>!0,t.extend=()=>t,t}function Ku(){return{forComponent(n){return Ot(n)}}}function Ot(n){let t=dx(`${n}:trace`);return dr.enabled(`${n}:trace`)&&dr.names.map(e=>e.toString()).find(e=>e.includes(":trace"))!=null&&(t=dr(`${n}:trace`)),Object.assign(dr(n),{error:dr(`${n}:error`),trace:t})}function L2(n){if(n!=null&&(n=n.trim(),n.length!==0))return n}var Oh={exports:{}},O2;function fx(){return O2||(O2=1,function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(c,l,h){this.fn=c,this.context=l,this.once=h||!1}function i(c,l,h,d,f){if(typeof h!="function")throw new TypeError("The listener must be a function");var g=new s(h,d||c,f),y=e?e+l:l;return c._events[y]?c._events[y].fn?c._events[y]=[c._events[y],g]:c._events[y].push(g):(c._events[y]=g,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],h,d;if(this._eventsCount===0)return l;for(d in h=this._events)t.call(h,d)&&l.push(e?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(h)):l},a.prototype.listeners=function(l){var h=e?e+l:l,d=this._events[h];if(!d)return[];if(d.fn)return[d.fn];for(var f=0,g=d.length,y=new Array(g);f<g;f++)y[f]=d[f].fn;return y},a.prototype.listenerCount=function(l){var h=e?e+l:l,d=this._events[h];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,h,d,f,g,y){var p=e?e+l:l;if(!this._events[p])return!1;var w=this._events[p],v=arguments.length,x,S;if(w.fn){switch(w.once&&this.removeListener(l,w.fn,void 0,!0),v){case 1:return w.fn.call(w.context),!0;case 2:return w.fn.call(w.context,h),!0;case 3:return w.fn.call(w.context,h,d),!0;case 4:return w.fn.call(w.context,h,d,f),!0;case 5:return w.fn.call(w.context,h,d,f,g),!0;case 6:return w.fn.call(w.context,h,d,f,g,y),!0}for(S=1,x=new Array(v-1);S<v;S++)x[S-1]=arguments[S];w.fn.apply(w.context,x)}else{var I=w.length,P;for(S=0;S<I;S++)switch(w[S].once&&this.removeListener(l,w[S].fn,void 0,!0),v){case 1:w[S].fn.call(w[S].context);break;case 2:w[S].fn.call(w[S].context,h);break;case 3:w[S].fn.call(w[S].context,h,d);break;case 4:w[S].fn.call(w[S].context,h,d,f);break;default:if(!x)for(P=1,x=new Array(v-1);P<v;P++)x[P-1]=arguments[P];w[S].fn.apply(w[S].context,x)}}return!0},a.prototype.on=function(l,h,d){return i(this,l,h,d,!1)},a.prototype.once=function(l,h,d){return i(this,l,h,d,!0)},a.prototype.removeListener=function(l,h,d,f){var g=e?e+l:l;if(!this._events[g])return this;if(!h)return o(this,g),this;var y=this._events[g];if(y.fn)y.fn===h&&(!f||y.once)&&(!d||y.context===d)&&o(this,g);else{for(var p=0,w=[],v=y.length;p<v;p++)(y[p].fn!==h||f&&!y[p].once||d&&y[p].context!==d)&&w.push(y[p]);w.length?this._events[g]=w.length===1?w[0]:w:o(this,g)}return this},a.prototype.removeAllListeners=function(l){var h;return l?(h=e?e+l:l,this._events[h]&&o(this,h)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,n.exports=a}(Oh)),Oh.exports}var gx=fx();const px=Fn(gx);class l5 extends Error{constructor(t){super(t),this.name="TimeoutError"}}let mx=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t}};const F2=n=>globalThis.DOMException===void 0?new mx(n):new DOMException(n),U2=n=>{const t=n.reason===void 0?F2("This operation was aborted."):n.reason;return t instanceof Error?t:F2(t)};function lc(n,t){const{milliseconds:e,fallback:r,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o,a;const l=new Promise((h,d)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){const{signal:g}=t;g.aborted&&d(U2(g)),a=()=>{d(U2(g))},g.addEventListener("abort",a,{once:!0})}if(e===Number.POSITIVE_INFINITY){n.then(h,d);return}const f=new l5;o=i.setTimeout.call(void 0,()=>{if(r){try{h(r())}catch(g){d(g)}return}typeof n.cancel=="function"&&n.cancel(),s===!1?h():s instanceof Error?d(s):(f.message=s??`Promise timed out after ${e} milliseconds`,d(f))},e),(async()=>{try{h(await n)}catch(g){d(g)}})()}).finally(()=>{l.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}function yx(n,t,e){let r=0,s=n.length;for(;s>0;){const i=Math.trunc(s/2);let o=r+i;e(n[o],t)<=0?(r=++o,s-=i+1):s=i}return r}var br,B3;let wx=(B3=class{constructor(){ve(this,br,[])}enqueue(t,e){e={priority:0,...e};const r={priority:e.priority,id:e.id,run:t};if(this.size===0||Q(this,br)[this.size-1].priority>=e.priority){Q(this,br).push(r);return}const s=yx(Q(this,br),r,(i,o)=>o.priority-i.priority);Q(this,br).splice(s,0,r)}setPriority(t,e){const r=Q(this,br).findIndex(i=>i.id===t);if(r===-1)throw new ReferenceError(`No promise function with the id "${t}" exists in the queue.`);const[s]=Q(this,br).splice(r,1);this.enqueue(s.run,{priority:e,id:t})}dequeue(){const t=Q(this,br).shift();return t==null?void 0:t.run}filter(t){return Q(this,br).filter(e=>e.priority===t.priority).map(e=>e.run)}get size(){return Q(this,br).length}},br=new WeakMap,B3);var oo,ao,ns,Ja,co,ja,vr,lo,Ft,ec,Er,uo,Tn,tc,Su,Te,u5,h5,d5,f5,g5,nl,Zd,Jd,sl,p5,il;class Fa extends px{constructor(e){var r,s;super();ve(this,Te);ve(this,oo);ve(this,ao);ve(this,ns,0);ve(this,Ja);ve(this,co);ve(this,ja,0);ve(this,vr);ve(this,lo);ve(this,Ft);ve(this,ec);ve(this,Er,0);ve(this,uo);ve(this,Tn);ve(this,tc);ve(this,Su,1n);u(this,"timeout");if(e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:wx,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((r=e.intervalCap)==null?void 0:r.toString())??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=e.interval)==null?void 0:s.toString())??""}\` (${typeof e.interval})`);He(this,oo,e.carryoverConcurrencyCount),He(this,ao,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0),He(this,Ja,e.intervalCap),He(this,co,e.interval),He(this,Ft,new e.queueClass),He(this,ec,e.queueClass),this.concurrency=e.concurrency,this.timeout=e.timeout,He(this,tc,e.throwOnTimeout===!0),He(this,Tn,e.autoStart===!1)}get concurrency(){return Q(this,uo)}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);He(this,uo,e),ie(this,Te,sl).call(this)}setPriority(e,r){Q(this,Ft).setPriority(e,r)}async add(e,r={}){return r.id??(r.id=(Xr(this,Su)._++).toString()),r={timeout:this.timeout,throwOnTimeout:Q(this,tc),...r},new Promise((s,i)=>{Q(this,Ft).enqueue(async()=>{var o;Xr(this,Er)._++,Xr(this,ns)._++;try{(o=r.signal)==null||o.throwIfAborted();let a=e({signal:r.signal});r.timeout&&(a=lc(Promise.resolve(a),{milliseconds:r.timeout})),r.signal&&(a=Promise.race([a,ie(this,Te,p5).call(this,r.signal)]));const c=await a;s(c),this.emit("completed",c)}catch(a){if(a instanceof l5&&!r.throwOnTimeout){s();return}i(a),this.emit("error",a)}finally{ie(this,Te,d5).call(this)}},r),this.emit("add"),ie(this,Te,nl).call(this)})}async addAll(e,r){return Promise.all(e.map(async s=>this.add(s,r)))}start(){return Q(this,Tn)?(He(this,Tn,!1),ie(this,Te,sl).call(this),this):this}pause(){He(this,Tn,!0)}clear(){He(this,Ft,new(Q(this,ec)))}async onEmpty(){Q(this,Ft).size!==0&&await ie(this,Te,il).call(this,"empty")}async onSizeLessThan(e){Q(this,Ft).size<e||await ie(this,Te,il).call(this,"next",()=>Q(this,Ft).size<e)}async onIdle(){Q(this,Er)===0&&Q(this,Ft).size===0||await ie(this,Te,il).call(this,"idle")}get size(){return Q(this,Ft).size}sizeBy(e){return Q(this,Ft).filter(e).length}get pending(){return Q(this,Er)}get isPaused(){return Q(this,Tn)}}oo=new WeakMap,ao=new WeakMap,ns=new WeakMap,Ja=new WeakMap,co=new WeakMap,ja=new WeakMap,vr=new WeakMap,lo=new WeakMap,Ft=new WeakMap,ec=new WeakMap,Er=new WeakMap,uo=new WeakMap,Tn=new WeakMap,tc=new WeakMap,Su=new WeakMap,Te=new WeakSet,u5=function(){return Q(this,ao)||Q(this,ns)<Q(this,Ja)},h5=function(){return Q(this,Er)<Q(this,uo)},d5=function(){Xr(this,Er)._--,ie(this,Te,nl).call(this),this.emit("next")},f5=function(){ie(this,Te,Jd).call(this),ie(this,Te,Zd).call(this),He(this,lo,void 0)},g5=function(){const e=Date.now();if(Q(this,vr)===void 0){const r=Q(this,ja)-e;if(r<0)He(this,ns,Q(this,oo)?Q(this,Er):0);else return Q(this,lo)===void 0&&He(this,lo,setTimeout(()=>{ie(this,Te,f5).call(this)},r)),!0}return!1},nl=function(){if(Q(this,Ft).size===0)return Q(this,vr)&&clearInterval(Q(this,vr)),He(this,vr,void 0),this.emit("empty"),Q(this,Er)===0&&this.emit("idle"),!1;if(!Q(this,Tn)){const e=!Q(this,Te,g5);if(Q(this,Te,u5)&&Q(this,Te,h5)){const r=Q(this,Ft).dequeue();return r?(this.emit("active"),r(),e&&ie(this,Te,Zd).call(this),!0):!1}}return!1},Zd=function(){Q(this,ao)||Q(this,vr)!==void 0||(He(this,vr,setInterval(()=>{ie(this,Te,Jd).call(this)},Q(this,co))),He(this,ja,Date.now()+Q(this,co)))},Jd=function(){Q(this,ns)===0&&Q(this,Er)===0&&Q(this,vr)&&(clearInterval(Q(this,vr)),He(this,vr,void 0)),He(this,ns,Q(this,oo)?Q(this,Er):0),ie(this,Te,sl).call(this)},sl=function(){for(;ie(this,Te,nl).call(this););},p5=async function(e){return new Promise((r,s)=>{e.addEventListener("abort",()=>{s(e.reason)},{once:!0})})},il=async function(e,r){return new Promise(s=>{const i=()=>{r&&!r()||(this.off(e,i),s())};this.on(e,i)})};function m5(n){const t=[Ss.A];return n==null?t:Array.isArray(n)?n.length===0?t:n:[n]}const y5=60;function w5(n){return{Status:n.Status??0,TC:n.TC??n.flag_tc??!1,RD:n.RD??n.flag_rd??!1,RA:n.RA??n.flag_ra??!1,AD:n.AD??n.flag_ad??!1,CD:n.CD??n.flag_cd??!1,Question:(n.Question??n.questions??[]).map(t=>({name:t.name,type:Ss[t.type]})),Answer:(n.Answer??n.answers??[]).map(t=>({name:t.name,type:Ss[t.type],TTL:t.TTL??t.ttl??y5,data:t.data instanceof Uint8Array?Z(t.data):t.data}))}}const bx=4;function $2(n,t={}){const e=new Fa({concurrency:t.queryConcurrency??bx});return async(r,s={})=>{var a;const i=new URLSearchParams;i.set("name",r),m5(s.types).forEach(c=>{i.append("type",Ss[c])}),(a=s.onProgress)==null||a.call(s,new se("dns:query",{detail:r}));const o=await e.add(async()=>{var h;const c=await fetch(`${n}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const l=w5(await c.json());return(h=s.onProgress)==null||h.call(s,new se("dns:response",{detail:l})),l},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function vx(){return[$2("https://cloudflare-dns.com/dns-query"),$2("https://dns.google/resolve")]}var Fh,z2;function Ex(){return z2||(z2=1,Fh=function(n){if(!n)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,e=Object.create(null),r=Object.create(null);function s(i,o){e[i]=o,t++,t>=n&&(t=0,r=e,e=Object.create(null))}return{has:function(i){return e[i]!==void 0||r[i]!==void 0},remove:function(i){e[i]!==void 0&&(e[i]=void 0),r[i]!==void 0&&(r[i]=void 0)},get:function(i){var o=e[i];if(o!==void 0)return o;if((o=r[i])!==void 0)return s(i,o),o},set:function(i,o){e[i]!==void 0?e[i]=o:s(i,o)},clear:function(){e=Object.create(null),r=Object.create(null)}}}),Fh}var Sx=Ex();const xx=Fn(Sx);class _x{constructor(t){u(this,"lru");this.lru=xx(t)}get(t,e){let r=!0;const s=[];for(const i of e){const o=this.getAnswers(t,i);if(o.length===0){r=!1;break}s.push(...o)}if(r)return w5({answers:s})}getAnswers(t,e){const r=`${t.toLowerCase()}-${e}`,s=this.lru.get(r);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Ss[a.type]}));return i.length===0&&this.lru.remove(r),i}return[]}add(t,e){const r=`${t.toLowerCase()}-${e.type}`,s=this.lru.get(r)??[];s.push({expires:Date.now()+(e.TTL??y5)*1e3,value:e}),this.lru.set(r,s)}remove(t,e){const r=`${t.toLowerCase()}-${e}`;this.lru.remove(r)}clear(){this.lru.clear()}}function kx(n){return new _x(n)}const Ix=1e3;let Ax=class{constructor(t){u(this,"resolvers");u(this,"cache");this.resolvers={},this.cache=kx(t.cacheSize??Ix),Object.entries(t.resolvers??{}).forEach(([e,r])=>{Array.isArray(r)||(r=[r]),e.endsWith(".")||(e=`${e}.`),this.resolvers[e]=r}),this.resolvers["."]==null&&(this.resolvers["."]=vx())}async query(t,e={}){var c,l,h;const r=m5(e.types),s=e.cached!==!1?this.cache.get(t,r):void 0;if(s!=null)return(c=e.onProgress)==null||c.call(e,new se("dns:cache",{detail:s})),s;const i=`${t.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const d of o){if(((l=e.signal)==null?void 0:l.aborted)===!0)break;try{const f=await d(t,{...e,types:r});for(const g of f.Answer)this.cache.add(t,g);return f}catch(f){a.push(f),(h=e.onProgress)==null||h.call(e,new se("dns:error",{detail:f}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${t} ${r} failed`)}};var Ss;(function(n){n[n.A=1]="A",n[n.CNAME=5]="CNAME",n[n.TXT=16]="TXT",n[n.AAAA=28]="AAAA"})(Ss||(Ss={}));function b5(n={}){return new Ax(n)}const Tx=["string","number","bigint","symbol"],Cx=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function Px(n){if(n===null)return"null";if(n===void 0)return"undefined";if(n===!0||n===!1)return"boolean";const t=typeof n;if(Tx.includes(t))return t;if(t==="function")return"Function";if(Array.isArray(n))return"Array";if(Dx(n))return"Buffer";const e=Rx(n);return e||"Object"}function Dx(n){return n&&n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer.call(null,n)}function Rx(n){const t=Object.prototype.toString.call(n).slice(8,-1);if(Cx.includes(t))return t}class B{constructor(t,e,r){this.major=t,this.majorEncoded=t<<5,this.name=e,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(t){return this.major<t.major?-1:this.major>t.major?1:0}}B.uint=new B(0,"uint",!0);B.negint=new B(1,"negint",!0);B.bytes=new B(2,"bytes",!0);B.string=new B(3,"string",!0);B.array=new B(4,"array",!1);B.map=new B(5,"map",!1);B.tag=new B(6,"tag",!1);B.float=new B(7,"float",!0);B.false=new B(7,"false",!0);B.true=new B(7,"true",!0);B.null=new B(7,"null",!0);B.undefined=new B(7,"undefined",!0);B.break=new B(7,"break",!0);class G{constructor(t,e,r){this.type=t,this.value=e,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Wo=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",Bx=new TextDecoder,Mx=new TextEncoder;function Fl(n){return Wo&&globalThis.Buffer.isBuffer(n)}function Uf(n){return n instanceof Uint8Array?Fl(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n:Uint8Array.from(n)}const Nx=Wo?(n,t,e)=>e-t>64?globalThis.Buffer.from(n.subarray(t,e)).toString("utf8"):H2(n,t,e):(n,t,e)=>e-t>64?Bx.decode(n.subarray(t,e)):H2(n,t,e),v5=Wo?n=>n.length>64?globalThis.Buffer.from(n):V2(n):n=>n.length>64?Mx.encode(n):V2(n),En=n=>Uint8Array.from(n),$f=Wo?(n,t,e)=>Fl(n)?new Uint8Array(n.subarray(t,e)):n.slice(t,e):(n,t,e)=>n.slice(t,e),Lx=Wo?(n,t)=>(n=n.map(e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e)),Uf(globalThis.Buffer.concat(n,t))):(n,t)=>{const e=new Uint8Array(t);let r=0;for(let s of n)r+s.length>e.length&&(s=s.subarray(0,e.length-r)),e.set(s,r),r+=s.length;return e},Ox=Wo?n=>globalThis.Buffer.allocUnsafe(n):n=>new Uint8Array(n);function Fx(n,t){if(Fl(n)&&Fl(t))return n.compare(t);for(let e=0;e<n.length;e++)if(n[e]!==t[e])return n[e]<t[e]?-1:1;return 0}function V2(n){const t=[];let e=0;for(let r=0;r<n.length;r++){let s=n.charCodeAt(r);s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&r+1<n.length&&(n.charCodeAt(r+1)&64512)===56320?(s=65536+((s&1023)<<10)+(n.charCodeAt(++r)&1023),t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128)}return t}function H2(n,t,e){const r=[];for(;t<e;){const s=n[t];let i=null,o=s>239?4:s>223?3:s>191?2:1;if(t+o<=e){let a,c,l,h;switch(o){case 1:s<128&&(i=s);break;case 2:a=n[t+1],(a&192)===128&&(h=(s&31)<<6|a&63,h>127&&(i=h));break;case 3:a=n[t+1],c=n[t+2],(a&192)===128&&(c&192)===128&&(h=(s&15)<<12|(a&63)<<6|c&63,h>2047&&(h<55296||h>57343)&&(i=h));break;case 4:a=n[t+1],c=n[t+2],l=n[t+3],(a&192)===128&&(c&192)===128&&(l&192)===128&&(h=(s&15)<<18|(a&63)<<12|(c&63)<<6|l&63,h>65535&&h<1114112&&(i=h))}}i===null?(i=65533,o=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|i&1023),r.push(i),t+=o}return E5(r)}const q2=4096;function E5(n){const t=n.length;if(t<=q2)return String.fromCharCode.apply(String,n);let e="",r=0;for(;r<t;)e+=String.fromCharCode.apply(String,n.slice(r,r+=q2));return e}const Ux=256;class S5{constructor(t=Ux){this.chunkSize=t,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(t){let e=this.chunks[this.chunks.length-1];if(this.cursor+t.length<=this.maxCursor+1){const s=e.length-(this.maxCursor-this.cursor)-1;e.set(t,s)}else{if(e){const s=e.length-(this.maxCursor-this.cursor)-1;s<e.length&&(this.chunks[this.chunks.length-1]=e.subarray(0,s),this.maxCursor=this.cursor-1)}t.length<64&&t.length<this.chunkSize?(e=Ox(this.chunkSize),this.chunks.push(e),this.maxCursor+=e.length,this._initReuseChunk===null&&(this._initReuseChunk=e),e.set(t,0)):(this.chunks.push(t),this.maxCursor+=t.length)}this.cursor+=t.length}toBytes(t=!1){let e;if(this.chunks.length===1){const r=this.chunks[0];t&&this.cursor>r.length/2?(e=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):e=$f(r,0,this.cursor)}else e=Lx(this.chunks,this.cursor);return t&&this.reset(),e}}const ce="CBOR decode error:",ri="CBOR encode error:";function Ko(n,t,e){if(n.length-t<e)throw new Error(`${ce} not enough data for type`)}const Ct=[24,256,65536,4294967296,BigInt("18446744073709551616")];function Ei(n,t,e){Ko(n,t,1);const r=n[t];if(e.strict===!0&&r<Ct[0])throw new Error(`${ce} integer encoded in more bytes than necessary (strict decode)`);return r}function Si(n,t,e){Ko(n,t,2);const r=n[t]<<8|n[t+1];if(e.strict===!0&&r<Ct[1])throw new Error(`${ce} integer encoded in more bytes than necessary (strict decode)`);return r}function xi(n,t,e){Ko(n,t,4);const r=n[t]*16777216+(n[t+1]<<16)+(n[t+2]<<8)+n[t+3];if(e.strict===!0&&r<Ct[2])throw new Error(`${ce} integer encoded in more bytes than necessary (strict decode)`);return r}function _i(n,t,e){Ko(n,t,8);const r=n[t]*16777216+(n[t+1]<<16)+(n[t+2]<<8)+n[t+3],s=n[t+4]*16777216+(n[t+5]<<16)+(n[t+6]<<8)+n[t+7],i=(BigInt(r)<<BigInt(32))+BigInt(s);if(e.strict===!0&&i<Ct[3])throw new Error(`${ce} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(e.allowBigInt===!0)return i;throw new Error(`${ce} integers outside of the safe integer range are not supported`)}function $x(n,t,e,r){return new G(B.uint,Ei(n,t+1,r),2)}function zx(n,t,e,r){return new G(B.uint,Si(n,t+1,r),3)}function Vx(n,t,e,r){return new G(B.uint,xi(n,t+1,r),5)}function Hx(n,t,e,r){return new G(B.uint,_i(n,t+1,r),9)}function ki(n,t){return Ar(n,0,t.value)}function Ar(n,t,e){if(e<Ct[0]){const r=Number(e);n.push([t|r])}else if(e<Ct[1]){const r=Number(e);n.push([t|24,r])}else if(e<Ct[2]){const r=Number(e);n.push([t|25,r>>>8,r&255])}else if(e<Ct[3]){const r=Number(e);n.push([t|26,r>>>24&255,r>>>16&255,r>>>8&255,r&255])}else{const r=BigInt(e);if(r<Ct[4]){const s=[t|27,0,0,0,0,0,0,0];let i=Number(r&BigInt(4294967295)),o=Number(r>>BigInt(32)&BigInt(4294967295));s[8]=i&255,i=i>>8,s[7]=i&255,i=i>>8,s[6]=i&255,i=i>>8,s[5]=i&255,s[4]=o&255,o=o>>8,s[3]=o&255,o=o>>8,s[2]=o&255,o=o>>8,s[1]=o&255,n.push(s)}else throw new Error(`${ce} encountered BigInt larger than allowable range`)}}ki.encodedSize=function(t){return Ar.encodedSize(t.value)};Ar.encodedSize=function(t){return t<Ct[0]?1:t<Ct[1]?2:t<Ct[2]?3:t<Ct[3]?5:9};ki.compareTokens=function(t,e){return t.value<e.value?-1:t.value>e.value?1:0};function qx(n,t,e,r){return new G(B.negint,-1-Ei(n,t+1,r),2)}function Wx(n,t,e,r){return new G(B.negint,-1-Si(n,t+1,r),3)}function Kx(n,t,e,r){return new G(B.negint,-1-xi(n,t+1,r),5)}const zf=BigInt(-1),x5=BigInt(1);function Gx(n,t,e,r){const s=_i(n,t+1,r);if(typeof s!="bigint"){const i=-1-s;if(i>=Number.MIN_SAFE_INTEGER)return new G(B.negint,i,9)}if(r.allowBigInt!==!0)throw new Error(`${ce} integers outside of the safe integer range are not supported`);return new G(B.negint,zf-BigInt(s),9)}function Vf(n,t){const e=t.value,r=typeof e=="bigint"?e*zf-x5:e*-1-1;Ar(n,t.type.majorEncoded,r)}Vf.encodedSize=function(t){const e=t.value,r=typeof e=="bigint"?e*zf-x5:e*-1-1;return r<Ct[0]?1:r<Ct[1]?2:r<Ct[2]?3:r<Ct[3]?5:9};Vf.compareTokens=function(t,e){return t.value<e.value?1:t.value>e.value?-1:0};function uc(n,t,e,r){Ko(n,t,e+r);const s=$f(n,t+e,t+e+r);return new G(B.bytes,s,e+r)}function Qx(n,t,e,r){return uc(n,t,1,e)}function Yx(n,t,e,r){return uc(n,t,2,Ei(n,t+1,r))}function Xx(n,t,e,r){return uc(n,t,3,Si(n,t+1,r))}function Zx(n,t,e,r){return uc(n,t,5,xi(n,t+1,r))}function Jx(n,t,e,r){const s=_i(n,t+1,r);if(typeof s=="bigint")throw new Error(`${ce} 64-bit integer bytes lengths not supported`);return uc(n,t,9,s)}function Ul(n){return n.encodedBytes===void 0&&(n.encodedBytes=n.type===B.string?v5(n.value):n.value),n.encodedBytes}function Gu(n,t){const e=Ul(t);Ar(n,t.type.majorEncoded,e.length),n.push(e)}Gu.encodedSize=function(t){const e=Ul(t);return Ar.encodedSize(e.length)+e.length};Gu.compareTokens=function(t,e){return jx(Ul(t),Ul(e))};function jx(n,t){return n.length<t.length?-1:n.length>t.length?1:Fx(n,t)}function hc(n,t,e,r,s){const i=e+r;Ko(n,t,i);const o=new G(B.string,Nx(n,t+e,t+i),i);return s.retainStringBytes===!0&&(o.byteValue=$f(n,t+e,t+i)),o}function e_(n,t,e,r){return hc(n,t,1,e,r)}function t_(n,t,e,r){return hc(n,t,2,Ei(n,t+1,r),r)}function r_(n,t,e,r){return hc(n,t,3,Si(n,t+1,r),r)}function n_(n,t,e,r){return hc(n,t,5,xi(n,t+1,r),r)}function s_(n,t,e,r){const s=_i(n,t+1,r);if(typeof s=="bigint")throw new Error(`${ce} 64-bit integer string lengths not supported`);return hc(n,t,9,s,r)}const i_=Gu;function Go(n,t,e,r){return new G(B.array,r,e)}function o_(n,t,e,r){return Go(n,t,1,e)}function a_(n,t,e,r){return Go(n,t,2,Ei(n,t+1,r))}function c_(n,t,e,r){return Go(n,t,3,Si(n,t+1,r))}function l_(n,t,e,r){return Go(n,t,5,xi(n,t+1,r))}function u_(n,t,e,r){const s=_i(n,t+1,r);if(typeof s=="bigint")throw new Error(`${ce} 64-bit integer array lengths not supported`);return Go(n,t,9,s)}function h_(n,t,e,r){if(r.allowIndefinite===!1)throw new Error(`${ce} indefinite length items not allowed`);return Go(n,t,1,1/0)}function Hf(n,t){Ar(n,B.array.majorEncoded,t.value)}Hf.compareTokens=ki.compareTokens;Hf.encodedSize=function(t){return Ar.encodedSize(t.value)};function Qo(n,t,e,r){return new G(B.map,r,e)}function d_(n,t,e,r){return Qo(n,t,1,e)}function f_(n,t,e,r){return Qo(n,t,2,Ei(n,t+1,r))}function g_(n,t,e,r){return Qo(n,t,3,Si(n,t+1,r))}function p_(n,t,e,r){return Qo(n,t,5,xi(n,t+1,r))}function m_(n,t,e,r){const s=_i(n,t+1,r);if(typeof s=="bigint")throw new Error(`${ce} 64-bit integer map lengths not supported`);return Qo(n,t,9,s)}function y_(n,t,e,r){if(r.allowIndefinite===!1)throw new Error(`${ce} indefinite length items not allowed`);return Qo(n,t,1,1/0)}function qf(n,t){Ar(n,B.map.majorEncoded,t.value)}qf.compareTokens=ki.compareTokens;qf.encodedSize=function(t){return Ar.encodedSize(t.value)};function w_(n,t,e,r){return new G(B.tag,e,1)}function b_(n,t,e,r){return new G(B.tag,Ei(n,t+1,r),2)}function v_(n,t,e,r){return new G(B.tag,Si(n,t+1,r),3)}function E_(n,t,e,r){return new G(B.tag,xi(n,t+1,r),5)}function S_(n,t,e,r){return new G(B.tag,_i(n,t+1,r),9)}function Wf(n,t){Ar(n,B.tag.majorEncoded,t.value)}Wf.compareTokens=ki.compareTokens;Wf.encodedSize=function(t){return Ar.encodedSize(t.value)};const x_=20,__=21,k_=22,I_=23;function A_(n,t,e,r){if(r.allowUndefined===!1)throw new Error(`${ce} undefined values are not supported`);return r.coerceUndefinedToNull===!0?new G(B.null,null,1):new G(B.undefined,void 0,1)}function T_(n,t,e,r){if(r.allowIndefinite===!1)throw new Error(`${ce} indefinite length items not allowed`);return new G(B.break,void 0,1)}function Kf(n,t,e){if(e){if(e.allowNaN===!1&&Number.isNaN(n))throw new Error(`${ce} NaN values are not supported`);if(e.allowInfinity===!1&&(n===1/0||n===-1/0))throw new Error(`${ce} Infinity values are not supported`)}return new G(B.float,n,t)}function C_(n,t,e,r){return Kf(Qf(n,t+1),3,r)}function P_(n,t,e,r){return Kf(Yf(n,t+1),5,r)}function D_(n,t,e,r){return Kf(A5(n,t+1),9,r)}function Gf(n,t,e){const r=t.value;if(r===!1)n.push([B.float.majorEncoded|x_]);else if(r===!0)n.push([B.float.majorEncoded|__]);else if(r===null)n.push([B.float.majorEncoded|k_]);else if(r===void 0)n.push([B.float.majorEncoded|I_]);else{let s,i=!1;(!e||e.float64!==!0)&&(k5(r),s=Qf(Br,1),r===s||Number.isNaN(r)?(Br[0]=249,n.push(Br.slice(0,3)),i=!0):(I5(r),s=Yf(Br,1),r===s&&(Br[0]=250,n.push(Br.slice(0,5)),i=!0))),i||(R_(r),s=A5(Br,1),Br[0]=251,n.push(Br.slice(0,9)))}}Gf.encodedSize=function(t,e){const r=t.value;if(r===!1||r===!0||r===null||r===void 0)return 1;if(!e||e.float64!==!0){k5(r);let s=Qf(Br,1);if(r===s||Number.isNaN(r))return 3;if(I5(r),s=Yf(Br,1),r===s)return 5}return 9};const _5=new ArrayBuffer(9),yr=new DataView(_5,1),Br=new Uint8Array(_5,0);function k5(n){if(n===1/0)yr.setUint16(0,31744,!1);else if(n===-1/0)yr.setUint16(0,64512,!1);else if(Number.isNaN(n))yr.setUint16(0,32256,!1);else{yr.setFloat32(0,n);const t=yr.getUint32(0),e=(t&2139095040)>>23,r=t&8388607;if(e===255)yr.setUint16(0,31744,!1);else if(e===0)yr.setUint16(0,(n&2147483648)>>16|r>>13,!1);else{const s=e-127;s<-24?yr.setUint16(0,0):s<-14?yr.setUint16(0,(t&2147483648)>>16|1<<24+s,!1):yr.setUint16(0,(t&2147483648)>>16|s+15<<10|r>>13,!1)}}}function Qf(n,t){if(n.length-t<2)throw new Error(`${ce} not enough data for float16`);const e=(n[t]<<8)+n[t+1];if(e===31744)return 1/0;if(e===64512)return-1/0;if(e===32256)return NaN;const r=e>>10&31,s=e&1023;let i;return r===0?i=s*2**-24:r!==31?i=(s+1024)*2**(r-25):i=s===0?1/0:NaN,e&32768?-i:i}function I5(n){yr.setFloat32(0,n,!1)}function Yf(n,t){if(n.length-t<4)throw new Error(`${ce} not enough data for float32`);const e=(n.byteOffset||0)+t;return new DataView(n.buffer,e,4).getFloat32(0,!1)}function R_(n){yr.setFloat64(0,n,!1)}function A5(n,t){if(n.length-t<8)throw new Error(`${ce} not enough data for float64`);const e=(n.byteOffset||0)+t;return new DataView(n.buffer,e,8).getFloat64(0,!1)}Gf.compareTokens=ki.compareTokens;function Ce(n,t,e){throw new Error(`${ce} encountered invalid minor (${e}) for major ${n[t]>>>5}`)}function Qu(n){return()=>{throw new Error(`${ce} ${n}`)}}const X=[];for(let n=0;n<=23;n++)X[n]=Ce;X[24]=$x;X[25]=zx;X[26]=Vx;X[27]=Hx;X[28]=Ce;X[29]=Ce;X[30]=Ce;X[31]=Ce;for(let n=32;n<=55;n++)X[n]=Ce;X[56]=qx;X[57]=Wx;X[58]=Kx;X[59]=Gx;X[60]=Ce;X[61]=Ce;X[62]=Ce;X[63]=Ce;for(let n=64;n<=87;n++)X[n]=Qx;X[88]=Yx;X[89]=Xx;X[90]=Zx;X[91]=Jx;X[92]=Ce;X[93]=Ce;X[94]=Ce;X[95]=Qu("indefinite length bytes/strings are not supported");for(let n=96;n<=119;n++)X[n]=e_;X[120]=t_;X[121]=r_;X[122]=n_;X[123]=s_;X[124]=Ce;X[125]=Ce;X[126]=Ce;X[127]=Qu("indefinite length bytes/strings are not supported");for(let n=128;n<=151;n++)X[n]=o_;X[152]=a_;X[153]=c_;X[154]=l_;X[155]=u_;X[156]=Ce;X[157]=Ce;X[158]=Ce;X[159]=h_;for(let n=160;n<=183;n++)X[n]=d_;X[184]=f_;X[185]=g_;X[186]=p_;X[187]=m_;X[188]=Ce;X[189]=Ce;X[190]=Ce;X[191]=y_;for(let n=192;n<=215;n++)X[n]=w_;X[216]=b_;X[217]=v_;X[218]=E_;X[219]=S_;X[220]=Ce;X[221]=Ce;X[222]=Ce;X[223]=Ce;for(let n=224;n<=243;n++)X[n]=Qu("simple values are not supported");X[244]=Ce;X[245]=Ce;X[246]=Ce;X[247]=A_;X[248]=Qu("simple values are not supported");X[249]=C_;X[250]=P_;X[251]=D_;X[252]=Ce;X[253]=Ce;X[254]=Ce;X[255]=T_;const wn=[];for(let n=0;n<24;n++)wn[n]=new G(B.uint,n,1);for(let n=-1;n>=-24;n--)wn[31-n]=new G(B.negint,n,1);wn[64]=new G(B.bytes,new Uint8Array(0),1);wn[96]=new G(B.string,"",1);wn[128]=new G(B.array,0,1);wn[160]=new G(B.map,0,1);wn[244]=new G(B.false,!1,1);wn[245]=new G(B.true,!0,1);wn[246]=new G(B.null,null,1);function B_(n){switch(n.type){case B.false:return En([244]);case B.true:return En([245]);case B.null:return En([246]);case B.bytes:return n.value.length?void 0:En([64]);case B.string:return n.value===""?En([96]):void 0;case B.array:return n.value===0?En([128]):void 0;case B.map:return n.value===0?En([160]):void 0;case B.uint:return n.value<24?En([Number(n.value)]):void 0;case B.negint:if(n.value>=-24)return En([31-Number(n.value)])}}const M_={float64:!1,mapSorter:O_,quickEncodeToken:B_};function N_(){const n=[];return n[B.uint.major]=ki,n[B.negint.major]=Vf,n[B.bytes.major]=Gu,n[B.string.major]=i_,n[B.array.major]=Hf,n[B.map.major]=qf,n[B.tag.major]=Wf,n[B.float.major]=Gf,n}const T5=N_(),Uh=new S5;class $l{constructor(t,e){this.obj=t,this.parent=e}includes(t){let e=this;do if(e.obj===t)return!0;while(e=e.parent);return!1}static createCheck(t,e){if(t&&t.includes(e))throw new Error(`${ri} object contains circular references`);return new $l(e,t)}}const Xn={null:new G(B.null,null),undefined:new G(B.undefined,void 0),true:new G(B.true,!0),false:new G(B.false,!1),emptyArray:new G(B.array,0),emptyMap:new G(B.map,0)},xs={number(n,t,e,r){return!Number.isInteger(n)||!Number.isSafeInteger(n)?new G(B.float,n):n>=0?new G(B.uint,n):new G(B.negint,n)},bigint(n,t,e,r){return n>=BigInt(0)?new G(B.uint,n):new G(B.negint,n)},Uint8Array(n,t,e,r){return new G(B.bytes,n)},string(n,t,e,r){return new G(B.string,n)},boolean(n,t,e,r){return n?Xn.true:Xn.false},null(n,t,e,r){return Xn.null},undefined(n,t,e,r){return Xn.undefined},ArrayBuffer(n,t,e,r){return new G(B.bytes,new Uint8Array(n))},DataView(n,t,e,r){return new G(B.bytes,new Uint8Array(n.buffer,n.byteOffset,n.byteLength))},Array(n,t,e,r){if(!n.length)return e.addBreakTokens===!0?[Xn.emptyArray,new G(B.break)]:Xn.emptyArray;r=$l.createCheck(r,n);const s=[];let i=0;for(const o of n)s[i++]=ol(o,e,r);return e.addBreakTokens?[new G(B.array,n.length),s,new G(B.break)]:[new G(B.array,n.length),s]},Object(n,t,e,r){const s=t!=="Object",i=s?n.keys():Object.keys(n),o=s?n.size:i.length;if(!o)return e.addBreakTokens===!0?[Xn.emptyMap,new G(B.break)]:Xn.emptyMap;r=$l.createCheck(r,n);const a=[];let c=0;for(const l of i)a[c++]=[ol(l,e,r),ol(s?n.get(l):n[l],e,r)];return L_(a,e),e.addBreakTokens?[new G(B.map,o),a,new G(B.break)]:[new G(B.map,o),a]}};xs.Map=xs.Object;xs.Buffer=xs.Uint8Array;for(const n of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))xs[`${n}Array`]=xs.DataView;function ol(n,t={},e){const r=Px(n),s=t&&t.typeEncoders&&t.typeEncoders[r]||xs[r];if(typeof s=="function"){const o=s(n,r,t,e);if(o!=null)return o}const i=xs[r];if(!i)throw new Error(`${ri} unsupported type: ${r}`);return i(n,r,t,e)}function L_(n,t){t.mapSorter&&n.sort(t.mapSorter)}function O_(n,t){const e=Array.isArray(n[0])?n[0][0]:n[0],r=Array.isArray(t[0])?t[0][0]:t[0];if(e.type!==r.type)return e.type.compare(r.type);const s=e.type.major,i=T5[s].compareTokens(e,r);return i===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i}function C5(n,t,e,r){if(Array.isArray(t))for(const s of t)C5(n,s,e,r);else e[t.type.major](n,t,r)}function P5(n,t,e){const r=ol(n,e);if(!Array.isArray(r)&&e.quickEncodeToken){const s=e.quickEncodeToken(r);if(s)return s;const i=t[r.type.major];if(i.encodedSize){const o=i.encodedSize(r,e),a=new S5(o);if(i(a,r,e),a.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${r} was wrong`);return Uf(a.chunks[0])}}return Uh.reset(),C5(Uh,r,t,e),Uh.toBytes(!0)}function al(n,t){return t=Object.assign({},M_,t),P5(n,T5,t)}const F_={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class U_{constructor(t,e={}){this._pos=0,this.data=t,this.options=e}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const t=this.data[this._pos];let e=wn[t];if(e===void 0){const r=X[t];if(!r)throw new Error(`${ce} no decoder for major type ${t>>>5} (byte 0x${t.toString(16).padStart(2,"0")})`);const s=t&31;e=r(this.data,this._pos,s,this.options)}return this._pos+=e.encodedLength,e}}const Ua=Symbol.for("DONE"),Yu=Symbol.for("BREAK");function $_(n,t,e){const r=[];for(let s=0;s<n.value;s++){const i=$a(t,e);if(i===Yu){if(n.value===1/0)break;throw new Error(`${ce} got unexpected break to lengthed array`)}if(i===Ua)throw new Error(`${ce} found array but not enough entries (got ${s}, expected ${n.value})`);r[s]=i}return r}function z_(n,t,e){const r=e.useMaps===!0,s=r?void 0:{},i=r?new Map:void 0;for(let o=0;o<n.value;o++){const a=$a(t,e);if(a===Yu){if(n.value===1/0)break;throw new Error(`${ce} got unexpected break to lengthed map`)}if(a===Ua)throw new Error(`${ce} found map but not enough entries (got ${o} [no key], expected ${n.value})`);if(r!==!0&&typeof a!="string")throw new Error(`${ce} non-string keys not supported (got ${typeof a})`);if(e.rejectDuplicateMapKeys===!0&&(r&&i.has(a)||!r&&a in s))throw new Error(`${ce} found repeat map key "${a}"`);const c=$a(t,e);if(c===Ua)throw new Error(`${ce} found map but not enough entries (got ${o} [no value], expected ${n.value})`);r?i.set(a,c):s[a]=c}return r?i:s}function $a(n,t){if(n.done())return Ua;const e=n.next();if(e.type===B.break)return Yu;if(e.type.terminal)return e.value;if(e.type===B.array)return $_(e,n,t);if(e.type===B.map)return z_(e,n,t);if(e.type===B.tag){if(t.tags&&typeof t.tags[e.value]=="function"){const r=$a(n,t);return t.tags[e.value](r)}throw new Error(`${ce} tag not supported (${e.value})`)}throw new Error("unsupported")}function V_(n,t){if(!(n instanceof Uint8Array))throw new Error(`${ce} data to decode must be a Uint8Array`);t=Object.assign({},F_,t);const e=t.tokenizer||new U_(n,t),r=$a(e,t);if(r===Ua)throw new Error(`${ce} did not find any content to decode`);if(r===Yu)throw new Error(`${ce} got unexpected break`);return[r,n.subarray(e.pos())]}function es(n,t){const[e,r]=V_(n,t);if(r.length>0)throw new Error(`${ce} too many terminals, data makes no sense`);return e}const xn="/",D5=new TextEncoder().encode(xn),Nc=D5[0];class Ge{constructor(t,e){u(this,"_buf");if(typeof t=="string")this._buf=Y(t);else if(t instanceof Uint8Array)this._buf=t;else throw new Error("Invalid key, should be String of Uint8Array");if(e==null&&(e=!0),e&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Nc)throw new Error("Invalid key")}toString(t="utf8"){return Z(this._buf,t)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(t){return new Ge(t.join(xn))}static random(){return new Ge(Math.random().toString().substring(2))}static asKey(t){return t instanceof Uint8Array||typeof t=="string"?new Ge(t):typeof t.uint8Array=="function"?new Ge(t.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=D5),this._buf[0]!==Nc){const t=new Uint8Array(this._buf.byteLength+1);t.fill(Nc,0,1),t.set(this._buf,1),this._buf=t}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Nc;)this._buf=this._buf.subarray(0,-1)}less(t){const e=this.list(),r=t.list();for(let s=0;s<e.length;s++){if(r.length<s+1)return!1;const i=e[s],o=r[s];if(i<o)return!0;if(i>o)return!1}return e.length<r.length}reverse(){return Ge.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const t=this.namespaces();return t[t.length-1]}list(){return this.toString().split(xn).slice(1)}type(){return H_(this.baseNamespace())}name(){return q_(this.baseNamespace())}instance(t){return new Ge(this.toString()+":"+t)}path(){let t=this.parent().toString();return t.endsWith(xn)||(t+=xn),t+=this.type(),new Ge(t)}parent(){const t=this.list();return t.length===1?new Ge(xn):new Ge(t.slice(0,-1).join(xn))}child(t){return this.toString()===xn?t:t.toString()===xn?this:new Ge(this.toString()+t.toString(),!1)}isAncestorOf(t){return t.toString()===this.toString()?!1:t.toString().startsWith(this.toString())}isDecendantOf(t){return t.toString()===this.toString()?!1:this.toString().startsWith(t.toString())}isTopLevel(){return this.list().length===1}concat(...t){return Ge.withNamespaces([...this.namespaces(),...W_(t.map(e=>e.namespaces()))])}}function H_(n){const t=n.split(":");return t.length<2?"":t.slice(0,-1).join(":")}function q_(n){const t=n.split(":");return t[t.length-1]}function W_(n){return[].concat(...n)}function Lc({enumerable:n=!0,configurable:t=!1}={}){return{enumerable:n,configurable:t,writable:!1}}function*K_(n,t){if(t!=null&&typeof t=="object")if(Array.isArray(t))for(const[e,r]of t.entries()){const s=[...n,e],i=te.asCID(r);i!=null?yield[s.join("/"),i]:typeof r=="object"&&(yield*jd(r,s))}else{const e=te.asCID(t);e!=null?yield[n.join("/"),e]:yield*jd(t,n)}}function*jd(n,t){if(n==null||n instanceof Uint8Array)return;const e=te.asCID(n);e!=null&&(yield[t.join("/"),e]);for(const[r,s]of Object.entries(n)){const i=[...t,r];yield*K_(i,s)}}function*G_(n,t){if(Array.isArray(t))for(const[e,r]of t.entries()){const s=[...n,e];yield s.join("/"),typeof r=="object"&&te.asCID(r)==null&&(yield*e1(r,s))}else yield*e1(t,n)}function*e1(n,t){if(!(n==null||typeof n!="object"))for(const[e,r]of Object.entries(n)){const s=[...t,e];yield s.join("/"),r!=null&&!(r instanceof Uint8Array)&&typeof r=="object"&&te.asCID(r)==null&&(yield*G_(s,r))}}function Q_(n,t){let e=n;for(const[r,s]of t.entries()){if(e=e[s],e==null)throw new Error(`Object has no property at ${t.slice(0,r+1).map(o=>`[${JSON.stringify(o)}]`).join("")}`);const i=te.asCID(e);if(i!=null)return{value:i,remaining:t.slice(r+1).join("/")}}return{value:e}}class Y_{constructor({cid:t,bytes:e,value:r}){u(this,"cid");u(this,"bytes");u(this,"value");u(this,"asBlock");if(t==null||e==null||typeof r>"u")throw new Error("Missing required argument");this.cid=t,this.bytes=e,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:Lc(),bytes:Lc(),value:Lc(),asBlock:Lc()})}links(){return jd(this.value,[])}tree(){return e1(this.value,[])}get(t="/"){return Q_(this.value,t.split("/").filter(Boolean))}}function X_({bytes:n,cid:t,value:e,codec:r}){const s=e!==void 0?e:r==null?void 0:r.decode(n);if(s===void 0)throw new Error('Missing required argument, must either provide "value" or "codec"');return new Y_({cid:t,bytes:n,value:s})}const R5="/pin/",W2="/pinned-block/",t1=ei,K2=1;function Oc(n){return n.version===0&&(n=n.toV1()),new Ge(`${R5}${n.toString(t1)}`)}var Nn,cl,r1;class Z_{constructor(t,e,r){ve(this,Nn);u(this,"datastore");u(this,"blockstore");u(this,"getCodec");this.datastore=t,this.blockstore=e,this.getCodec=r}async*add(t,e={}){const r=Oc(t);if(await this.datastore.has(r))throw new Error("Already pinned");const s=Math.round(e.depth??1/0);if(s<0)throw new Error("Depth must be greater than or equal to 0");const i=new oi({concurrency:K2});for await(const a of ie(this,Nn,cl).call(this,t,i,{...e,depth:s}))await ie(this,Nn,r1).call(this,a,c=>c.pinnedBy.find(l=>_e(l,t.bytes))!=null?!1:(c.pinCount++,c.pinnedBy.push(t.bytes),!0),e),yield a;const o={depth:s,metadata:e.metadata??{}};await this.datastore.put(r,al(o),e)}async*rm(t,e={}){const r=Oc(t),s=await this.datastore.get(r,e),i=es(s);await this.datastore.delete(r,e);const o=new oi({concurrency:K2});for await(const a of ie(this,Nn,cl).call(this,t,o,{...e,depth:i.depth}))await ie(this,Nn,r1).call(this,a,c=>(c.pinCount--,c.pinnedBy=c.pinnedBy.filter(l=>_e(l,t.bytes)),!0),{...e,depth:i.depth}),yield a}async*ls(t={}){for await(const{key:e,value:r}of this.datastore.query({prefix:R5+(t.cid!=null?`${t.cid.toString(ei)}`:"")},t)){const s=te.parse(e.toString().substring(5),ei),i=es(r);yield{cid:s,...i}}}async isPinned(t,e={}){const r=new Ge(`${W2}${t1.encode(t.multihash.bytes)}`);return this.datastore.has(r,e)}async get(t,e){const r=Oc(t),s=await this.datastore.get(r,e);return es(s)}async setMetadata(t,e,r){const s=Oc(t),i=await this.datastore.get(s,r),o=es(i);o.metadata=e??{},await this.datastore.put(s,al(o),r)}}Nn=new WeakSet,cl=async function*(t,e,r){if(r.depth===-1)return;const s=await this.getCodec(t.code),i=await this.blockstore.get(t,r),o=X_({bytes:i,cid:t,codec:s});yield t;for await(const[,a]of o.links())yield*await e.add(async()=>ie(this,Nn,cl).call(this,a,e,{...r,depth:r.depth-1}))},r1=async function(t,e,r){var a;const s=new Ge(`${W2}${t1.encode(t.multihash.bytes)}`);let i={pinCount:0,pinnedBy:[]};try{i=es(await this.datastore.get(s,r))}catch(c){if(c.name!=="NotFoundError")throw c}if(e(i)){if(i.pinCount===0&&await this.datastore.has(s)){await this.datastore.delete(s);return}await this.datastore.put(s,al(i),r),(a=r.onProgress)==null||a.call(r,new se("helia:pin:add",t))}};const J_=1,j_=5;class B5 extends Error{constructor(t="Insufficient providers found"){super(t),this.name="InsufficientProvidersError"}}u(B5,"name","InsufficientProvidersError");class fa extends Error{constructor(t="No routers available"){super(t),this.name="NoRoutersAvailableError"}}u(fa,"name","NoRoutersAvailableError");class M5 extends Error{constructor(t="Unknown hash algorithm"){super(t),this.name="UnknownHashAlgorithmError"}}u(M5,"name","UnknownHashAlgorithmError");class N5 extends Error{constructor(t="Unknown codec"){super(t),this.name="UnknownCodecError"}}u(N5,"name","UnknownCodecError");const ek=5;class tk{constructor(t,e){u(this,"log");u(this,"routers");u(this,"providerLookupConcurrency");var r,s,i,o,a,c,l;this.log=t.logger.forComponent("helia:routing"),this.routers=e.routers??[],this.providerLookupConcurrency=e.providerLookupConcurrency??ek,this.findProviders=((r=t.metrics)==null?void 0:r.traceFunction("helia.routing.findProviders",this.findProviders.bind(this),{optionsIndex:1}))??this.findProviders,this.provide=((s=t.metrics)==null?void 0:s.traceFunction("helia.routing.provide",this.provide.bind(this),{optionsIndex:1}))??this.provide,this.cancelReprovide=((i=t.metrics)==null?void 0:i.traceFunction("helia.routing.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1}))??this.cancelReprovide,this.put=((o=t.metrics)==null?void 0:o.traceFunction("helia.routing.put",this.put.bind(this),{optionsIndex:2}))??this.put,this.get=((a=t.metrics)==null?void 0:a.traceFunction("helia.routing.get",this.get.bind(this),{optionsIndex:1}))??this.get,this.findPeer=((c=t.metrics)==null?void 0:c.traceFunction("helia.routing.findPeer",this.findPeer.bind(this),{optionsIndex:1}))??this.findPeer,this.getClosestPeers=((l=t.metrics)==null?void 0:l.traceFunction("helia.routing.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1}))??this.getClosestPeers}async start(){await Ln(...this.routers)}async stop(){await Cs(...this.routers)}async*findProviders(t,e={}){if(this.routers.length===0)throw new fa("No content routers available");const r=new ys({concurrency:this.providerLookupConcurrency});r.addEventListener("error",()=>{});for await(const s of us(r.toGenerator(),...Ls(this.routers,"findProviders").map(i=>i.findProviders(t,e))))if(s!=null){if(s.multiaddrs.length===0){if(r.find(s.id)!=null)continue;r.add(async()=>{try{const i=await this.findPeer(s.id,e);return i.multiaddrs.length===0?null:i}catch(i){return this.log.error("could not load multiaddrs for peer %p",s.id,i),null}},{peerId:s.id,signal:e.signal}).catch(i=>{this.log.error("could not load multiaddrs for peer %p",s.id,i)})}yield s}}async provide(t,e={}){if(this.routers.length===0)throw new fa("No content routers available");await Promise.all(Ls(this.routers,"provide").map(async r=>{await r.provide(t,e)}))}async cancelReprovide(t,e={}){await Promise.all(Ls(this.routers,"cancelReprovide").map(async r=>{await r.cancelReprovide(t,e)}))}async put(t,e,r){await Promise.all(Ls(this.routers,"put").map(async s=>{await s.put(t,e,r)}))}async get(t,e){return Promise.any(Ls(this.routers,"get").map(async r=>r.get(t,e)))}async findPeer(t,e){if(this.routers.length===0)throw new fa("No peer routers available");const r=this,s=us(...Ls(this.routers,"findPeer").map(i=>async function*(){try{yield await i.findPeer(t,e)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i;throw new Nt("Could not find peer in routing")}async*getClosestPeers(t,e={}){if(this.routers.length===0)throw new fa("No peer routers available");for await(const r of us(...Ls(this.routers,"getClosestPeers").map(s=>s.getClosestPeers(t,e))))r!=null&&(yield r)}}function Ls(n,t){return n.filter(e=>e[t]!=null)}const fs={},fi=n=>{n.addEventListener("message",t=>{fi.dispatchEvent("message",n,t)}),n.port!=null&&n.port.addEventListener("message",t=>{fi.dispatchEvent("message",n,t)})};fi.addEventListener=(n,t)=>{fs[n]==null&&(fs[n]=[]),fs[n].push(t)};fi.removeEventListener=(n,t)=>{fs[n]!=null&&(fs[n]=fs[n].filter(e=>e===t))};fi.dispatchEvent=function(n,t,e){fs[n]!=null&&fs[n].forEach(r=>r(t,e))};const G2="lock:worker:request-read",Q2="lock:worker:release-read",Y2="lock:master:grant-read",X2="lock:worker:request-write",Z2="lock:worker:release-write",J2="lock:master:grant-write",rk=(n=21)=>Math.random().toString().substring(2),j2=(n,t,e,r,s)=>(i,o)=>{if(o.data.type!==e)return;const a={type:o.data.type,name:o.data.name,identifier:o.data.identifier};n.dispatchEvent(new MessageEvent(t,{data:{name:a.name,handler:async()=>{i.postMessage({type:s,name:a.name,identifier:a.identifier}),await new Promise(c=>{const l=h=>{if((h==null?void 0:h.data)==null)return;const d={type:h.data.type,name:h.data.name,identifier:h.data.identifier};d.type===r&&d.identifier===a.identifier&&(i.removeEventListener("message",l),c())};i.addEventListener("message",l)})}}}))},eg=(n,t,e,r)=>async()=>{const s=rk();return globalThis.postMessage({type:t,identifier:s,name:n}),new Promise(i=>{const o=a=>{if((a==null?void 0:a.data)==null)return;const c={type:a.data.type,identifier:a.data.identifier};c.type===e&&c.identifier===s&&(globalThis.removeEventListener("message",o),i(()=>{globalThis.postMessage({type:r,identifier:s,name:n})}))};globalThis.addEventListener("message",o)})},nk={singleProcess:!1},sk=n=>{if(n=Object.assign({},nk,n),!!globalThis.document||n.singleProcess){const e=new EventTarget;return fi.addEventListener("message",j2(e,"requestReadLock",G2,Q2,Y2)),fi.addEventListener("message",j2(e,"requestWriteLock",X2,Z2,J2)),e}return{isWorker:!0,readLock:e=>eg(e,G2,Y2,Q2),writeLock:e=>eg(e,X2,J2,Z2)}},Os={};let ts;async function $h(n,t){let e;const r=new Promise(s=>{e=s});return n.add(async()=>lc((async()=>{await new Promise(s=>{e(()=>{s()})})})(),{milliseconds:t.timeout})),r}const ik=(n,t)=>{if(ts.isWorker===!0)return{readLock:ts.readLock(n,t),writeLock:ts.writeLock(n,t)};const e=new Fa({concurrency:1});let r;return{async readLock(){if(r!=null)return $h(r,t);r=new Fa({concurrency:t.concurrency,autoStart:!1});const s=r,i=$h(r,t);return e.add(async()=>{s.start(),await s.onIdle().then(()=>{r===s&&(r=null)})}),i},async writeLock(){return r=null,$h(e,t)}}},ok={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function Xf(n){const t=Object.assign({},ok,n);return ts==null&&(ts=sk(t),ts.isWorker!==!0&&(ts.addEventListener("requestReadLock",e=>{Os[e.data.name]!=null&&Os[e.data.name].readLock().then(async r=>e.data.handler().finally(()=>{r()}))}),ts.addEventListener("requestWriteLock",async e=>{Os[e.data.name]!=null&&Os[e.data.name].writeLock().then(async r=>e.data.handler().finally(()=>{r()}))}))),Os[t.name]==null&&(Os[t.name]=ik(t.name,t)),Os[t.name]}class ak{constructor(t,e,r={}){u(this,"lock");u(this,"child");u(this,"pins");u(this,"started");this.child=t,this.pins=e,this.lock=Xf({singleProcess:r.holdGcLock}),this.started=!1}isStarted(){return this.started}async start(){await Ln(this.child),this.started=!0}async stop(){await Cs(this.child),this.started=!1}unwrap(){return this.child}async put(t,e,r={}){var i;(i=r==null?void 0:r.signal)==null||i.throwIfAborted();const s=await this.lock.readLock();try{return await this.child.put(t,e,r)}finally{s()}}async*putMany(t,e={}){var s;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const r=await this.lock.readLock();try{yield*this.child.putMany(t,e)}finally{r()}}async get(t,e={}){var s;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const r=await this.lock.readLock();try{return await this.child.get(t,e)}finally{r()}}async*getMany(t,e={}){var s;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const r=await this.lock.readLock();try{yield*this.child.getMany(t,e)}finally{r()}}async delete(t,e={}){var s;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const r=await this.lock.writeLock();try{if(await this.pins.isPinned(t))throw new Error("CID was pinned");await this.child.delete(t,e)}finally{r()}}async*deleteMany(t,e={}){var s;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const r=await this.lock.writeLock();try{const i=this;yield*this.child.deleteMany(async function*(){for await(const o of t){if(await i.pins.isPinned(o))throw new Error("CID was pinned");yield o}}(),e)}finally{r()}}async has(t,e={}){var s;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const r=await this.lock.readLock();try{return await this.child.has(t,e)}finally{r()}}async*getAll(t={}){var r;(r=t==null?void 0:t.signal)==null||r.throwIfAborted();const e=await this.lock.readLock();try{yield*this.child.getAll(t)}finally{e()}}createSession(t,e){var r;return(r=e==null?void 0:e.signal)==null||r.throwIfAborted(),this.child.createSession(t,e)}}const zh=new Ge("/version"),tg=1;async function ck(n){if(!await n.has(zh)){await n.put(zh,Y(`${tg}`));return}const t=await n.get(zh),e=Z(t);if(parseInt(e,10)!==tg)throw new Error("Unknown datastore version, a datastore migration may be required")}const L5=42;function O5(n){return n instanceof ArrayBuffer?new Uint8Array(n,0,n.byteLength):n}function lk(n){if(n.asCID!==n&&n["/"]!==n.bytes)return null;const t=te.asCID(n);if(!t)return null;const e=new Uint8Array(t.bytes.byteLength+1);return e.set(t.bytes,1),[new G(B.tag,L5),new G(B.bytes,e)]}function uk(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function hk(n){if(Number.isNaN(n))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(n===1/0||n===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const n1={float64:!0,typeEncoders:{Object:lk,undefined:uk,number:hk}},dk={...n1,typeEncoders:{...n1.typeEncoders}};function fk(n){if(n[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return te.decode(n.subarray(1))}const zl={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};zl.tags[L5]=fk;const gk={...zl,tags:zl.tags.slice()},pk="dag-cbor",Zf=113,mk=n=>al(n,n1),F5=n=>es(O5(n),zl),yk=Object.freeze(Object.defineProperty({__proto__:null,code:Zf,decode:F5,decodeOptions:gk,encode:mk,encodeOptions:dk,name:pk,toByteView:O5},Symbol.toStringTag,{value:"Module"}));class wk extends Array{constructor(){super(),this.inRecursive=[]}prefix(t){const e=this.inRecursive[this.inRecursive.length-1];e&&(e.type===B.array&&(e.elements++,e.elements!==1&&t.push([44])),e.type===B.map&&(e.elements++,e.elements!==1&&(e.elements%2===1?t.push([44]):t.push([58]))))}[B.uint.major](t,e){this.prefix(t);const r=String(e.value),s=[];for(let i=0;i<r.length;i++)s[i]=r.charCodeAt(i);t.push(s)}[B.negint.major](t,e){this[B.uint.major](t,e)}[B.bytes.major](t,e){throw new Error(`${ri} unsupported type: Uint8Array`)}[B.string.major](t,e){this.prefix(t);const r=v5(JSON.stringify(e.value));t.push(r.length>32?Uf(r):r)}[B.array.major](t,e){this.prefix(t),this.inRecursive.push({type:B.array,elements:0}),t.push([91])}[B.map.major](t,e){this.prefix(t),this.inRecursive.push({type:B.map,elements:0}),t.push([123])}[B.tag.major](t,e){}[B.float.major](t,e){if(e.type.name==="break"){const o=this.inRecursive.pop();if(o){if(o.type===B.array)t.push([93]);else if(o.type===B.map)t.push([125]);else throw new Error("Unexpected recursive type; this should not happen!");return}throw new Error("Unexpected break; this should not happen!")}if(e.value===void 0)throw new Error(`${ri} unsupported type: undefined`);if(this.prefix(t),e.type.name==="true"){t.push([116,114,117,101]);return}else if(e.type.name==="false"){t.push([102,97,108,115,101]);return}else if(e.type.name==="null"){t.push([110,117,108,108]);return}const r=String(e.value),s=[];let i=!1;for(let o=0;o<r.length;o++)s[o]=r.charCodeAt(o),!i&&(s[o]===46||s[o]===101||s[o]===69)&&(i=!0);i||(s.push(46),s.push(48)),t.push(s)}}function bk(n,t){if(Array.isArray(n[0])||Array.isArray(t[0]))throw new Error(`${ri} complex map keys are not supported`);const e=n[0],r=t[0];if(e.type!==B.string||r.type!==B.string)throw new Error(`${ri} non-string map keys are not supported`);if(e<r)return-1;if(e>r)return 1;throw new Error(`${ri} unexpected duplicate map keys, this is not supported`)}const vk={addBreakTokens:!0,mapSorter:bk};function Ek(n,t){return t=Object.assign({},vk,t),P5(n,new wk,t)}class U5{constructor(t,e={}){this._pos=0,this.data=t,this.options=e,this.modeStack=["value"],this.lastToken=""}pos(){return this._pos}done(){return this._pos>=this.data.length}ch(){return this.data[this._pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let t=this.ch();for(;t===32||t===9||t===13||t===10;)t=this.data[++this._pos]}expect(t){if(this.data.length-this._pos<t.length)throw new Error(`${ce} unexpected end of input at position ${this._pos}`);for(let e=0;e<t.length;e++)if(this.data[this._pos++]!==t[e])throw new Error(`${ce} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...t)}'`)}parseNumber(){const t=this._pos;let e=!1,r=!1;const s=a=>{for(;!this.done();){const c=this.ch();if(a.includes(c))this._pos++;else break}};if(this.ch()===45&&(e=!0,this._pos++),this.ch()===48)if(this._pos++,this.ch()===46)this._pos++,r=!0;else return new G(B.uint,0,this._pos-t);if(s([48,49,50,51,52,53,54,55,56,57]),e&&this._pos===t+1)throw new Error(`${ce} unexpected token at position ${this._pos}`);if(!this.done()&&this.ch()===46){if(r)throw new Error(`${ce} unexpected token at position ${this._pos}`);r=!0,this._pos++,s([48,49,50,51,52,53,54,55,56,57])}!this.done()&&(this.ch()===101||this.ch()===69)&&(r=!0,this._pos++,!this.done()&&(this.ch()===43||this.ch()===45)&&this._pos++,s([48,49,50,51,52,53,54,55,56,57]));const i=String.fromCharCode.apply(null,this.data.subarray(t,this._pos)),o=parseFloat(i);return r?new G(B.float,o,this._pos-t):this.options.allowBigInt!==!0||Number.isSafeInteger(o)?new G(o>=0?B.uint:B.negint,o,this._pos-t):new G(o>=0?B.uint:B.negint,BigInt(i),this._pos-t)}parseString(){if(this.ch()!==34)throw new Error(`${ce} unexpected character at position ${this._pos}; this shouldn't happen`);this._pos++;for(let i=this._pos,o=0;i<this.data.length&&o<65536;i++,o++){const a=this.data[i];if(a===92||a<32||a>=128)break;if(a===34){const c=String.fromCharCode.apply(null,this.data.subarray(this._pos,i));return this._pos=i+1,new G(B.string,c,o)}}const t=this._pos,e=[],r=()=>{if(this._pos+4>=this.data.length)throw new Error(`${ce} unexpected end of unicode escape sequence at position ${this._pos}`);let i=0;for(let o=0;o<4;o++){let a=this.ch();if(a>=48&&a<=57)a-=48;else if(a>=97&&a<=102)a=a-97+10;else if(a>=65&&a<=70)a=a-65+10;else throw new Error(`${ce} unexpected unicode escape character at position ${this._pos}`);i=i*16+a,this._pos++}return i},s=()=>{const i=this.ch();let o=null,a=i>239?4:i>223?3:i>191?2:1;if(this._pos+a>this.data.length)throw new Error(`${ce} unexpected unicode sequence at position ${this._pos}`);let c,l,h,d;switch(a){case 1:i<128&&(o=i);break;case 2:c=this.data[this._pos+1],(c&192)===128&&(d=(i&31)<<6|c&63,d>127&&(o=d));break;case 3:c=this.data[this._pos+1],l=this.data[this._pos+2],(c&192)===128&&(l&192)===128&&(d=(i&15)<<12|(c&63)<<6|l&63,d>2047&&(d<55296||d>57343)&&(o=d));break;case 4:c=this.data[this._pos+1],l=this.data[this._pos+2],h=this.data[this._pos+3],(c&192)===128&&(l&192)===128&&(h&192)===128&&(d=(i&15)<<18|(c&63)<<12|(l&63)<<6|h&63,d>65535&&d<1114112&&(o=d))}o===null?(o=65533,a=1):o>65535&&(o-=65536,e.push(o>>>10&1023|55296),o=56320|o&1023),e.push(o),this._pos+=a};for(;!this.done();){const i=this.ch();let o;switch(i){case 92:if(this._pos++,this.done())throw new Error(`${ce} unexpected string termination at position ${this._pos}`);switch(o=this.ch(),this._pos++,o){case 34:case 39:case 92:case 47:e.push(o);break;case 98:e.push(8);break;case 116:e.push(9);break;case 110:e.push(10);break;case 102:e.push(12);break;case 114:e.push(13);break;case 117:e.push(r());break;default:throw new Error(`${ce} unexpected string escape character at position ${this._pos}`)}break;case 34:return this._pos++,new G(B.string,E5(e),this._pos-t);default:if(i<32)throw new Error(`${ce} invalid control character at position ${this._pos}`);i<128?(e.push(i),this._pos++):s()}}throw new Error(`${ce} unexpected end of string at position ${this._pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this._pos++,new G(B.map,1/0,1);case 91:return this.modeStack.push("array-start"),this._pos++,new G(B.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new G(B.null,null,4);case 102:return this.expect([102,97,108,115,101]),new G(B.false,!1,5);case 116:return this.expect([116,114,117,101]),new G(B.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${ce} unexpected character at position ${this._pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":{if(this.modeStack.pop(),this.ch()===93)return this._pos++,this.skipWhitespace(),new G(B.break,void 0,1);if(this.ch()!==44)throw new Error(`${ce} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this._pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue()}case"array-start":return this.modeStack.pop(),this.ch()===93?(this._pos++,this.skipWhitespace(),new G(B.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(this.ch()===125)return this.modeStack.pop(),this._pos++,this.skipWhitespace(),new G(B.break,void 0,1);if(this.ch()!==44)throw new Error(`${ce} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this._pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),this.ch()===125)return this._pos++,this.skipWhitespace(),new G(B.break,void 0,1);const t=this.parseString();if(this.skipWhitespace(),this.ch()!==58)throw new Error(`${ce} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this._pos++,this.modeStack.push("obj-value"),t}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${ce} unexpected parse state at position ${this._pos}; this shouldn't happen`)}}}function Sk(n,t){return t=Object.assign({tokenizer:new U5(n,t)},t),es(n,t)}function xk(n){return n instanceof ArrayBuffer?new Uint8Array(n,0,n.byteLength):n}function _k(n){if(n.asCID!==n&&n["/"]!==n.bytes)return null;const t=te.asCID(n);if(!t)return null;const e=t.toString();return[new G(B.map,1/0,1),new G(B.string,"/",1),new G(B.string,e,e.length),new G(B.break,void 0,1)]}function Vl(n){const t=kr.encode(n).slice(1);return[new G(B.map,1/0,1),new G(B.string,"/",1),new G(B.map,1/0,1),new G(B.string,"bytes",5),new G(B.string,t,t.length),new G(B.break,void 0,1),new G(B.break,void 0,1)]}function Pr(n){return Vl(new Uint8Array(n.buffer,n.byteOffset,n.byteLength))}function kk(n){return Vl(new Uint8Array(n))}function Ik(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function Ak(n){if(Number.isNaN(n))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(n===1/0||n===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const Tk={typeEncoders:{Object:_k,Buffer:Vl,Uint8Array:Vl,Int8Array:Pr,Uint16Array:Pr,Int16Array:Pr,Uint32Array:Pr,Int32Array:Pr,Float32Array:Pr,Float64Array:Pr,Uint8ClampedArray:Pr,BigInt64Array:Pr,BigUint64Array:Pr,DataView:Pr,ArrayBuffer:kk,undefined:Ik,number:Ak}};class Ck extends U5{constructor(t,e){super(t,e),this.tokenBuffer=[]}done(){return this.tokenBuffer.length===0&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const t=this._next();if(t.type===B.map){const e=this._next();if(e.type===B.string&&e.value==="/"){const r=this._next();if(r.type===B.string){if(this._next().type!==B.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(r),new G(B.tag,42,0)}if(r.type===B.map){const s=this._next();if(s.type===B.string&&s.value==="bytes"){const i=this._next();if(i.type===B.string){for(let a=0;a<2;a++)if(this._next().type!==B.break)throw new Error("Invalid encoded Bytes form");const o=kr.decode(`m${i.value}`);return new G(B.bytes,o,i.value.length)}this.tokenBuffer.push(i)}this.tokenBuffer.push(s)}this.tokenBuffer.push(r)}this.tokenBuffer.push(e)}return t}}const s1={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};s1.tags[42]=te.parse;const Pk="dag-json",Jf=297,$5=n=>Ek(n,Tk),jf=n=>{const t=xk(n),e=Object.assign(s1,{tokenizer:new Ck(t,s1)});return Sk(t,e)},rg=n=>Dk.decode($5(n)),Dk=new TextDecoder,Rk=n=>jf(Bk.encode(n)),Bk=new TextEncoder,Mk=Object.freeze(Object.defineProperty({__proto__:null,code:Jf,decode:jf,encode:$5,format:rg,name:Pk,parse:Rk,stringify:rg},Symbol.toStringTag,{value:"Module"})),Nk=new TextDecoder;function e0(n,t){let e=0;for(let r=0;;r+=7){if(r>=64)throw new Error("protobuf: varint overflow");if(t>=n.length)throw new Error("protobuf: unexpected end of data");const s=n[t++];if(e+=r<28?(s&127)<<r:(s&127)*2**r,s<128)break}return[e,t]}function Hl(n,t){let e;[e,t]=e0(n,t);const r=t+e;if(e<0||r<0)throw new Error("protobuf: invalid length");if(r>n.length)throw new Error("protobuf: unexpected end of data");return[n.subarray(t,r),r]}function z5(n,t){let e;return[e,t]=e0(n,t),[e&7,e>>3,t]}function Lk(n){const t={},e=n.length;let r=0;for(;r<e;){let s,i;if([s,i,r]=z5(n,r),i===1){if(t.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(s!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Hash`);if(t.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(t.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash,r]=Hl(n,r)}else if(i===2){if(t.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(s!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Name`);if(t.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let o;[o,r]=Hl(n,r),t.Name=Nk.decode(o)}else if(i===3){if(t.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(s!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${s}) for Tsize`);[t.Tsize,r]=e0(n,r)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${i}`)}if(r>e)throw new Error("protobuf: (PBLink) unexpected end of data");return t}function Ok(n){const t=n.length;let e=0,r,s=!1,i;for(;e<t;){let a,c;if([a,c,e]=z5(n,e),a!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${a}`);if(c===1){if(i)throw new Error("protobuf: (PBNode) duplicate Data section");[i,e]=Hl(n,e),r&&(s=!0)}else if(c===2){if(s)throw new Error("protobuf: (PBNode) duplicate Links section");r||(r=[]);let l;[l,e]=Hl(n,e),r.push(Lk(l))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${c}`)}if(e>t)throw new Error("protobuf: (PBNode) unexpected end of data");const o={};return i&&(o.Data=i),o.Links=r||[],o}const V5=new TextEncoder,ng=2**32,Fk=2**31;function Uk(n,t){let e=t.length;if(typeof n.Tsize=="number"){if(n.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(n.Tsize))throw new Error("Tsize too large for encoding");e=Ea(t,e,n.Tsize)-1,t[e]=24}if(typeof n.Name=="string"){const r=V5.encode(n.Name);e-=r.length,t.set(r,e),e=Ea(t,e,r.length)-1,t[e]=18}return n.Hash&&(e-=n.Hash.length,t.set(n.Hash,e),e=Ea(t,e,n.Hash.length)-1,t[e]=10),t.length-e}function $k(n){const t=Vk(n),e=new Uint8Array(t);let r=t;if(n.Data&&(r-=n.Data.length,e.set(n.Data,r),r=Ea(e,r,n.Data.length)-1,e[r]=10),n.Links)for(let s=n.Links.length-1;s>=0;s--){const i=Uk(n.Links[s],e.subarray(0,r));r-=i,r=Ea(e,r,i)-1,e[r]=18}return e}function zk(n){let t=0;if(n.Hash){const e=n.Hash.length;t+=1+e+ro(e)}if(typeof n.Name=="string"){const e=V5.encode(n.Name).length;t+=1+e+ro(e)}return typeof n.Tsize=="number"&&(t+=1+ro(n.Tsize)),t}function Vk(n){let t=0;if(n.Data){const e=n.Data.length;t+=1+e+ro(e)}if(n.Links)for(const e of n.Links){const r=zk(e);t+=1+r+ro(r)}return t}function Ea(n,t,e){t-=ro(e);const r=t;for(;e>=Fk;)n[t++]=e&127|128,e/=128;for(;e>=128;)n[t++]=e&127|128,e>>>=7;return n[t]=e,r}function ro(n){return n%2===0&&n++,Math.floor((Hk(n)+6)/7)}function Hk(n){let t=0;return n>=ng&&(n=Math.floor(n/ng),t=32),n>=65536&&(n>>>=16,t+=16),n>=256&&(n>>>=8,t+=8),t+qk[n]}const qk=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],Wk=["Data","Links"],Kk=["Hash","Name","Tsize"],i1=new TextEncoder;function H5(n,t){if(n===t)return 0;const e=n.Name?i1.encode(n.Name):[],r=t.Name?i1.encode(t.Name):[];let s=e.length,i=r.length;for(let o=0,a=Math.min(s,i);o<a;++o)if(e[o]!==r[o]){s=e[o],i=r[o];break}return s<i?-1:i<s?1:0}function sg(n,t){return!Object.keys(n).some(e=>!t.includes(e))}function q5(n){if(typeof n.asCID=="object"){const e=te.asCID(n);if(!e)throw new TypeError("Invalid DAG-PB form");return{Hash:e}}if(typeof n!="object"||Array.isArray(n))throw new TypeError("Invalid DAG-PB form");const t={};if(n.Hash){let e=te.asCID(n.Hash);try{e||(typeof n.Hash=="string"?e=te.parse(n.Hash):n.Hash instanceof Uint8Array&&(e=te.decode(n.Hash)))}catch(r){throw new TypeError(`Invalid DAG-PB form: ${r.message}`)}e&&(t.Hash=e)}if(!t.Hash)throw new TypeError("Invalid DAG-PB form");return typeof n.Name=="string"&&(t.Name=n.Name),typeof n.Tsize=="number"&&(t.Tsize=n.Tsize),t}function gr(n){if((n instanceof Uint8Array||typeof n=="string")&&(n={Data:n}),typeof n!="object"||Array.isArray(n))throw new TypeError("Invalid DAG-PB form");const t={};if(n.Data!==void 0)if(typeof n.Data=="string")t.Data=i1.encode(n.Data);else if(n.Data instanceof Uint8Array)t.Data=n.Data;else throw new TypeError("Invalid DAG-PB form");if(n.Links!==void 0)if(Array.isArray(n.Links))t.Links=n.Links.map(q5),t.Links.sort(H5);else throw new TypeError("Invalid DAG-PB form");else t.Links=[];return t}function W5(n){if(!n||typeof n!="object"||Array.isArray(n)||n instanceof Uint8Array||n["/"]&&n["/"]===n.bytes)throw new TypeError("Invalid DAG-PB form");if(!sg(n,Wk))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(n.Data!==void 0&&!(n.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be bytes)");if(!Array.isArray(n.Links))throw new TypeError("Invalid DAG-PB form (Links must be a list)");for(let t=0;t<n.Links.length;t++){const e=n.Links[t];if(!e||typeof e!="object"||Array.isArray(e)||e instanceof Uint8Array||e["/"]&&e["/"]===e.bytes)throw new TypeError("Invalid DAG-PB form (bad link)");if(!sg(e,Kk))throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");if(e.Hash===void 0)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(e.Hash==null||!e.Hash["/"]||e.Hash["/"]!==e.Hash.bytes)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(e.Name!==void 0&&typeof e.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(e.Tsize!==void 0){if(typeof e.Tsize!="number"||e.Tsize%1!==0)throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(e.Tsize<0)throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)")}if(t>0&&H5(e,n.Links[t-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function Gk(n,t=[]){return gr({Data:n,Links:t})}function Qk(n,t,e){return q5({Hash:e,Name:n,Tsize:t})}function Yk(n){return n instanceof ArrayBuffer?new Uint8Array(n,0,n.byteLength):n}const Xk="dag-pb",bn=112;function pt(n){W5(n);const t={};return n.Links&&(t.Links=n.Links.map(e=>{const r={};return e.Hash&&(r.Hash=e.Hash.bytes),e.Name!==void 0&&(r.Name=e.Name),e.Tsize!==void 0&&(r.Tsize=e.Tsize),r})),n.Data&&(t.Data=n.Data),$k(t)}function Kr(n){const t=Yk(n),e=Ok(t),r={};return e.Data&&(r.Data=e.Data),e.Links&&(r.Links=e.Links.map(s=>{const i={};try{i.Hash=te.decode(s.Hash)}catch{}if(!i.Hash)throw new Error("Invalid Hash field found in link, expected CID");return s.Name!==void 0&&(i.Name=s.Name),s.Tsize!==void 0&&(i.Tsize=s.Tsize),i})),r}const dc=Object.freeze(Object.defineProperty({__proto__:null,code:bn,createLink:Qk,createNode:Gk,decode:Kr,encode:pt,name:Xk,prepare:gr,validate:W5},Symbol.toStringTag,{value:"Module"}));function t0(n){return(n==null?void 0:n.then)!=null}function Zk(n=[],t){const e={[bn]:dc,[qr]:xf,[Zf]:yk,[Jf]:Mk,[Mu]:xb};return n.forEach(r=>{e[r.code]=r}),async r=>{let s=e[r];if(s==null&&t!=null){const i=t(r);t0(i)?s=await i:s=i,e[s.code]=s}if(s!=null)return s;throw new N5(`Could not load codec for ${r}`)}}function Jk(n=[],t){const e={[gt.code]:gt,[h2.code]:h2,[bs.code]:bs};return n.forEach(r=>{e[r.code]=r}),async r=>{let s=e[r];if(s==null&&t!=null){const i=t(r);t0(i)?s=await i:s=i,e[s.code]=s}if(s!=null)return s;throw new M5(`No hasher configured for multihash code 0x${r.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`)}}var Pn;let r0=(Pn=class extends Error{constructor(e="Not Found"){super(e);u(this,"name",Pn.name);u(this,"code",Pn.code)}},u(Pn,"name","NotFoundError"),u(Pn,"code","ERR_NOT_FOUND"),Pn);class K5{has(t,e){return Promise.reject(new Error(".has is not implemented"))}put(t,e,r){return Promise.reject(new Error(".put is not implemented"))}async*putMany(t,e){for await(const{cid:r,block:s}of t)await this.put(r,s,e),yield r}get(t,e){return Promise.reject(new Error(".get is not implemented"))}async*getMany(t,e){for await(const r of t)yield{cid:r,block:await this.get(r,e)}}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*deleteMany(t,e){for await(const r of t)await this.delete(r,e),yield r}async*getAll(t){throw new Error(".getAll is not implemented")}}const Fc=0;class jk extends K5{constructor(e){super();u(this,"child");this.child=e}put(e,r){return e.multihash.code===Fc||this.child==null?e:this.child.put(e,r)}get(e){if(e.multihash.code===Fc)return e.multihash.digest;if(this.child==null)throw new r0;return this.child.get(e)}has(e){return e.multihash.code===Fc?!0:this.child==null?!1:this.child.has(e)}delete(e){if(e.code!==Fc&&this.child!=null)return this.child.delete(e)}getAll(e){return this.child!=null?this.child.getAll(e):[]}}function eI(n){return n[Symbol.asyncIterator]!=null}function Jn(n,t){let e=0;if(eI(n))return async function*(){for await(const c of n)await t(c,e++)&&(yield c)}();const r=wf(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for await(const c of r)await t(c,e++)&&(yield c)}();const a=t;return function*(){o===!0&&(yield s);for(const c of r)a(c,e++)&&(yield c)}()}function tI(n){return n[Symbol.asyncIterator]!=null}function ig(n){return(n==null?void 0:n.then)!=null}function ql(n,t){let e=0;if(tI(n))return async function*(){for await(const c of n){const l=t(c,e++);ig(l)&&await l,yield c}}();const r=wf(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof(o==null?void 0:o.then)=="function")return async function*(){yield s;for await(const c of r){const l=t(c,e++);ig(l)&&await l,yield c}}();const a=t;return function*(){yield s;for(const c of r)a(c,e++),yield c}()}class G5{constructor(t){u(this,"child");u(this,"getHasher");u(this,"log");u(this,"logger");u(this,"components");this.log=t.logger.forComponent("helia:networked-storage"),this.logger=t.logger,this.components=t,this.child=new jk(t.blockstore),this.getHasher=t.getHasher}async put(t,e,r={}){var s,i,o;return await this.child.has(t,r)?((s=r.onProgress)==null||s.call(r,new se("blocks:put:duplicate",t)),t):((i=r.onProgress)==null||i.call(r,new se("blocks:put:providers:notify",t)),await Promise.all(this.components.blockBrokers.map(async a=>{var c;return(c=a.announce)==null?void 0:c.call(a,t,e,r)})),(o=r.onProgress)==null||o.call(r,new se("blocks:put:blockstore:put",t)),this.child.put(t,e,r))}async*putMany(t,e={}){var i;const r=Jn(t,async({cid:o})=>{var c;const a=await this.child.has(o,e);return a&&((c=e.onProgress)==null||c.call(e,new se("blocks:put-many:duplicate",o))),!a}),s=ql(r,async({cid:o,block:a})=>{var c;(c=e.onProgress)==null||c.call(e,new se("blocks:put-many:providers:notify",o)),await Promise.all(this.components.blockBrokers.map(async l=>{var h;return(h=l.announce)==null?void 0:h.call(l,o,a,e)}))});(i=e.onProgress)==null||i.call(e,new se("blocks:put-many:blockstore:put-many")),yield*this.child.putMany(s,e)}async get(t,e={}){var r,s,i,o;if(e.offline!==!0&&!await this.child.has(t,e)){const a=await this.getHasher(t.multihash.code);(r=e.onProgress)==null||r.call(e,new se("blocks:get:providers:get",t));const c=await og(t,this.components.blockBrokers,a,{...e,log:this.log});return(s=e.onProgress)==null||s.call(e,new se("blocks:get:blockstore:put",t)),await this.child.put(t,c,e),(i=e.onProgress)==null||i.call(e,new se("blocks:get:providers:notify",t)),await Promise.all(this.components.blockBrokers.map(async l=>{var h;return(h=l.announce)==null?void 0:h.call(l,t,c,e)})),c}return(o=e.onProgress)==null||o.call(e,new se("blocks:get:blockstore:get",t)),this.child.get(t,e)}async*getMany(t,e={}){var r;(r=e.onProgress)==null||r.call(e,new se("blocks:get-many:blockstore:get-many")),yield*this.child.getMany(ql(t,async s=>{var i,o,a;if(e.offline!==!0&&!await this.child.has(s,e)){const c=await this.getHasher(s.multihash.code);(i=e.onProgress)==null||i.call(e,new se("blocks:get-many:providers:get",s));const l=await og(s,this.components.blockBrokers,c,{...e,log:this.log});(o=e.onProgress)==null||o.call(e,new se("blocks:get-many:blockstore:put",s)),await this.child.put(s,l,e),(a=e.onProgress)==null||a.call(e,new se("blocks:get-many:providers:notify",s)),await Promise.all(this.components.blockBrokers.map(async h=>{var d;return(d=h.announce)==null?void 0:d.call(h,s,l,e)}))}}))}async delete(t,e={}){var r;(r=e.onProgress)==null||r.call(e,new se("blocks:delete:blockstore:delete",t)),await this.child.delete(t,e)}async*deleteMany(t,e={}){var r;(r=e.onProgress)==null||r.call(e,new se("blocks:delete-many:blockstore:delete-many")),yield*this.child.deleteMany(async function*(){for await(const s of t)yield s}(),e)}async has(t,e={}){return this.child.has(t,e)}async*getAll(t={}){var e;(e=t.onProgress)==null||e.call(t,new se("blocks:get-all:blockstore:get-many")),yield*this.child.getAll(t)}}class rI extends G5{constructor(e){super(e);u(this,"started");this.started=!1}isStarted(){return this.started}async start(){await Ln(this.child,...this.components.blockBrokers),this.started=!0}async stop(){await Cs(this.child,...this.components.blockBrokers),this.started=!1}unwrap(){return this.child}createSession(e,r){const s=this.components.blockBrokers.map(i=>i.createSession==null?i:i.createSession(r));return new nI({blockstore:this.child,blockBrokers:s,getHasher:this.getHasher,logger:this.logger},{root:e})}}class nI extends G5{constructor(e,r){super(e);u(this,"closeController");this.closeController=new AbortController,this.closeController.signal,this.log=e.logger.forComponent(`helia:session-storage:${r.root}`)}close(){this.closeController.abort()}async put(e,r,s={}){const i=Ne([this.closeController.signal,s.signal]);try{return await super.put(e,r,{...s,signal:i})}finally{i.clear()}}async*putMany(e,r={}){const s=Ne([this.closeController.signal,r.signal]);try{yield*super.putMany(e,{...r,signal:s})}finally{s.clear()}}async get(e,r={}){const s=Ne([this.closeController.signal,r.signal]);try{return await super.get(e,{...r,signal:s})}finally{s.clear()}}async*getMany(e,r={}){const s=Ne([this.closeController.signal,r.signal]);try{yield*super.getMany(e,{...r,signal:s})}finally{s.clear()}}async delete(e,r={}){const s=Ne([this.closeController.signal,r.signal]);try{await super.delete(e,{...r,signal:s})}finally{s.clear()}}async*deleteMany(e,r={}){const s=Ne([this.closeController.signal,r.signal]);try{yield*super.deleteMany(e,{...r,signal:s})}finally{s.clear()}}async has(e,r={}){const s=Ne([this.closeController.signal,r.signal]);try{return await super.has(e,{...r,signal:s})}finally{s.clear()}}async*getAll(e={}){const r=Ne([this.closeController.signal,e.signal]);try{yield*super.getAll({...e,signal:r})}finally{r.clear()}}}function sI(n){return typeof n.retrieve=="function"}const iI=(n,t)=>{if(t==null)throw new W(`No hasher configured for multihash code 0x${n.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);return async e=>{let r;const s=t.digest(e);if(t0(s)?r=await s:r=s,!_e(r.digest,n.multihash.digest))throw new Cu("Hash of downloaded block did not match multihash from passed CID")}};async function og(n,t,e,r){const s=iI(n,e),i=new AbortController,o=Ne([i.signal,r.signal]);i.signal;const a=[];for(const c of t)sI(c)&&a.push(c);try{return await Promise.any(a.map(async c=>{try{let l=!1;const h=await c.retrieve(n,{...r,signal:o,validateFn:async d=>{await s(d),l=!0}});return l||await s(h),h}catch(l){throw r.log.error("could not retrieve verified block for %c",n,l),l}}))}finally{i.abort(),o.clear()}}class Q5 extends Et{constructor(e,r){super();u(this,"initialPeerSearchComplete");u(this,"requests");u(this,"name");u(this,"log");u(this,"logger");u(this,"minProviders");u(this,"maxProviders");u(this,"providers");u(this,"evictionFilter");this.name=r.name,this.logger=e.logger,this.log=e.logger.forComponent(this.name),this.requests=new Map,this.minProviders=r.minProviders??J_,this.maxProviders=r.maxProviders??j_,this.providers=[],this.evictionFilter=hi(this.maxProviders)}async retrieve(e,r={}){const s=kr.encode(e.multihash.bytes),i=this.requests.get(s);if(i!=null)return this.log("join existing request for %c",e),i;const o=me();if(this.requests.set(s,o.promise),this.providers.length===0){let h=!1;this.initialPeerSearchComplete==null&&(h=!0,this.log=this.logger.forComponent(`${this.name}:${e}`),this.initialPeerSearchComplete=this.findProviders(e,this.minProviders,r)),await this.initialPeerSearchComplete,h&&this.log("found initial session peers for %c",e)}let a=!1;const c=new oi({concurrency:this.maxProviders});c.addEventListener("error",()=>{}),c.addEventListener("failure",h=>{this.log.error("error querying provider %o, evicting from session",h.detail.job.options.provider,h.detail.error),this.evict(h.detail.job.options.provider)}),c.addEventListener("success",h=>{a=!0,o.resolve(h.detail.result)}),c.addEventListener("idle",()=>{var h;a||((h=r.signal)==null?void 0:h.aborted)===!0||Promise.resolve().then(async()=>{this.log("no session peers had block for for %c, finding new providers",e);for(let d=0;d<this.minProviders&&this.providers.length!==0;d++){const f=this.providers[Math.floor(Math.random()*this.providers.length)];this.evict(f)}await this.findProviders(e,this.minProviders,r),this.log("found new providers re-retrieving %c",e),this.requests.delete(s),o.resolve(await this.retrieve(e,r))}).catch(d=>{this.log.error("could not find new providers for %c",e,d),o.reject(d)})});const l=h=>{c.add(async()=>this.queryProvider(e,h.detail,r),{provider:h.detail}).catch(d=>{var f;((f=r.signal)==null?void 0:f.aborted)!==!0&&this.log.error("error retrieving session block for %c",e,d)})};this.addEventListener("provider",l),Promise.all([...this.providers].map(async h=>c.add(async()=>this.queryProvider(e,h,r),{provider:h}))).catch(h=>{var d;((d=r.signal)==null?void 0:d.aborted)!==!0&&this.log.error("error retrieving session block for %c",e,h)});try{return await o.promise}finally{this.removeEventListener("provider",l),c.clear(),this.requests.delete(s)}}evict(e){this.evictionFilter.add(this.toEvictionKey(e));const r=this.providers.findIndex(s=>this.equals(s,e));r!==-1&&this.providers.splice(r,1)}isEvicted(e){return this.evictionFilter.has(this.toEvictionKey(e))}hasProvider(e){return!!(this.providers.find(r=>this.equals(r,e))!=null||this.isEvicted(e))}async findProviders(e,r,s){const i=me();let o=0;return Promise.resolve().then(async()=>{var a;this.log("finding %d-%d new provider(s) for %c",r,this.maxProviders,e);for await(const c of this.findNewProviders(e,s)){if(o===this.maxProviders||((a=s.signal)==null?void 0:a.aborted)===!0)break;if(!this.hasProvider(c)&&(this.log("found %d/%d new providers",o,this.maxProviders),this.providers.push(c),this.safeDispatchEvent("provider",{detail:c}),o++,o===r&&(this.log("session is ready"),i.resolve()),this.providers.length===this.maxProviders)){this.log("found max session peers",o);break}}if(this.log("found %d/%d new session peers",o,this.maxProviders),o<r)throw new B5(`Found ${o} of ${r} ${this.name} providers for ${e}`)}).catch(a=>{this.log.error("error searching routing for potential session peers for %c",e,a.errors??a),i.reject(a)}),i.promise}}class oI{constructor(t){u(this,"blockstore");u(this,"datastore");u(this,"pins");u(this,"logger");u(this,"routing");u(this,"getCodec");u(this,"getHasher");u(this,"dns");u(this,"metrics");u(this,"log");this.logger=t.logger??Ku(),this.log=this.logger.forComponent("helia"),this.getHasher=Jk(t.hashers,t.loadHasher),this.getCodec=Zk(t.codecs,t.loadCodec),this.dns=t.dns??b5(),this.metrics=t.metrics;const e={blockstore:t.blockstore,datastore:t.datastore,logger:this.logger,blockBrokers:[],getHasher:this.getHasher,getCodec:this.getCodec,dns:this.dns,metrics:this.metrics,...t.components??{}};this.routing=e.routing=new tk(e,{routers:(t.routers??[]).flatMap(s=>{const i=[s];return s[yo]!=null&&i.push(s[yo]),s[wo]!=null&&i.push(s[wo]),i}),providerLookupConcurrency:t.providerLookupConcurrency});const r=new rI(e);this.pins=new Z_(t.datastore,r,this.getCodec),this.blockstore=new ak(r,this.pins,{holdGcLock:t.holdGcLock??!0}),this.datastore=t.datastore,e.blockBrokers=t.blockBrokers.map(s=>s(e))}async start(){await ck(this.datastore),await Ln(this.blockstore,this.datastore,this.routing)}async stop(){await Cs(this.blockstore,this.datastore,this.routing)}async gc(t={}){const e=await this.blockstore.lock.writeLock();try{const r=this,s=this.blockstore.unwrap();this.log("gc start"),await ws(s.deleteMany(async function*(){var i,o;for await(const{cid:a}of s.getAll())try{if(await r.pins.isPinned(a,t))continue;yield a,(i=t.onProgress)==null||i.call(t,new se("helia:gc:deleted",a))}catch(c){r.log.error("Error during gc",c),(o=t.onProgress)==null||o.call(t,new se("helia:gc:error",c))}}()))}finally{e()}this.log("gc finished")}}class aI extends Q5{constructor(e,r){super(e,{...r,name:"helia:bitswap:session"});u(this,"wantList");u(this,"network");this.wantList=e.wantList,this.network=e.network}async queryProvider(e,r,s){this.log("sending WANT-BLOCK for %c to %p",e,r);const i=await this.wantList.wantSessionBlock(e,r,s);if(this.log("%p %s %c",r,i.has?"has":"does not have",e),i.has&&i.block!=null)return i.block;throw new Error("Provider did not have block")}async*findNewProviders(e,r={}){for await(const s of this.network.findProviders(e,r))yield s.id}toEvictionKey(e){return e.toMultihash().bytes}equals(e,r){return e.equals(r)}}function cI(n,t){return new aI(n,t)}class lI{constructor(t){u(this,"blocksReceived");u(this,"duplicateBlocksReceived");u(this,"dataReceived");u(this,"duplicateDataReceived");var e,r,s,i;this.blocksReceived=(e=t.metrics)==null?void 0:e.registerMetricGroup("helia_bitswap_received_blocks"),this.duplicateBlocksReceived=(r=t.metrics)==null?void 0:r.registerMetricGroup("helia_bitswap_duplicate_received_blocks"),this.dataReceived=(s=t.metrics)==null?void 0:s.registerMetricGroup("helia_bitswap_data_received_bytes"),this.duplicateDataReceived=(i=t.metrics)==null?void 0:i.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes")}updateBlocksReceived(t=1,e){var s;const r={global:t};e!=null&&(r[e.toString()]=t),(s=this.blocksReceived)==null||s.increment(r)}updateDuplicateBlocksReceived(t=1,e){var s;const r={global:t};e!=null&&(r[e.toString()]=t),(s=this.duplicateBlocksReceived)==null||s.increment(r)}updateDataReceived(t,e){var s;const r={global:t};e!=null&&(r[e.toString()]=t),(s=this.dataReceived)==null||s.increment(r)}updateDuplicateDataReceived(t,e){var s;const r={global:t};e!=null&&(r[e.toString()]=t),(s=this.duplicateDataReceived)==null||s.increment(r)}}class uI extends Map{constructor(e){super();u(this,"metric");const{name:r,metrics:s}=e;this.metric=s.registerMetric(r),this.updateComponentMetric()}set(e,r){return super.set(e,r),this.updateComponentMetric(),this}delete(e){const r=super.delete(e);return this.updateComponentMetric(),r}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Y5(n){const{name:t,metrics:e}=n;let r;return e!=null?r=new uI({name:t,metrics:e}):r=new Map,r}function hI(n){if(!(n instanceof Uint8Array))throw new Error("arg needs to be a Uint8Array");const t=[];for(;n.length>0;){const e=yn(n);t.push(e),n=n.slice($e(e))}return t}class dI extends Et{constructor(e,r={}){super();u(this,"peers");u(this,"wants");u(this,"network");u(this,"log");u(this,"sendMessagesDelay");u(this,"sendMessagesTimeout");u(this,"hashLoader");u(this,"sendingMessages");this.peers=a5({name:"helia_bitswap_peers",metrics:e.metrics}),this.wants=Y5({name:"helia_bitswap_wantlist",metrics:e.metrics}),this.network=e.network,this.sendMessagesDelay=r.sendMessagesDelay??dw,this.log=e.logger.forComponent("helia:bitswap:wantlist"),this.hashLoader=r.hashLoader,this.network.addEventListener("bitswap:message",s=>{this.receiveMessage(s.detail.peer,s.detail.message).catch(i=>{this.log.error("error receiving bitswap message from %p",s.detail.peer,i)})}),this.network.addEventListener("peer:connected",s=>{this.peerConnected(s.detail).catch(i=>{this.log.error("error processing newly connected bitswap peer %p",s.detail,i)})}),this.network.addEventListener("peer:disconnected",s=>{this.peerDisconnected(s.detail)})}async addEntry(e,r){var o;const s=Z(e.multihash.bytes,"base64");let i=this.wants.get(s);i==null&&(i={cid:e,priority:r.priority??1,wantType:r.wantType??_t.WantBlock,cancel:!1,sendDontHave:!0},this.wants.set(s,i)),i.wantType===_t.WantHave&&r.wantType===_t.WantBlock&&(i.wantType=_t.WantBlock),await this.sendMessagesDebounced();try{return r.wantType===_t.WantBlock?(await _r(this,"block",r==null?void 0:r.signal,{filter:l=>_e(e.multihash.digest,l.detail.cid.multihash.digest),errorMessage:"Want was aborted"})).detail:(await _r(this,"presence",r==null?void 0:r.signal,{filter:c=>_e(e.multihash.digest,c.detail.cid.multihash.digest),errorMessage:"Want was aborted"})).detail}finally{((o=r.signal)==null?void 0:o.aborted)===!0&&(this.log("want for %c was aborted, cancelling want",e),i.cancel=!0,await this.sendMessagesDebounced())}}async sendMessagesDebounced(){var e;await((e=this.sendingMessages)==null?void 0:e.promise),clearTimeout(this.sendMessagesTimeout),this.sendMessagesTimeout=setTimeout(()=>{this.sendMessages().catch(r=>{this.log("error sending messages to peers",r)})},this.sendMessagesDelay)}async sendMessages(){this.sendingMessages=me(),await Promise.all([...this.peers.entries()].map(async([e,r])=>{const s=new Set,i=new da;for(const[o,a]of this.wants.entries())r.has(o)||a.cancel||(s.add(o),i.addWantlistEntry(a.cid,{cid:a.cid.bytes,priority:a.priority,wantType:a.wantType,cancel:a.cancel,sendDontHave:a.sendDontHave}));if(i.wantlist.size!==0)try{await this.network.sendMessage(e,i);for(const o of s)r.add(o)}catch(o){this.log.error("error sending full wantlist to new peer",o)}})).catch(e=>{this.log.error("error sending messages",e)});for(const[e,r]of this.wants)if(r.cancel){this.wants.delete(e);for(const s of this.peers.values())s.delete(e)}this.sendingMessages.resolve()}has(e){const r=Z(e.multihash.bytes,"base64");return this.wants.has(r)}async wantSessionPresence(e,r,s={}){const i=new da;return i.addWantlistEntry(e,{cid:e.bytes,sendDontHave:!0,wantType:_t.WantHave,priority:1}),await this.network.sendMessage(r,i),(await _r(this,"presence",s.signal,{filter:a=>r.equals(a.detail.sender)&&_e(e.multihash.digest,a.detail.cid.multihash.digest)})).detail}async wantBlock(e,r={}){return this.addEntry(e,{...r,wantType:_t.WantBlock})}async wantSessionBlock(e,r,s={}){const i=new da;return i.addWantlistEntry(e,{cid:e.bytes,sendDontHave:!0,wantType:_t.WantBlock,priority:1}),await this.network.sendMessage(r,i),(await _r(this,"presence",s.signal,{filter:a=>r.equals(a.detail.sender)&&_e(e.multihash.digest,a.detail.cid.multihash.digest)})).detail}async receivedBlock(e,r){const s=Z(e.multihash.bytes,"base64"),i=this.wants.get(s);i!=null&&(i.cancel=!0,await this.sendMessagesDebounced())}async receiveMessage(e,r){var i;this.log("received message from %p with %d blocks",e,r.blocks.length);let s=!1;for(const o of r.blocks){if(o.prefix==null||o.data==null)continue;const a=hI(o.prefix),c=a[0],l=a[1],h=a[2],d=h===gt.code?gt:await((i=this.hashLoader)==null?void 0:i.getHasher(h));if(d==null){this.log.error("unknown hash algorithm",h);continue}let f=d.digest(o.data);f.then!=null&&(f=await f);const g=te.create(c===0?0:1,l,f);this.log("received block from %p for %c",e,g),this.safeDispatchEvent("block",{detail:{sender:e,cid:g,block:o.data}}),this.safeDispatchEvent("presence",{detail:{sender:e,cid:g,has:!0,block:o.data}});const y=Z(g.multihash.bytes,"base64"),p=this.wants.get(y);p!=null&&(p.cancel=!0,s=!0)}for(const{cid:o,type:a}of r.blockPresences){const c=te.decode(o);this.log("received %s from %p for %c",a,e,c),this.safeDispatchEvent("presence",{detail:{sender:e,cid:c,has:a===hn.HaveBlock}})}s&&await this.sendMessagesDebounced()}async peerConnected(e){const r=new Set,s=new da(!0);for(const[i,o]of this.wants.entries())o.cancel||(r.add(i),s.addWantlistEntry(o.cid,{cid:o.cid.bytes,priority:1,wantType:_t.WantBlock,cancel:!1,sendDontHave:!1}));if(s.wantlist.size===0){this.peers.set(e,r);return}try{await this.network.sendMessage(e,s),this.peers.set(e,r)}catch(i){this.log.error("error sending full wantlist to new peer %p",e,i)}}peerDisconnected(e){this.peers.delete(e)}start(){}stop(){this.peers.clear(),clearTimeout(this.sendMessagesTimeout)}}class fI{constructor(t,e={}){u(this,"log");u(this,"logger");u(this,"stats");u(this,"network");u(this,"blockstore");u(this,"peerWantLists");u(this,"wantList");this.logger=t.logger,this.log=t.logger.forComponent("helia:bitswap"),this.blockstore=t.blockstore,this.stats=new lI(t),this.network=new pv(t,e),this.peerWantLists=new YS({...t,network:this.network},e),this.wantList=new dI({...t,network:this.network},e)}createSession(t={}){return cI({wantList:this.wantList,network:this.network,logger:this.logger},t)}async want(t,e={}){const r=new AbortController,s=Ne([r.signal,e.signal]);r.signal,this.network.findAndConnect(t,{...e,signal:s}).catch(i=>{r.signal.aborted||this.log.error("error during finding and connect for cid %c",t,i)});try{return(await this.wantList.wantBlock(t,{...e,signal:s})).block}finally{r.abort(),s.clear()}}async notify(t,e,r={}){await Promise.all([this.peerWantLists.receivedBlock(t,r),this.wantList.receivedBlock(t,r)])}getWantlist(){return[...this.wantList.wants.values()].filter(t=>!t.cancel).map(t=>({cid:t.cid,priority:t.priority,wantType:t.wantType}))}getPeerWantlist(t){return this.peerWantLists.wantListForPeer(t)}async start(){this.wantList.start(),await this.network.start()}async stop(){this.wantList.stop(),await this.network.stop()}}const gI=(n,t={})=>new fI(n,t);class pI{constructor(t,e={}){u(this,"bitswap");u(this,"started");const{getHasher:r}=t;this.bitswap=gI(t,{hashLoader:{getHasher:async s=>r(s)},...e}),this.started=!1}isStarted(){return this.started}async start(){await this.bitswap.start(),this.started=!0}async stop(){await this.bitswap.stop(),this.started=!1}async announce(t,e,r){await this.bitswap.notify(t,e,r)}async retrieve(t,e={}){return this.bitswap.want(t,e)}createSession(t){const e=this.bitswap.createSession(t);return{announce:async(r,s,i)=>{await this.bitswap.notify(r,s,i)},retrieve:async(r,s)=>e.retrieve(r,s)}}}function mI(n={}){return t=>new pI(t,n)}class yI{constructor(){u(this,"index",0);u(this,"input","")}new(t){return this.index=0,this.input=t,this}readAtomically(t){const e=this.index,r=t();return r===void 0&&(this.index=e),r}parseWith(t){const e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{const e=this.readChar();if(e===t)return e})}readSeparator(t,e,r){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return r()})}readNumber(t,e,r,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const h=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const f=Number.parseInt(d,t);if(!Number.isNaN(f))return f});if(h===void 0)break;if(i*=t,i+=h,i>l||(o+=1,e!==void 0&&o>e))return}if(o!==0)return!r&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const t=new Uint8Array(4);for(let e=0;e<t.length;e++){const r=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(r===void 0)return;t[e]=r}return t})}readIPv6Addr(){const t=e=>{for(let r=0;r<e.length/2;r++){const s=r*2;if(r<e.length-3){const o=this.readSeparator(":",r,()=>this.readIPv4Addr());if(o!==void 0)return e[s]=o[0],e[s+1]=o[1],e[s+2]=o[2],e[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",r,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];e[s]=i>>8,e[s+1]=i&255}return[e.length,!1]};return this.readAtomically(()=>{const e=new Uint8Array(16),[r,s]=t(e);if(r===16)return e;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(r+2),[a]=t(i.subarray(0,o));return e.set(i.subarray(0,a),16-a),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const X5=45,wI=15,Co=new yI;function Z5(n){if(!(n.length>wI))return Co.new(n).parseWith(()=>Co.readIPv4Addr())}function J5(n){if(n.includes("%")&&(n=n.split("%")[0]),!(n.length>X5))return Co.new(n).parseWith(()=>Co.readIPv6Addr())}function Wl(n,t=!1){if(n.includes("%")&&(n=n.split("%")[0]),n.length>X5)return;const e=Co.new(n).parseWith(()=>Co.readIPAddr());if(e)return t&&e.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,e[0],e[1],e[2],e[3]]):e}function Po(n){return!!Z5(n)}function n0(n){return!!J5(n)}function j5(n){return!!Wl(n)}var Ri={},ag;function bI(){return ag||(ag=1,(function(){var n,t,e,r,s,i,o,a;a=function(c){var l,h,d,f;return l=(c&255<<24)>>>24,h=(c&255<<16)>>>16,d=(c&65280)>>>8,f=c&255,[l,h,d,f].join(".")},o=function(c){var l,h,d,f,g,y;for(l=[],d=f=0;f<=3&&c.length!==0;d=++f){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}y=t(c),g=y[0],h=y[1],c=c.substring(h),l.push(g)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},e=function(c){return c.charCodeAt(0)},r=e("0"),i=e("a"),s=e("A"),t=function(c){var l,h,d,f,g;for(f=0,l=10,h="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,h="7")),g=d;d<c.length;){if("0"<=c[d]&&c[d]<=h)f=f*l+(e(c[d])-r)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")f=f*l+(10+e(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")f=f*l+(10+e(c[d])-s)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");d++}if(d===g)throw new Error("empty octet");return[f,d]},n=function(){function c(l,h){var d,f,g;if(typeof l!="string")throw new Error("Missing `net' parameter");if(h||(g=l.split("/",2),l=g[0],h=g[1]),h||(h=32),typeof h=="string"&&h.indexOf(".")>-1){try{this.maskLong=o(h)}catch{throw new Error("Invalid mask: "+h)}for(d=f=32;f>=0;d=--f)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(h||h===0)this.bitmask=parseInt(h,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+h);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var h,d,f;for(f=o(this.first),d=o(this.last),h=0;f<=d;)l(a(f),f,h),h++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Ri.ip2long=o,Ri.long2ip=a,Ri.Netmask=n}).call(Ri)),Ri}var vI=bI();const EI=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],SI=EI.map(n=>new vI.Netmask(n));function s0(n){for(const t of SI)if(t.contains(n))return!0;return!1}function xI(n){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n)}function _I(n){const t=n.split(":");if(t.length<2)return!1;const e=t[t.length-1].padStart(4,"0"),r=t[t.length-2].padStart(4,"0"),s=`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(e.substring(0,2),16)}.${parseInt(e.substring(2),16)}`;return s0(s)}function kI(n){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)}function II(n){const t=n.split(":"),e=t[t.length-1];return s0(e)}function AI(n){return/^::$/.test(n)||/^::1$/.test(n)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n)||/^ff([0-9a-fA-F]{2,2}):/i.test(n)}function Ds(n){return Po(n)?s0(n):xI(n)?_I(n):kI(n)?II(n):n0(n)?AI(n):void 0}const TI=n=>n.toString().split("/").slice(1),fc=n=>({match:t=>t.length<1?!1:n(t[0])?t.slice(1):!1,pattern:"fn"}),Se=n=>({match:t=>fc(e=>e===n).match(t),pattern:n}),Yo=()=>({match:n=>fc(t=>typeof t=="string").match(n),pattern:"{string}"}),Xu=()=>({match:n=>fc(t=>!isNaN(parseInt(t))).match(n),pattern:"{number}"}),ze=()=>({match:n=>{if(n.length<2||n[0]!=="p2p"&&n[0]!=="ipfs")return!1;if(n[1].startsWith("Q")||n[1].startsWith("1"))try{ht.decode(`z${n[1]}`)}catch{return!1}else return!1;return n.slice(2)},pattern:"/p2p/{peerid}"}),Kl=()=>({match:n=>{if(n.length<2||n[0]!=="certhash")return!1;try{Ef.decode(n[1])}catch{return!1}return n.slice(2)},pattern:"/certhash/{certhash}"}),Be=n=>({match:t=>{const e=n.match(t);return e===!1?t:e},pattern:`optional(${n.pattern})`}),qt=(...n)=>({match:t=>{let e;for(const r of n){const s=r.match(t);s!==!1&&(e==null||s.length<e.length)&&(e=s)}return e??!1},pattern:`or(${n.map(t=>t.pattern).join(", ")})`}),xe=(...n)=>({match:t=>{for(const e of n){const r=e.match(t);if(r===!1)return!1;t=r}return t},pattern:`and(${n.map(t=>t.pattern).join(", ")})`});function Qe(...n){function t(s){let i=TI(s);for(const o of n){const a=o.match(i);if(a===!1)return!1;i=a}return i}function e(s){return t(s)!==!1}function r(s){const i=t(s);return i===!1?!1:i.length===0}return{matchers:n,matches:e,exactMatch:r}}const Zu=xe(Se("dns4"),Yo()),Ju=xe(Se("dns6"),Yo()),ju=xe(Se("dnsaddr"),Yo()),i0=xe(Se("dns"),Yo());Qe(Zu,Be(ze()));Qe(Ju,Be(ze()));Qe(ju,Be(ze()));const e8=Qe(qt(i0,ju,Zu,Ju),Be(ze())),t8=xe(Se("ip4"),fc(Po)),r8=xe(Se("ip6"),fc(n0)),o0=qt(t8,r8),Mn=qt(o0,i0,Zu,Ju,ju),CI=Qe(qt(o0,xe(qt(i0,ju,Zu,Ju),Be(ze())))),cg=Qe(t8),lg=Qe(r8),PI=Qe(o0),a0=xe(Mn,Se("tcp"),Xu()),gc=xe(Mn,Se("udp"),Xu()),Gl=Qe(xe(a0,Be(ze())));Qe(gc);const c0=xe(gc,Se("quic"),Be(ze())),eh=xe(gc,Se("quic-v1"),Be(ze())),DI=qt(c0,eh);Qe(c0);const RI=Qe(eh),o1=qt(Mn,a0,gc,c0,eh),n8=qt(xe(o1,Se("ws"),Be(ze()))),za=Qe(n8),s8=qt(xe(o1,Se("wss"),Be(ze())),xe(o1,Se("tls"),Be(xe(Se("sni"),Yo())),Se("ws"),Be(ze()))),Ql=Qe(s8),i8=xe(gc,Se("webrtc-direct"),Be(Kl()),Be(Kl()),Be(ze())),a1=Qe(i8),o8=xe(eh,Se("webtransport"),Be(Kl()),Be(Kl()),Be(ze())),ug=Qe(o8),Yl=qt(n8,s8,xe(a0,Be(ze())),xe(DI,Be(ze())),xe(Mn,Be(ze())),i8,o8,ze()),a8=Qe(Yl),BI=xe(Yl,Se("p2p-circuit"),ze()),_s=Qe(BI),MI=qt(xe(Yl,Se("p2p-circuit"),Se("webrtc"),Be(ze())),xe(Yl,Se("webrtc"),Be(ze())),xe(Se("webrtc"),Be(ze()))),c1=Qe(MI),NI=qt(xe(Mn,Se("tcp"),Xu(),Se("http"),Be(ze())),xe(Mn,Se("http"),Be(ze()))),LI=Qe(NI),OI=qt(xe(Mn,Se("tcp"),qt(xe(Se("443"),Se("http")),xe(Xu(),Se("https"))),Be(ze())),xe(Mn,Se("tls"),Se("http"),Be(ze())),xe(Mn,Se("https"),Be(ze()))),FI=Qe(OI),UI=qt(xe(Se("memory"),Yo(),Be(ze())));Qe(UI);function $I(n,t,e){let r=0;for(const s of n)if(!(r<t)){if(r>e)break;if(s!==255)return!1;r++}return!0}function zI(n,t,e,r){let s=0;for(const i of n)if(!(s<e)){if(s>r)break;if(i!==t[s])return!1;s++}return!0}function VI(n){switch(n.length){case Va:return n.join(".");case Ha:{const t=[];for(let e=0;e<n.length;e++)e%2===0&&t.push(n[e].toString(16).padStart(2,"0")+n[e+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}function HI(n){let t=0;for(let[e,r]of n.entries()){if(r===255){t+=8;continue}for(;(r&128)!=0;)t++,r=r<<1;if((r&128)!=0)return-1;for(let s=e+1;s<n.length;s++)if(n[s]!=0)return-1;break}return t}function qI(n){let t="0x";for(const e of n)t+=(e>>4).toString(16)+(e&15).toString(16);return t}const Va=4,Ha=16,WI=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function c8(n,t){t.length===Ha&&n.length===Va&&$I(t,0,11)&&(t=t.slice(12)),t.length===Va&&n.length===Ha&&zI(n,WI,0,11)&&(n=n.slice(12));const e=n.length;if(e!=t.length)throw new Error("Failed to mask ip");const r=new Uint8Array(e);for(let s=0;s<e;s++)r[s]=n[s]&t[s];return r}function KI(n,t){if(typeof t=="string"&&(t=Wl(t)),t==null)throw new Error("Invalid ip");if(t.length!==n.network.length)return!1;for(let e=0;e<t.length;e++)if((n.network[e]&n.mask[e])!==(t[e]&n.mask[e]))return!1;return!0}function GI(n){const[t,e]=n.split("/");if(!t||!e)throw new Error("Failed to parse given CIDR: "+n);let r=Va,s=Z5(t);if(s==null&&(r=Ha,s=J5(t),s==null))throw new Error("Failed to parse given CIDR: "+n);const i=parseInt(e,10);if(Number.isNaN(i)||String(i).length!==e.length||i<0||i>r*8)throw new Error("Failed to parse given CIDR: "+n);const o=l8(i,8*r);return{network:c8(s,o),mask:o}}function l8(n,t){if(t!==8*Va&&t!==8*Ha)throw new Error("Invalid CIDR mask");if(n<0||n>t)throw new Error("Invalid CIDR mask");const e=t/8,r=new Uint8Array(e);for(let s=0;s<e;s++){if(n>=8){r[s]=255,n-=8;continue}r[s]=255-(255>>n),n=0}return r}class u8{constructor(t,e){if(e==null)({network:this.network,mask:this.mask}=GI(t));else{const r=Wl(t);if(r==null)throw new Error("Failed to parse network");e=String(e);const s=parseInt(e,10);if(Number.isNaN(s)||String(s).length!==e.length||s<0||s>r.length*8){const i=Wl(e);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=l8(s,8*r.length);this.network=c8(r,this.mask)}}contains(t){return KI({network:this.network,mask:this.mask},t)}toString(){const t=HI(this.mask),e=t!==-1?String(t):qI(this.mask);return VI(this.network)+"/"+e}}function QI(n,t){return new u8(n).contains(t)}const hg=Po,YI=n0,h8=function(n){let t=0;if(n=n.toString().trim(),hg(n)){const e=new Uint8Array(t+4);return n.split(/\./g).forEach(r=>{e[t++]=parseInt(r,10)&255}),e}if(YI(n)){const e=n.split(":",8);let r;for(r=0;r<e.length;r++){const i=hg(e[r]);let o;i&&(o=h8(e[r]),e[r]=Z(o.slice(0,2),"base16")),o!=null&&++r<8&&e.splice(r,0,Z(o.slice(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(r=0;r<e.length&&e[r]!=="";r++);const i=[r,1];for(r=9-e.length;r>0;r--)i.push("0");e.splice.apply(e,i)}const s=new Uint8Array(t+16);for(r=0;r<e.length;r++){const i=parseInt(e[r],16);s[t++]=i>>8&255,s[t++]=i&255}return s}throw new Error("invalid ip address")},XI=function(n,t=0,e){t=~~t,e=e??n.length-t;const r=new DataView(n.buffer);if(e===4){const s=[];for(let i=0;i<e;i++)s.push(n[t+i]);return s.join(".")}if(e===16){const s=[];for(let i=0;i<e;i+=2)s.push(r.getUint16(t+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},cr=-1,qa={},l1={},ZI=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,cr,"ip6zone"],[43,8,"ipcidr"],[53,cr,"dns",!0],[54,cr,"dns4",!0],[55,cr,"dns6",!0],[56,cr,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,cr,"unix",!1,!0],[421,cr,"ipfs"],[421,cr,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,cr,"garlic64"],[448,0,"tls"],[449,cr,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,cr,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,cr,"http-path"],[777,cr,"memory"]];ZI.forEach(n=>{const t=JI(...n);l1[t.code]=t,qa[t.name]=t});function JI(n,t,e,r,s){return{code:n,size:t,name:e,resolvable:!!r,path:!!s}}function ge(n){if(typeof n=="number"){if(l1[n]!=null)return l1[n];throw new Error(`no protocol with code: ${n}`)}else if(typeof n=="string"){if(qa[n]!=null)return qa[n];throw new Error(`no protocol with name: ${n}`)}throw new Error(`invalid protocol id type: ${typeof n}`)}const jI=ge("ip4"),eA=ge("ip6"),tA=ge("ipcidr");function l0(n,t){switch(ge(n).code){case 4:case 41:return sA(t);case 42:return qh(t);case 43:return Z(t,"base10");case 6:case 273:case 33:case 132:return d8(t).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return qh(t);case 421:return cA(t);case 444:return gg(t);case 445:return gg(t);case 466:return aA(t);case 481:return globalThis.encodeURIComponent(qh(t));default:return Z(t,"base16")}}function dg(n,t){switch(ge(n).code){case 4:return fg(t);case 41:return fg(t);case 42:return Hh(t);case 43:return Y(t,"base10");case 6:case 273:case 33:case 132:return u0(parseInt(t,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Hh(t);case 421:return iA(t);case 444:return lA(t);case 445:return uA(t);case 466:return oA(t);case 481:return Hh(globalThis.decodeURIComponent(t));default:return Y(t,"base16")}}function rA(n){let t,e;if(n.stringTuples().forEach(([r,s])=>{(r===jI.code||r===eA.code)&&(e=s),r===tA.code&&(t=s)}),t==null||e==null)throw new Error("Invalid multiaddr");return new u8(e,t)}const Vh=Object.values(Cl).map(n=>n.decoder),nA=function(){let n=Vh[0].or(Vh[1]);return Vh.slice(2).forEach(t=>n=n.or(t)),n}();function fg(n){if(!j5(n))throw new Error("invalid ip address");return h8(n)}function sA(n){const t=XI(n,0,n.length);if(t==null)throw new Error("ipBuff is required");if(!j5(t))throw new Error("invalid ip address");return t}function u0(n){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,n),new Uint8Array(t)}function d8(n){return new DataView(n.buffer).getUint16(n.byteOffset)}function Hh(n){const t=Y(n),e=Uint8Array.from(Lt(t.length));return ft([e,t],e.length+t.length)}function qh(n){const t=yn(n);if(n=n.slice($e(t)),n.length!==t)throw new Error("inconsistent lengths");return Z(n)}function iA(n){let t;n[0]==="Q"||n[0]==="1"?t=bt(ht.decode(`z${n}`)).bytes:t=te.parse(n).multihash.bytes;const e=Uint8Array.from(Lt(t.length));return ft([e,t],e.length+t.length)}function oA(n){const t=nA.decode(n),e=Uint8Array.from(Lt(t.length));return ft([e,t],e.length+t.length)}function aA(n){const t=yn(n),e=n.slice($e(t));if(e.length!==t)throw new Error("inconsistent lengths");return"u"+Z(e,"base64url")}function cA(n){const t=yn(n),e=n.slice($e(t));if(e.length!==t)throw new Error("inconsistent lengths");return Z(e,"base58btc")}function lA(n){const t=n.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const e=er.decode("b"+t[0]),r=parseInt(t[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=u0(r);return ft([e,s],e.length+s.length)}function uA(n){const t=n.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const e=er.decode(`b${t[0]}`),r=parseInt(t[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=u0(r);return ft([e,s],e.length+s.length)}function gg(n){const t=n.slice(0,n.length-2),e=n.slice(n.length-2),r=Z(t,"base32"),s=d8(e);return`${r}:${s}`}function hA(n){n=u1(n);const t=[],e=[];let r=null;const s=n.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=s[i],a=ge(o);if(a.size===0){t.push([a.code]),e.push([a.code]);continue}if(i++,i>=s.length)throw new h0("invalid address: "+n);if(a.path===!0){r=u1(s.slice(i).join("/")),t.push([a.code,dg(a.code,r)]),e.push([a.code,r]);break}const c=dg(a.code,s[i]);t.push([a.code,c]),e.push([a.code,l0(a.code,c)])}return{string:f8(e),bytes:g8(t),tuples:t,stringTuples:e,path:r}}function pg(n){const t=[],e=[];let r=null,s=0;for(;s<n.length;){const i=yn(n,s),o=$e(i),a=ge(i),c=dA(a,n.slice(s+o));if(c===0){t.push([i]),e.push([i]),s+=o;continue}const l=n.slice(s+o,s+o+c);if(s+=c+o,s>n.length)throw new h0("Invalid address Uint8Array: "+Z(n,"base16"));t.push([i,l]);const h=l0(i,l);if(e.push([i,h]),a.path===!0){r=h;break}}return{bytes:Uint8Array.from(n),string:f8(e),tuples:t,stringTuples:e,path:r}}function f8(n){const t=[];return n.map(e=>{const r=ge(e[0]);return t.push(r.name),e.length>1&&e[1]!=null&&t.push(e[1]),null}),u1(t.join("/"))}function g8(n){return ft(n.map(t=>{const e=ge(t[0]);let r=Uint8Array.from(Lt(e.code));return t.length>1&&t[1]!=null&&(r=ft([r,t[1]])),r}))}function dA(n,t){if(n.size>0)return n.size/8;if(n.size===0)return 0;{const e=yn(t instanceof Uint8Array?t:Uint8Array.from(t));return e+$e(e)}}function u1(n){return"/"+n.trim().split("/").filter(t=>t).join("/")}class h0 extends Error{constructor(e){super(`Error parsing address: ${e}`);u(this,"name","ParseError")}}u(h0,"name","ParseError");const fA=Symbol.for("nodejs.util.inspect.custom"),p8=Symbol.for("@multiformats/js-multiaddr/multiaddr"),gA=[ge("dns").code,ge("dns4").code,ge("dns6").code,ge("dnsaddr").code];class pA extends Error{constructor(t="No available resolver"){super(t),this.name="NoAvailableResolverError"}}var M3,ho,ss,rc,nc;const Hi=class Hi{constructor(t){u(this,"bytes");ve(this,ho);ve(this,ss);ve(this,rc);ve(this,nc);u(this,M3,!0);t==null&&(t="");let e;if(t instanceof Uint8Array)e=pg(t);else if(typeof t=="string"){if(t.length>0&&t.charAt(0)!=="/")throw new Error(`multiaddr "${t}" must start with a "/"`);e=hA(t)}else if(th(t))e=pg(t.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=e.bytes,He(this,ho,e.string),He(this,ss,e.tuples),He(this,rc,e.stringTuples),He(this,nc,e.path)}toString(){return Q(this,ho)}toJSON(){return this.toString()}toOptions(){let t,e,r,s,i="";const o=ge("tcp"),a=ge("udp"),c=ge("ip4"),l=ge("ip6"),h=ge("dns6"),d=ge("ip6zone");for(const[g,y]of this.stringTuples())g===d.code&&(i=`%${y??""}`),gA.includes(g)&&(e=o.name==="tcp"?"tcp":"udp",s=443,r=`${y??""}${i}`,t=g===h.code?6:4),(g===o.code||g===a.code)&&(e=ge(g).name==="tcp"?"tcp":"udp",s=parseInt(y??"")),(g===c.code||g===l.code)&&(e=ge(g).name==="tcp"?"tcp":"udp",r=`${y??""}${i}`,t=g===l.code?6:4);if(t==null||e==null||r==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:t,host:r,transport:e,port:s}}protos(){return Q(this,ss).map(([t])=>Object.assign({},ge(t)))}protoCodes(){return Q(this,ss).map(([t])=>t)}protoNames(){return Q(this,ss).map(([t])=>ge(t).name)}tuples(){return Q(this,ss).map(([t,e])=>e==null?[t]:[t,e])}stringTuples(){return Q(this,rc).map(([t,e])=>e==null?[t]:[t,e])}encapsulate(t){return t=new Hi(t),new Hi(this.toString()+t.toString())}decapsulate(t){const e=t.toString(),r=this.toString(),s=r.lastIndexOf(e);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${t.toString()}`);return new Hi(r.slice(0,s))}decapsulateCode(t){const e=this.tuples();for(let r=e.length-1;r>=0;r--)if(e[r][0]===t)return new Hi(g8(e.slice(0,r)));return this}getPeerId(){try{let t=[];this.stringTuples().forEach(([r,s])=>{r===qa.p2p.code&&t.push([r,s]),r===qa["p2p-circuit"].code&&(t=[])});const e=t.pop();if((e==null?void 0:e[1])!=null){const r=e[1];return r[0]==="Q"||r[0]==="1"?Z(ht.decode(`z${r}`),"base58btc"):Z(te.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return Q(this,nc)}equals(t){return _e(this.bytes,t.bytes)}async resolve(t){const e=this.protos().find(i=>i.resolvable);if(e==null)return[this];const r=d0.get(e.name);if(r==null)throw new pA(`no available resolver for ${e.name}`);return(await r(this,t)).map(i=>fe(i))}nodeAddress(){const t=this.toOptions();if(t.transport!=="tcp"&&t.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${t.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:t.family,address:t.host,port:t.port}}isThinWaistAddress(t){const e=(t??this).protos();return!(e.length!==2||e[0].code!==4&&e[0].code!==41||e[1].code!==6&&e[1].code!==273)}[(M3=p8,fA)](){return`Multiaddr(${Q(this,ho)})`}};ho=new WeakMap,ss=new WeakMap,rc=new WeakMap,nc=new WeakMap;let h1=Hi;const d0=new Map;function th(n){return!!(n!=null&&n[p8])}function fe(n){return new h1(n)}const mA=[ge("tcp").code,ge("dns").code,ge("dnsaddr").code,ge("dns4").code,ge("dns6").code];function mg(n){var t;return(t=m8("sni",n))==null?void 0:t[1]}function yg(n){var e;const t=(e=m8("tcp",n))==null?void 0:e[1];return t==null?"":`:${t}`}function m8(n,t){let e;try{e=ge(n).code}catch{return}for(const[r,s]of t)if(r===e&&s!=null)return[r,s]}function wg(n){return n.some(([t,e])=>t===ge("tls").code)}function Dr(n,t,e){const r=y8[ge(n).name];if(r==null)throw new Error(`Can't interpret protocol ${ge(n).name}`);const s=r(t,e);return n===ge("ip6").code?`[${s}]`:s}const y8={ip4:(n,t)=>n,ip6:(n,t)=>t.length===0?n:`[${n}]`,tcp:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");return`tcp://${Dr(e[0],e[1]??"",t)}:${n}`},udp:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");return`udp://${Dr(e[0],e[1]??"",t)}:${n}`},dnsaddr:(n,t)=>n,dns4:(n,t)=>n,dns6:(n,t)=>n,dns:(n,t)=>n,ipfs:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");return`${Dr(e[0],e[1]??"",t)}`},p2p:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");return`${Dr(e[0],e[1]??"",t)}`},http:(n,t)=>{const e=wg(t),r=mg(t),s=yg(t);if(e&&r!=null)return`https://${r}${s}`;const i=e?"https://":"http://",o=t.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Dr(o[0],o[1]??"",t);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");const r=Dr(e[0],e[1]??"",t),s=decodeURIComponent(n);return`${r}/${s}`},tls:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");return Dr(e[0],e[1]??"",t)},sni:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");return Dr(e[0],e[1]??"",t)},https:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");let r=Dr(e[0],e[1]??"",t);return r=r.replace("tcp://",""),`https://${r}`},ws:(n,t)=>{const e=wg(t),r=mg(t),s=yg(t);if(e&&r!=null)return`wss://${r}${s}`;const i=e?"wss://":"ws://",o=t.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=Dr(o[0],o[1]??"",t);return a=a.replace("tcp://",""),`${i}${a}`},wss:(n,t)=>{const e=t.pop();if(e==null)throw new Error("Unexpected end of multiaddr");let r=Dr(e[0],e[1]??"",t);return r=r.replace("tcp://",""),`wss://${r}`}};function w8(n,t){const r=fe(n).stringTuples(),s=r.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=ge(s[0]),o=y8[i.name];if(o==null)throw new Error(`No interpreter found for ${i.name}`);let a=o(s[1]??"",r);return mA.includes(s[0])&&(a=a.replace(/^.*:\/\//,""),s[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}var Xs,Zs,fo,go,Js,xu,b8;class yA{constructor(t,{logger:e,transformRequestInit:r}){ve(this,xu);u(this,"url");ve(this,Xs,0);ve(this,Zs,0);ve(this,fo,0);ve(this,go,0);ve(this,Js,new Map);u(this,"log");u(this,"transformRequestInit");this.url=t instanceof URL?t:new URL(t),this.transformRequestInit=r,this.log=e.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`)}async getRawBlock(t,e){const r=new URL(this.url.toString());if(r.pathname=`/ipfs/${t.toString()}`,r.search="?format=raw",(e==null?void 0:e.aborted)===!0)throw new Error(`Signal to fetch raw block for CID ${t} from gateway ${this.url} was aborted prior to fetch`);const s=ie(this,xu,b8).call(this,t),i=new AbortController,o=()=>{i.abort()};e==null||e.addEventListener("abort",o);try{let a=Q(this,Js).get(s);if(a==null){Xr(this,Xs)._++;const c={signal:i.signal,headers:{Accept:"application/vnd.ipld.raw"},cache:"force-cache"},l=this.transformRequestInit!=null?await this.transformRequestInit(c):c;a=fetch(r.toString(),l).then(async h=>{if(this.log("GET %s %d",r,h.status),!h.ok)throw Xr(this,Zs)._++,new Error(`unable to fetch raw block for CID ${t} from gateway ${this.url}`);return Xr(this,go)._++,new Uint8Array(await h.arrayBuffer())}),Q(this,Js).set(s,a)}return await a}catch{throw(e==null?void 0:e.aborted)===!0?new Error(`fetching raw block for CID ${t} from gateway ${this.url} was aborted`):(Xr(this,Zs)._++,new Error(`unable to fetch raw block for CID ${t}`))}finally{e==null||e.removeEventListener("abort",o),Q(this,Js).delete(s)}}reliability(){return Q(this,Xs)===0?1:Q(this,fo)>0?-1/0:Q(this,go)/(Q(this,Xs)+Q(this,Zs)*3)}incrementInvalidBlocks(){Xr(this,fo)._++}getStats(){return{attempts:Q(this,Xs),errors:Q(this,Zs),invalidBlocks:Q(this,fo),successes:Q(this,go),pendingResponses:Q(this,Js).size}}}Xs=new WeakMap,Zs=new WeakMap,fo=new WeakMap,go=new WeakMap,Js=new WeakMap,xu=new WeakSet,b8=function(t){const e=t.multihash.bytes;return kr.encode(e)};function wA(n,t,e){return n.filter(r=>{if(FI.matches(r)||t&&LI.matches(r))return e||e8.matches(r)?!0:Ds(r.toOptions().host)===!1;if(!t&&e){const{host:s}=r.toOptions();if(s==="127.0.0.1"||s==="localhost"||s.endsWith(".localhost"))return!0}return!1})}async function*v8(n,t,e,r,s,i={}){for await(const o of t.findProviders(n,i)){const a=wA(o.multiaddrs,r,s);if(a.length===0)continue;const c=w8(a[0]);yield new yA(c,{logger:e,transformRequestInit:i.transformRequestInit})}}class bA extends Q5{constructor(e,r){super(e,{...r,name:"helia:trustless-gateway:session"});u(this,"routing");u(this,"allowInsecure");u(this,"allowLocal");u(this,"transformRequestInit");this.routing=e.routing,this.allowInsecure=r.allowInsecure??E8,this.allowLocal=r.allowLocal??S8,this.transformRequestInit=r.transformRequestInit}async queryProvider(e,r,s){var o;this.log("fetching BLOCK for %c from %s",e,r.url);const i=await r.getRawBlock(e,s.signal);return this.log.trace("got block for %c from %s",e,r.url),await((o=s.validateFn)==null?void 0:o.call(s,i)),i}async*findNewProviders(e,r={}){yield*v8(e,this.routing,this.logger,this.allowInsecure,this.allowLocal,{...r,transformRequestInit:this.transformRequestInit})}toEvictionKey(e){return e.url.toString()}equals(e,r){return e.url.toString()===r.url.toString()}}function vA(n,t){return new bA(n,t)}class EA{constructor(t,e={}){u(this,"allowInsecure");u(this,"allowLocal");u(this,"transformRequestInit");u(this,"routing");u(this,"log");u(this,"logger");this.log=t.logger.forComponent("helia:trustless-gateway-block-broker"),this.logger=t.logger,this.routing=t.routing,this.allowInsecure=e.allowInsecure??E8,this.allowLocal=e.allowLocal??S8,this.transformRequestInit=e.transformRequestInit}async retrieve(t,e={}){var s,i;const r=[];for await(const o of v8(t,this.routing,this.logger,this.allowInsecure,this.allowLocal,{...e,transformRequestInit:this.transformRequestInit})){this.log("getting block for %c from %s",t,o.url);try{const a=await o.getRawBlock(t,e.signal);this.log.trace("got block for %c from %s",t,o.url);try{await((s=e.validateFn)==null?void 0:s.call(e,a))}catch(c){this.log.error("failed to validate block for %c from %s",t,o.url,c);continue}return a}catch(a){if(this.log.error("failed to get block for %c from %s",t,o.url,a),a instanceof Error?r.push(a):r.push(new Error(`Unable to fetch raw block for CID ${t} from gateway ${o.url}`)),((i=e.signal)==null?void 0:i.aborted)===!0){this.log.trace("request aborted while fetching raw block for CID %c from gateway %s",t,o.url);break}}}throw r.length>0?new AggregateError(r,`Unable to fetch raw block for CID ${t} from any gateway`):new Error(`Unable to fetch raw block for CID ${t} from any gateway`)}createSession(t={}){return vA({logger:this.logger,routing:this.routing},{...t,allowLocal:this.allowLocal,allowInsecure:this.allowInsecure,transformRequestInit:this.transformRequestInit})}}const E8=!1,S8=!1;function SA(n={}){return t=>new EA(t,n)}async function*bg(n,t={}){const e=n.getReader();try{for(;;){const r=await e.read();if(r.done)return;yield r.value}}finally{t.preventCancel!==!0&&await e.cancel(),e.releaseLock()}}var Wh={exports:{}},vg;function xA(){return vg||(vg=1,function(n){(function(){n.exports=w;var t=86400,e=3200,r=146097*e/400,s=t*r,i=1e3*s,o=864e13,a=4294967296,c=1e6,l="000000000",h=Math.trunc||function(k){var N=k-k%1;return N==0&&(k<0||k===0&&1/k!=1/0)?-0:N},d=w.prototype,f=(w.fromDate=function(k){return new w(+k)},w.fromInt64BE=P(0,1,2,3,0,4),w.fromInt64LE=P(3,2,1,0,4,0),w.fromString=function(z){var N,$=new w,z=(z+="").replace(/^\s*[+\-]?\d+/,function(U){var U=+U,L=1970+(U-1970)%400;return $.year=U-L,L}).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/,function(q,U,L){return U<0&&(L*=-1),N=6e4*(60*+U+ +L),""}).replace(/\.\d+$/,function(q){return $.nano=+(q+l).substr(1,9),""}).split(/\D+/);if(1<z.length?z[1]--:z[1]=0,$.time=N=Date.UTC.apply(Date,z)-(N||0),isNaN(N))throw new TypeError("Invalid Date");return v($)},w.fromTimeT=function(k){return S(k,0)},d.year=0,d.time=0,d.nano=0,d.addNano=function(k){return this.nano+=+k||0,this},d.getNano=function(){var k=v(this);return(k.time%1e3*c+ +k.nano+1e9)%1e9},d.getTimeT=function(){var N=v(this),k=Math.floor(N.time/1e3),N=N.year;return N&&(k+=N*r*t/e),k},d.getYear=function(){return this.toDate().getUTCFullYear()+this.year},d.toDate=function(){return x(v(this).time)},d.toJSON=function(){return this.toString().replace(/0{1,6}Z$/,"Z")},d.toString=function(k){var N=this,$=N.toDate(),z={H:function(){return C($.getUTCHours())},L:function(){return T($.getUTCMilliseconds(),3)},M:function(){return C($.getUTCMinutes())},N:function(){return T(N.getNano(),9)},S:function(){return C($.getUTCSeconds())},Y:function(){var q=N.getYear();return 999999<q?"+"+q:9999<q?"+"+T(q,6):0<=q?T(q,4):-999999<=q?"-"+T(-q,6):q},a:function(){return y[$.getUTCDay()]},b:function(){return g[$.getUTCMonth()]},d:function(){return C($.getUTCDate())},e:function(){return function(q){return(9<q?"":" ")+(0|q)}($.getUTCDate())},m:function(){return C($.getUTCMonth()+1)}};return function q(U){return U.replace(/%./g,function(L){var R=L[1],M=p[R],R=z[R];return M?q(M):R?R():L})}(k||f)},d.writeInt64BE=I(0,1,2,3,0,4),d.writeInt64LE=I(3,2,1,0,4,0),"%Y-%m-%dT%H:%M:%S.%NZ"),g=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],y=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],p={"%":"%",F:"%Y-%m-%d",n:`
`,R:"%H:%M",T:"%H:%M:%S",t:"	",X:"%T",Z:"GMT",z:"+0000"};return w;function w(k,N,$){var z=this;if(!(z instanceof w))return new w(k,N,$);z.time=+k||0,z.nano=+N||0,z.year=+$||0,v(z)}function v(k){var N,$,z,q=k.year,U=k.time,L=k.nano,M=((L<0||c<=L)&&(L-=($=Math.floor(L/c))*c,U+=$,$=1),q%e);return(U<-864e13||o<U||M)&&((N=h(U/i))&&(q+=N*e,U-=N*i),(z=x(U)).setUTCFullYear(M+z.getUTCFullYear()),z=(U=+z)+(N=h((q-=M)/e))*i,N&&-864e13<=z&&z<=o&&(q-=N*e,U=z),$=1),$&&(k.year=q,k.time=U,k.nano=L),k}function x(k){var N=new Date(0);return N.setTime(k),N}function S(q,z){q=+q||0;var $=h((z=(z|0)*a)/s)+h(q/s),z=z%s+q%s,q=h(z/s);return q&&($+=q,z-=q*s),new w(1e3*z,0,$*e)}function I(k,N,$,z,q,U){return function(M,R){var F=v(this);M=M||new Array(8),A(M,R|=0);var K=Math.floor(F.time/1e3),F=F.year*(r*t/e),V=h(F/a)+h(K/a),F=F%a+K%a,K=Math.floor(F/a);return K&&(V+=K,F-=K*a),L(M,R+q,V),L(M,R+U,F),M};function L(M,R,V){M[R+k]=V>>24&255,M[R+N]=V>>16&255,M[R+$]=V>>8&255,M[R+z]=255&V}}function P(k,N,$,z,q,U){return function(M,R){A(M,R|=0);var V=L(M,R+q);return S(L(M,R+U),V)};function L(M,R){return 16777216*M[R+k]+(M[R+N]<<16|M[R+$]<<8|M[R+z])}}function A(k,N){if(k=k&&k.length,k==null)throw new TypeError("Invalid Buffer");if(k<N+8)throw new RangeError("Out of range")}function C(k){return(9<k?"":"0")+(0|k)}function T(k,N){return(l+(0|k)).substr(-N)}})()}(Wh)),Wh.exports}var _A=xA();const d1=Fn(_A);class rs extends Error{constructor(t="Record signature verification failed"){super(t),this.name="SignatureVerificationError"}}u(rs,"name","SignatureVerificationError");class x8 extends Error{constructor(t="Record has expired"){super(t),this.name="RecordExpiredError"}}u(x8,"name","RecordExpiredError");class f0 extends Error{constructor(t="The validity type is unsupported"){super(t),this.name="UnsupportedValidityError"}}u(f0,"name","UnsupportedValidityError");class _8 extends Error{constructor(t="The record is too large"){super(t),this.name="RecordTooLargeError"}}u(_8,"name","RecordTooLargeError");class k8 extends Error{constructor(t="Value must be a valid content path starting with /"){super(t),this.name="InvalidValueError"}}u(k8,"name","InvalidValueError");class I8 extends Error{constructor(t="Invalid record data"){super(t),this.name="InvalidRecordDataError"}}u(I8,"name","InvalidRecordDataError");class f1 extends Error{constructor(t="Invalid embedded public key"){super(t),this.name="InvalidEmbeddedPublicKeyError"}}u(f1,"name","InvalidEmbeddedPublicKeyError");var zr;(function(n){(function(r){r.EOL="EOL"})(n.ValidityType||(n.ValidityType={}));let t;(function(r){r[r.EOL=0]="EOL"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.ValidityType||(n.ValidityType={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.value!=null&&(s.uint32(10),s.bytes(r.value)),r.signatureV1!=null&&(s.uint32(18),s.bytes(r.signatureV1)),r.validityType!=null&&(s.uint32(24),n.ValidityType.codec().encode(r.validityType,s)),r.validity!=null&&(s.uint32(34),s.bytes(r.validity)),r.sequence!=null&&(s.uint32(40),s.uint64(r.sequence)),r.ttl!=null&&(s.uint32(48),s.uint64(r.ttl)),r.pubKey!=null&&(s.uint32(58),s.bytes(r.pubKey)),r.signatureV2!=null&&(s.uint32(66),s.bytes(r.signatureV2)),r.data!=null&&(s.uint32(74),s.bytes(r.data)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.value=r.bytes();break}case 2:{o.signatureV1=r.bytes();break}case 3:{o.validityType=n.ValidityType.codec().decode(r);break}case 4:{o.validity=r.bytes();break}case 5:{o.sequence=r.uint64();break}case 6:{o.ttl=r.uint64();break}case 7:{o.pubKey=r.bytes();break}case 8:{o.signatureV2=r.bytes();break}case 9:{o.data=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),e),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>ue(r,n.codec(),s)})(zr||(zr={}));const kA=Ot("ipns:utils"),A8=Y("/ipns/"),IA=0,AA=18;function TA(n){let t;if(n.pubKey!=null)try{t=ir(n.pubKey)}catch(e){throw kA.error(e),e}if(t!=null)return t}function CA(n){const t=Y("ipns-signature:");return ft([t,n])}function T8(n){return"signatureV1"in n?zr.encode({value:Y(n.value),signatureV1:n.signatureV1,validityType:n.validityType,validity:Y(n.validity),sequence:n.sequence,ttl:n.ttl,pubKey:n.pubKey,signatureV2:n.signatureV2,data:n.data}):zr.encode({pubKey:n.pubKey,signatureV2:n.signatureV2,data:n.data})}function pc(n){const t=zr.decode(n);if(t.sequence!=null&&(t.sequence=BigInt(t.sequence)),t.ttl!=null&&(t.ttl=BigInt(t.ttl)),t.signatureV2==null||t.data==null)throw new rs("Missing data or signatureV2");const e=P8(t.data),r=PA(e.Value),s=Z(e.Validity);if(t.value!=null&&t.signatureV1!=null)return DA(t),{value:r,validityType:zr.ValidityType.EOL,validity:s,sequence:e.Sequence,ttl:e.TTL,pubKey:t.pubKey,signatureV1:t.signatureV1,signatureV2:t.signatureV2,data:t.data};if(t.signatureV2!=null)return{value:r,validityType:zr.ValidityType.EOL,validity:s,sequence:e.Sequence,ttl:e.TTL,pubKey:t.pubKey,signatureV2:t.signatureV2,data:t.data};throw new Error("invalid record: does not include signatureV1 or signatureV2")}function C8(n){return ft([A8,n.bytes])}function g1(n){const t=bt(n.slice(A8.length));if(!p1(t,IA)&&!p1(t,AA))throw new Cu("Multihash in IPNS key was not identity or sha2-256");return t}function P8(n){const t=es(n);if(t.ValidityType===0)t.ValidityType=zr.ValidityType.EOL;else throw new f0("The validity type is unsupported");return Number.isInteger(t.Sequence)&&(t.Sequence=BigInt(t.Sequence)),Number.isInteger(t.TTL)&&(t.TTL=BigInt(t.TTL)),t}function PA(n){const t=Z(n).trim();if(t.startsWith("/"))return t;try{return`/ipfs/${te.decode(n).toV1().toString()}`}catch{}try{return`/ipfs/${te.parse(t).toV1().toString()}`}catch{}throw new k8("Value must be a valid content path starting with /")}function DA(n){if(n.data==null)throw new I8("Record data is missing");const t=P8(n.data);if(!_e(t.Value,n.value??new Uint8Array(0)))throw new rs('Field "value" did not match between protobuf and CBOR');if(!_e(t.Validity,n.validity??new Uint8Array(0)))throw new rs('Field "validity" did not match between protobuf and CBOR');if(t.ValidityType!==n.validityType)throw new rs('Field "validityType" did not match between protobuf and CBOR');if(t.Sequence!==n.sequence)throw new rs('Field "sequence" did not match between protobuf and CBOR');if(t.TTL!==n.ttl)throw new rs('Field "ttl" did not match between protobuf and CBOR')}function p1(n,t){return n.code===t}const Uc=Ot("ipns:validator"),RA=1024*10,BA=async(n,t)=>{const e=pc(t);let r;try{const s=CA(e.data);r=await n.verify(s,e.signatureV2)}catch{r=!1}if(!r)throw Uc.error("record signature verification failed"),new rs("Record signature verification failed");if(e.validityType===zr.ValidityType.EOL){if(d1.fromString(e.validity).toDate().getTime()<Date.now())throw Uc.error("record has expired"),new x8("record has expired")}else if(e.validityType!=null)throw Uc.error("the validity type is unsupported"),new f0("The validity type is unsupported");Uc("ipns record for %s is valid",e.value)};async function D8(n,t){if(t.byteLength>RA)throw new _8("The record is too large");const e=g1(n);let r;p1(e,0)&&(r=Q6(e));const s=pc(t),i=TA(s)??r;if(i==null)throw new f1("Could not extract public key from IPNS record or routing key");const o=C8(i.toMultihash());if(!_e(o,n))throw new f1("Embedded public key did not match routing key");await BA(i,t)}let MA=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidMessageLengthError");u(this,"code","ERR_INVALID_MESSAGE_LENGTH")}};async function*Eg(n,t={}){const e=/\r?\n/,r=new TextDecoder("utf8");let s="";for await(let i of n){if(typeof i=="string"&&(i=new TextEncoder().encode(i)),ua(i)&&(i=i.subarray()),s+=r.decode(i,{stream:!0}),s.length>((t==null?void 0:t.maxMessageLength)??s.length))throw new MA("Incoming message too long");const o=s.split(e);s=o.pop()??"";for(let a=0;a<o.length;a++)yield JSON.parse(o[a])}s+=r.decode(),s!==""&&(yield JSON.parse(s))}class ll extends Error{constructor(t="Invalid request"){super(t),this.name="InvalidRequestError"}}u(ll,"name","InvalidRequestError");class _n extends Error{constructor(t="Bad response"){super(t),this.name="BadResponseError"}}u(_n,"name","BadResponseError");function NA(n){return n[Symbol.asyncIterator]!=null}function g0(n){if(NA(n))return(async()=>{for await(const t of n)return t})();for(const t of n)return t}const Sg=Y("/ipns/");function xg(n){return _e(n.subarray(0,Sg.byteLength),Sg)}class LA{constructor(t){u(this,"client");this.client=t}async*findProviders(t,e={}){yield*Un(this.client.getProviders(t,e),r=>({id:r.ID,multiaddrs:r.Addrs??[]}))}async provide(){}async cancelReprovide(){}async put(t,e,r){if(!xg(t))return;const s=g1(t),i=te.createV1(114,s),o=pc(e);await this.client.putIPNS(i,o,r)}async get(t,e){if(!xg(t))throw new Nt("Not found");const r=g1(t),s=te.createV1(114,r);try{const i=await this.client.getIPNS(s,e);return T8(i)}catch(i){throw i.name==="BadResponseError"?new Nt("Not found"):i}}}class OA{constructor(t){u(this,"client");this.client=t}async findPeer(t,e={}){const r=await g0(this.client.getPeers(t,e));if(r!=null)return{id:r.ID,multiaddrs:r.Addrs??[]};throw new Nt("Not found")}async*getClosestPeers(t,e={}){}}const St=Ot("delegated-routing-v1-http-api-client"),$c={concurrentRequests:4,timeout:3e4,cacheTTL:5*60*1e3,cacheName:"delegated-routing-v1-cache"};var Vt,ga,m1,pa;class FA{constructor(t,e={}){ve(this,Vt);u(this,"started");u(this,"httpQueue");u(this,"shutDownController");u(this,"clientUrl");u(this,"timeout");u(this,"contentRouting");u(this,"peerRouting");u(this,"filterAddrs");u(this,"filterProtocols");u(this,"inFlightRequests");u(this,"cacheName");u(this,"cache");u(this,"cacheTTL");this.started=!1,this.shutDownController=new AbortController,this.shutDownController.signal,this.httpQueue=new Fa({concurrency:e.concurrentRequests??$c.concurrentRequests}),this.inFlightRequests=new Map,this.clientUrl=t instanceof URL?t:new URL(t),this.timeout=e.timeout??$c.timeout,this.filterAddrs=e.filterAddrs,this.filterProtocols=e.filterProtocols,this.contentRouting=new LA(this),this.peerRouting=new OA(this),this.cacheName=e.cacheName??$c.cacheName,this.cacheTTL=e.cacheTTL??$c.cacheTTL}get[yo](){return this.contentRouting}get[wo](){return this.peerRouting}isStarted(){return this.started}async start(){var t;this.started||(this.started=!0,this.cacheTTL>0&&(this.cache=await((t=globalThis.caches)==null?void 0:t.open(this.cacheName)),this.cache!=null&&St("cache enabled with ttl %d",this.cacheTTL)))}async stop(){var t;this.httpQueue.clear(),this.shutDownController.abort(),await((t=globalThis.caches)==null?void 0:t.delete(this.cacheName)),this.started=!1}async*getProviders(t,e={}){St("getProviders starts: %c",t);const r=AbortSignal.timeout(this.timeout),s=Ne([this.shutDownController.signal,r,e.signal]),i=me(),o=me();this.httpQueue.add(async()=>(i.resolve(),o.promise));try{await i.promise;const a=new URL(`${this.clientUrl}routing/v1/providers/${t.toString()}`);ie(this,Vt,m1).call(this,a,e.filterAddrs,e.filterProtocols);const c={headers:{Accept:"application/x-ndjson"},signal:s},l=await ie(this,Vt,pa).call(this,a.toString(),c);if(l==null)throw new _n("No response received");if(!l.ok)throw l.status===404?new Nt("No matching records found"):l.status===422?new ll("Request does not conform to schema or semantic constraints"):new _n(`Unexpected status code: ${l.status}`);if(l.body==null)throw new _n("Routing response had no body");const h=l.headers.get("Content-Type");if(h==null)throw new _n("No Content-Type header received");if(h!=null&&h.startsWith("application/json")){const d=await l.json();for(const f of d.Providers){const g=ie(this,Vt,ga).call(this,f);g!=null&&(yield g)}}else if(h.includes("application/x-ndjson"))for await(const d of Eg(bg(l.body))){const f=ie(this,Vt,ga).call(this,d);f!=null&&(yield f)}else throw new _n(`Unsupported Content-Type: ${h}`)}catch(a){St.error("getProviders errored:",a)}finally{s.clear(),o.resolve(),St("getProviders finished: %c",t)}}async*getPeers(t,e={}){St("getPeers starts: %c",t);const r=AbortSignal.timeout(this.timeout),s=Ne([this.shutDownController.signal,r,e.signal]),i=me(),o=me();this.httpQueue.add(async()=>(i.resolve(),o.promise));try{await i.promise;const a=new URL(`${this.clientUrl}routing/v1/peers/${t.toCID().toString()}`);ie(this,Vt,m1).call(this,a,e.filterAddrs,e.filterProtocols);const c={headers:{Accept:"application/x-ndjson"},signal:s},l=await ie(this,Vt,pa).call(this,a.toString(),c);if(l.status===404)throw new Nt("No matching records found");if(l.status===422)throw new ll("Request does not conform to schema or semantic constraints");if(l.body==null)throw new _n("Routing response had no body");if(l.headers.get("Content-Type")==="application/json"){const d=await l.json();for(const f of d.Peers){const g=ie(this,Vt,ga).call(this,f);g!=null&&(yield g)}}else for await(const d of Eg(bg(l.body))){const f=ie(this,Vt,ga).call(this,d);f!=null&&(yield f)}}catch(a){St.error("getPeers errored:",a)}finally{s.clear(),o.resolve(),St("getPeers finished: %c",t)}}async getIPNS(t,e={}){St("getIPNS starts: %s",t);const r=AbortSignal.timeout(this.timeout),s=Ne([this.shutDownController.signal,r,e.signal]),i=me(),o=me();this.httpQueue.add(async()=>(i.resolve(),o.promise));const a=`${this.clientUrl}routing/v1/ipns/${t}`;try{await i.promise;const c={headers:{Accept:"application/vnd.ipfs.ipns-record"},signal:s},l=await ie(this,Vt,pa).call(this,a,c);if(St("getIPNS GET %s %d",a,l.status),l.status===404)throw new Nt("No matching records found");if(l.status===422)throw new ll("Request does not conform to schema or semantic constraints");if(l.body==null)throw new _n("GET ipns response had no body");const h=await l.arrayBuffer(),d=new Uint8Array(h,0,h.byteLength);return e.validate!==!1&&await D8(C8(t.multihash),d),pc(d)}catch(c){throw St.error("getIPNS GET %s error:",a,c),c}finally{s.clear(),o.resolve(),St("getIPNS finished: %s",t)}}async putIPNS(t,e,r={}){St("putIPNS starts: %c",t);const s=AbortSignal.timeout(this.timeout),i=Ne([this.shutDownController.signal,s,r.signal]),o=me(),a=me();this.httpQueue.add(async()=>(o.resolve(),a.promise));const c=`${this.clientUrl}routing/v1/ipns/${t}`;try{await o.promise;const l=T8(e),h={method:"PUT",headers:{"Content-Type":"application/vnd.ipfs.ipns-record"},body:l,signal:i},d=await ie(this,Vt,pa).call(this,c,h);if(St("putIPNS PUT %s %d",c,d.status),d.status!==200)throw new _n("PUT ipns response had status other than 200")}catch(l){throw St.error("putIPNS PUT %s error:",c,l.stack),l}finally{i.clear(),a.resolve(),St("putIPNS finished: %c",t)}}}Vt=new WeakSet,ga=function(t){var e;try{const r=[],s=((e=t.Addrs)==null?void 0:e.map(fe))??[];return t.Protocols!=null&&r.push(...t.Protocols),t.Protocol!=null&&(r.push(t.Protocol),delete t.Protocol),{...t,Schema:"peer",ID:ut(t.ID),Addrs:s,Protocols:r}}catch(r){St.error("could not conform record to peer schema",r)}},m1=function(t,e,r){var s,i;if(e!=null||this.filterAddrs!=null){const o=(e==null?void 0:e.join(","))??((s=this.filterAddrs)==null?void 0:s.join(","))??"";o!==""&&t.searchParams.set("filter-addrs",o)}if(r!=null||this.filterProtocols!=null){const o=(r==null?void 0:r.join(","))??((i=this.filterProtocols)==null?void 0:i.join(","))??"";o!==""&&t.searchParams.set("filter-protocols",o)}},pa=async function(t,e){var c,l;const r=e.method??"GET",s=`${r}-${t}`;if(r==="GET"){const h=await((c=this.cache)==null?void 0:c.match(t));if(h!=null){if(parseInt(h.headers.get("x-cache-expires")??"0",10)>Date.now())return St("returning cached response for %s",s),h;await((l=this.cache)==null?void 0:l.delete(t))}}const i=this.inFlightRequests.get(s);if(i!=null){const h=await i;return St("deduplicating outgoing request for %s",s),h.clone()}const o=fetch(t,e).then(async h=>{if(this.cache!=null&&h.ok&&r==="GET"){const d=Date.now()+this.cacheTTL,f=new Headers(h.headers);f.set("x-cache-expires",d.toString());const g=new Response(h.clone().body,{status:h.status,statusText:h.statusText,headers:f});await this.cache.put(t,g)}return h}).finally(()=>{this.inFlightRequests.delete(s)});return this.inFlightRequests.set(s,o),await o};function UA(n,t={}){return new FA(new URL(n),t)}function $A(){return{filterProtocols:["unknown","transport-bitswap","transport-ipfs-gateway-http"],filterAddrs:["https","webtransport","webrtc","webrtc-direct","wss","tls"]}}const _g="[a-fA-F\\d:]",os=n=>n&&n.includeBoundaries?`(?:(?<=\\s|^)(?=${_g})|(?<=${_g})(?=\\s|$))`:"",Nr="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",wt="[a-fA-F\\d]{1,4}",rh=`
(?:
(?:${wt}:){7}(?:${wt}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${wt}:){6}(?:${Nr}|:${wt}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${wt}:){5}(?::${Nr}|(?::${wt}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${wt}:){4}(?:(?::${wt}){0,1}:${Nr}|(?::${wt}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${wt}:){3}(?:(?::${wt}){0,2}:${Nr}|(?::${wt}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${wt}:){2}(?:(?::${wt}){0,3}:${Nr}|(?::${wt}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${wt}:){1}(?:(?::${wt}){0,4}:${Nr}|(?::${wt}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${wt}){0,5}:${Nr}|(?::${wt}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),zA=new RegExp(`(?:^${Nr}$)|(?:^${rh}$)`),VA=new RegExp(`^${Nr}$`),HA=new RegExp(`^${rh}$`),nh=n=>n&&n.exact?zA:new RegExp(`(?:${os(n)}${Nr}${os(n)})|(?:${os(n)}${rh}${os(n)})`,"g");nh.v4=n=>n&&n.exact?VA:new RegExp(`${os(n)}${Nr}${os(n)}`,"g");nh.v6=n=>n&&n.exact?HA:new RegExp(`${os(n)}${rh}${os(n)}`,"g");function qA(n){const t=(...e)=>n(...e);return Object.defineProperty(t,"name",{value:`functionTimeout(${n.name||"<anonymous>"})`,configurable:!0}),t}const{toString:WA}=Object.prototype;function KA(n){return WA.call(n)==="[object RegExp]"}const kg={global:"g",ignoreCase:"i",multiline:"m",dotAll:"s",sticky:"y",unicode:"u"};function GA(n,t={}){if(!KA(n))throw new TypeError("Expected a RegExp instance");const e=Object.keys(kg).map(s=>(typeof t[s]=="boolean"?t[s]:n[s])?kg[s]:"").join(""),r=new RegExp(t.source||n.source,e);return r.lastIndex=typeof t.lastIndex=="number"?t.lastIndex:n.lastIndex,r}function R8(n,t,{timeout:e}={}){try{return qA(()=>GA(n).test(t),{timeout:e})()}catch(r){throw r}}const QA=15,YA=45,B8={timeout:400};function Ig(n){return n.length>YA?!1:R8(nh.v6({exact:!0}),n,B8)}function XA(n){return n.length>QA?!1:R8(nh.v4({exact:!0}),n,B8)}const Ag={http:"80",https:"443",ws:"80",wss:"443"},ZA=["http","https","ws","wss"];function JA(n,t){t=t??{};const e=t.defaultDnsType??"dns4",{scheme:r,hostname:s,port:i}=jA(n),a="/"+[eT(s,e),tT(i,r),rT(r)].filter(c=>!!c).reduce((c,l)=>c.concat(l),[]).join("/");return fe(a)}function jA(n){const[t]=n.split(":");ZA.includes(t)||(n="http"+n.substring(t.length));let{protocol:e,hostname:r,port:s}=new URL(n);if(s==null||s===""){const i=nT(t);i!=null&&(s=i),i==null&&e==="http:"&&(s="80")}return{scheme:t,hostname:r,port:s}}function eT(n,t){if(!(n==null||n==="")){if(XA(n))return["ip4",n];if(Ig(n))return["ip6",n];if(n[0]==="["){const e=n.substring(1,n.length-1);if(Ig(e))return["ip6",e]}return[t,n]}}function tT(n,t){if(!(n==null||n===""))return t==="udp"?["udp",n]:["tcp",n]}function rT(n){if(n.match(/^tcp$|^udp$/)==null)return[n]}function nT(n){if(!(n==null||n===""||Ag[n]==null))return Ag[n]}const sT=["https://trustless-gateway.link","https://4everland.io"],iT=2336;function oT(n){return n=n.toString(),{id:qo(te.createV1(iT,bs.digest(Y(n)))),multiaddrs:[JA(n)]}}class aT{constructor(t={}){u(this,"gateways");this.gateways=(t.gateways??sT).map(e=>oT(e))}async*findProviders(t,e){yield*this.gateways.toSorted(()=>Math.random()>.5?1:-1).map(r=>({...r,protocols:["transport-ipfs-gateway-http"]}))}}function cT(n={}){return new aT(n)}class lT{constructor(t){u(this,"libp2p");this.libp2p=t}async provide(t,e){await this.libp2p.contentRouting.provide(t,e)}async cancelReprovide(t,e){await this.libp2p.contentRouting.cancelReprovide(t,e)}async*findProviders(t,e){yield*this.libp2p.contentRouting.findProviders(t,e)}async put(t,e,r){await this.libp2p.contentRouting.put(t,e,r)}async get(t,e){return this.libp2p.contentRouting.get(t,e)}async findPeer(t,e){return this.libp2p.peerRouting.findPeer(t,e)}async*getClosestPeers(t,e){yield*this.libp2p.peerRouting.getClosestPeers(t,e)}}function uT(n){return new lT(n)}class M8 extends K5{constructor(){super();u(this,"data");this.data=new Map}put(e,r){return this.data.set(er.encode(e.multihash.bytes),r),e}get(e){const r=this.data.get(er.encode(e.multihash.bytes));if(r==null)throw new r0;return r}has(e){return this.data.has(er.encode(e.multihash.bytes))}async delete(e){this.data.delete(er.encode(e.multihash.bytes))}async*getAll(){for(const[e,r]of this.data.entries())yield{cid:te.createV1(qr,bt(er.decode(e))),block:r}}}Ot("blockstore:core:tiered");const hT="SHARDING";function dT(n){return n[Symbol.asyncIterator]!=null}function Wa(n){if(dT(n))return(async()=>{const e=[];for await(const r of n)e.push(r);return e})();const t=[];for(const e of n)t.push(e);return t}function fT(n){return n[Symbol.asyncIterator]!=null}function Tg(n,t){return fT(n)?async function*(){yield*(await Wa(n)).sort(t)}():function*(){yield*Wa(n).sort(t)}()}class gT{put(t,e,r){return Promise.reject(new Error(".put is not implemented"))}get(t,e){return Promise.reject(new Error(".get is not implemented"))}has(t,e){return Promise.reject(new Error(".has is not implemented"))}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(t,e={}){for await(const{key:r,value:s}of t)await this.put(r,s,e),yield r}async*getMany(t,e={}){for await(const r of t)yield{key:r,value:await this.get(r,e)}}async*deleteMany(t,e={}){for await(const r of t)await this.delete(r,e),yield r}batch(){let t=[],e=[];return{put(r,s){t.push({key:r,value:s})},delete(r){e.push(r)},commit:async r=>{await ws(this.putMany(t,r)),t=[],await ws(this.deleteMany(e,r)),e=[]}}}async*_all(t,e){throw new Error("._all is not implemented")}async*_allKeys(t,e){throw new Error("._allKeys is not implemented")}query(t,e){let r=this._all(t,e);if(t.prefix!=null){const s=t.prefix;r=Jn(r,i=>i.key.toString().startsWith(s))}if(Array.isArray(t.filters)&&(r=t.filters.reduce((s,i)=>Jn(s,i),r)),Array.isArray(t.orders)&&(r=t.orders.reduce((s,i)=>Tg(s,i),r)),t.offset!=null){let s=0;const i=t.offset;r=Jn(r,()=>s++>=i)}return t.limit!=null&&(r=kl(r,t.limit)),r}queryKeys(t,e){let r=this._allKeys(t,e);if(t.prefix!=null){const s=t.prefix;r=Jn(r,i=>i.toString().startsWith(s))}if(Array.isArray(t.filters)&&(r=t.filters.reduce((s,i)=>Jn(s,i),r)),Array.isArray(t.orders)&&(r=t.orders.reduce((s,i)=>Tg(s,i),r)),t.offset!=null){const s=t.offset;let i=0;r=Jn(r,()=>i++>=s)}return t.limit!=null&&(r=kl(r,t.limit)),r}}class p0 extends gT{constructor(){super();u(this,"data");this.data=new Map}put(e,r){return this.data.set(e.toString(),r),e}get(e){const r=this.data.get(e.toString());if(r==null)throw new r0;return r}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,r]of this.data.entries())yield{key:new Ge(e),value:r}}*_allKeys(){for(const e of this.data.keys())yield new Ge(e)}}new Ge(hT);Ot("datastore:core:tiered");class pT extends oI{constructor(e){super({...e,components:{libp2p:e.libp2p}});u(this,"libp2p");this.libp2p=e.libp2p}async start(){await super.start(),await this.libp2p.start()}async stop(){await super.stop(),await this.libp2p.stop()}}class mT{constructor(){u(this,"readNext");u(this,"haveNext");u(this,"ended");u(this,"nextResult");this.ended=!1,this.readNext=me(),this.haveNext=me()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=me(),t}async throw(t){return this.ended=!0,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){const t={done:!0,value:void 0};return this.ended=!0,this.nextResult=t,this.haveNext.resolve(),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=me(),await fr(this.readNext.promise,e==null?void 0:e.signal,e)}}function yT(){return new mT}let wT=class extends Error{constructor(){super(...arguments);u(this,"name","UnexpectedEOFError");u(this,"code","ERR_UNEXPECTED_EOF")}};class bT extends Error{constructor(e,r){super(e);u(this,"code");this.code=r}}let vT=class extends bT{constructor(e){super(e,"ABORT_ERR");u(this,"type");this.type="aborted",this.name="AbortError"}};function Xl(n,t){const e=yT();n.sink(e).catch(async o=>{await e.end(o)}),n.sink=async o=>{for await(const a of o)await e.push(a);await e.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new ye;return{read:async(o,a)=>{var h,d;(h=a==null?void 0:a.signal)==null||h.throwIfAborted();let c;const l=new Promise((f,g)=>{var y;c=()=>{g(new vT("Read aborted"))},(y=a==null?void 0:a.signal)==null||y.addEventListener("abort",c)});try{if(o==null){const{done:g,value:y}=await Promise.race([r.next(),l]);return g===!0?new ye:y}for(;s.byteLength<o;){const{value:g,done:y}=await Promise.race([r.next(),l]);if(y===!0)throw new wT("unexpected end of input");s.append(g)}const f=s.sublist(0,o);return s.consume(o),f}finally{c!=null&&((d=a==null?void 0:a.signal)==null||d.removeEventListener("abort",c))}},write:async(o,a)=>{var c;(c=a==null?void 0:a.signal)==null||c.throwIfAborted(),o instanceof Uint8Array?await e.push(o,a):await e.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){(t==null?void 0:t.yieldBytes)===!1?yield s:yield*s,yield*o}()}return n}}}let ET=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidMessageLengthError");u(this,"code","ERR_INVALID_MSG_LENGTH")}},ST=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthError");u(this,"code","ERR_MSG_DATA_TOO_LONG")}},xT=class extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthLengthError");u(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function Do(n,t={}){const e=Xl(n,t);t.maxDataLength!=null&&t.maxLengthLength==null&&(t.maxLengthLength=$e(t.maxDataLength));const r=(t==null?void 0:t.lengthDecoder)??yn,s=(t==null?void 0:t.lengthEncoder)??Lt;return{read:async o=>{let a=-1;const c=new ye;for(;;){c.append(await e.read(1,o));try{a=r(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new ET("Invalid message length");if((t==null?void 0:t.maxLengthLength)!=null&&c.byteLength>t.maxLengthLength)throw new xT("message length length too long");if(a>-1)break}if((t==null?void 0:t.maxDataLength)!=null&&a>t.maxDataLength)throw new ST("message length too long");return e.read(a,o)},write:async(o,a)=>{await e.write(new ye(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new ye(...o.flatMap(l=>[s(l.byteLength),l]));await e.write(c,a)},unwrap:()=>e.unwrap()}}function Cg(){const n=me();let t=!1;return{sink:async e=>{if(t)throw new Error("already piped");t=!0,n.resolve(e)},source:async function*(){yield*await n.promise}()}}function _T(){const n=Cg(),t=Cg();return[{source:n.source,sink:t.sink},{source:t.source,sink:n.sink}]}const Ka=65535,Pg=Ka-16;var N3,L3;const mc=!!((L3=(N3=globalThis.process)==null?void 0:N3.env)!=null&&L3.DUMP_SESSION_KEYS);function Kh(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function N8(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function ur(n,...t){if(!N8(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function Dg(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function kT(n,t){ur(n);const e=t.outputLen;if(n.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Rg(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const gs=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),IT=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),AT=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!AT)throw new Error("Non little-endian hardware is not supported");function TT(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function y1(n){if(typeof n=="string")n=TT(n);else if(N8(n))n=w1(n);else throw new Error("Uint8Array expected, got "+typeof n);return n}function CT(n,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(n,t)}function PT(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0}const DT=(n,t)=>{function e(r,...s){if(ur(r),n.nonceLength!==void 0){const h=s[0];if(!h)throw new Error("nonce / iv required");n.varSizeNonce?ur(h):ur(h,n.nonceLength)}const i=n.tagLength;i&&s[1]!==void 0&&ur(s[1]);const o=t(r,...s),a=(h,d)=>{if(d!==void 0){if(h!==2)throw new Error("cipher output not supported");ur(d)}};let c=!1;return{encrypt(h,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,ur(h),a(o.encrypt.length,d),o.encrypt(h,d)},decrypt(h,d){if(ur(h),i&&h.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(h,d)}}}return Object.assign(e,n),e};function Bg(n,t,e=!0){if(t===void 0)return new Uint8Array(n);if(t.length!==n)throw new Error("invalid output length, expected "+n+", got: "+t.length);if(e&&!RT(t))throw new Error("invalid output, must be aligned");return t}function Mg(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(e>>s&i),a=Number(e&i),c=4,l=0;n.setUint32(t+c,o,r),n.setUint32(t+l,a,r)}function RT(n){return n.byteOffset%4===0}function w1(n){return Uint8Array.from(n)}function Ro(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}const L8=n=>Uint8Array.from(n.split("").map(t=>t.charCodeAt(0))),BT=L8("expand 16-byte k"),MT=L8("expand 32-byte k"),NT=gs(BT),LT=gs(MT);function Ie(n,t){return n<<t|n>>>32-t}function b1(n){return n.byteOffset%4===0}const zc=64,OT=16,O8=2**32-1,Ng=new Uint32Array;function FT(n,t,e,r,s,i,o,a){const c=s.length,l=new Uint8Array(zc),h=gs(l),d=b1(s)&&b1(i),f=d?gs(s):Ng,g=d?gs(i):Ng;for(let y=0;y<c;o++){if(n(t,e,r,h,o,a),o>=O8)throw new Error("arx: counter overflow");const p=Math.min(zc,c-y);if(d&&p===zc){const w=y/4;if(y%4!==0)throw new Error("arx: invalid block position");for(let v=0,x;v<OT;v++)x=w+v,g[x]=f[x]^h[v];y+=zc;continue}for(let w=0,v;w<p;w++)v=y+w,i[v]=s[v]^l[w];y+=p}}function UT(n,t){const{allowShortKeys:e,extendNonceFn:r,counterLength:s,counterRight:i,rounds:o}=CT({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof n!="function")throw new Error("core must be a function");return Kh(s),Kh(o),Rg(i),Rg(e),(a,c,l,h,d=0)=>{ur(a),ur(c),ur(l);const f=l.length;if(h===void 0&&(h=new Uint8Array(f)),ur(h),Kh(d),d<0||d>=O8)throw new Error("arx: counter overflow");if(h.length<f)throw new Error(`arx: output (${h.length}) is shorter than data (${f})`);const g=[];let y=a.length,p,w;if(y===32)g.push(p=w1(a)),w=LT;else if(y===16&&e)p=new Uint8Array(32),p.set(a),p.set(a,16),w=NT,g.push(p);else throw new Error(`arx: invalid 32-byte key, got length=${y}`);b1(c)||g.push(c=w1(c));const v=gs(p);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(w,v,gs(c.subarray(0,16)),v),c=c.subarray(16)}const x=16-s;if(x!==c.length)throw new Error(`arx: nonce must be ${x} or 16 bytes`);if(x!==12){const I=new Uint8Array(12);I.set(c,i?0:12-c.length),c=I,g.push(c)}const S=gs(c);return FT(n,w,v,S,l,h,d,o),Ro(...g),h}}const At=(n,t)=>n[t++]&255|(n[t++]&255)<<8;class $T{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,t=y1(t),ur(t,32);const e=At(t,0),r=At(t,2),s=At(t,4),i=At(t,6),o=At(t,8),a=At(t,10),c=At(t,12),l=At(t,14);this.r[0]=e&8191,this.r[1]=(e>>>13|r<<3)&8191,this.r[2]=(r>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let h=0;h<8;h++)this.pad[h]=At(t,16+2*h)}process(t,e,r=!1){const s=r?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],h=o[3],d=o[4],f=o[5],g=o[6],y=o[7],p=o[8],w=o[9],v=At(t,e+0),x=At(t,e+2),S=At(t,e+4),I=At(t,e+6),P=At(t,e+8),A=At(t,e+10),C=At(t,e+12),T=At(t,e+14);let k=i[0]+(v&8191),N=i[1]+((v>>>13|x<<3)&8191),$=i[2]+((x>>>10|S<<6)&8191),z=i[3]+((S>>>7|I<<9)&8191),q=i[4]+((I>>>4|P<<12)&8191),U=i[5]+(P>>>1&8191),L=i[6]+((P>>>14|A<<2)&8191),M=i[7]+((A>>>11|C<<5)&8191),R=i[8]+((C>>>8|T<<8)&8191),V=i[9]+(T>>>5|s),F=0,K=F+k*a+N*(5*w)+$*(5*p)+z*(5*y)+q*(5*g);F=K>>>13,K&=8191,K+=U*(5*f)+L*(5*d)+M*(5*h)+R*(5*l)+V*(5*c),F+=K>>>13,K&=8191;let J=F+k*c+N*a+$*(5*w)+z*(5*p)+q*(5*y);F=J>>>13,J&=8191,J+=U*(5*g)+L*(5*f)+M*(5*d)+R*(5*h)+V*(5*l),F+=J>>>13,J&=8191;let re=F+k*l+N*c+$*a+z*(5*w)+q*(5*p);F=re>>>13,re&=8191,re+=U*(5*y)+L*(5*g)+M*(5*f)+R*(5*d)+V*(5*h),F+=re>>>13,re&=8191;let ae=F+k*h+N*l+$*c+z*a+q*(5*w);F=ae>>>13,ae&=8191,ae+=U*(5*p)+L*(5*y)+M*(5*g)+R*(5*f)+V*(5*d),F+=ae>>>13,ae&=8191;let j=F+k*d+N*h+$*l+z*c+q*a;F=j>>>13,j&=8191,j+=U*(5*w)+L*(5*p)+M*(5*y)+R*(5*g)+V*(5*f),F+=j>>>13,j&=8191;let oe=F+k*f+N*d+$*h+z*l+q*c;F=oe>>>13,oe&=8191,oe+=U*a+L*(5*w)+M*(5*p)+R*(5*y)+V*(5*g),F+=oe>>>13,oe&=8191;let we=F+k*g+N*f+$*d+z*h+q*l;F=we>>>13,we&=8191,we+=U*c+L*a+M*(5*w)+R*(5*p)+V*(5*y),F+=we>>>13,we&=8191;let Pe=F+k*y+N*g+$*f+z*d+q*h;F=Pe>>>13,Pe&=8191,Pe+=U*l+L*c+M*a+R*(5*w)+V*(5*p),F+=Pe>>>13,Pe&=8191;let De=F+k*p+N*y+$*g+z*f+q*d;F=De>>>13,De&=8191,De+=U*h+L*l+M*c+R*a+V*(5*w),F+=De>>>13,De&=8191;let Me=F+k*w+N*p+$*y+z*g+q*f;F=Me>>>13,Me&=8191,Me+=U*d+L*h+M*l+R*c+V*a,F+=Me>>>13,Me&=8191,F=(F<<2)+F|0,F=F+K|0,K=F&8191,F=F>>>13,J+=F,i[0]=K,i[1]=J,i[2]=re,i[3]=ae,i[4]=j,i[5]=oe,i[6]=we,i[7]=Pe,i[8]=De,i[9]=Me}finalize(){const{h:t,pad:e}=this,r=new Uint16Array(10);let s=t[1]>>>13;t[1]&=8191;for(let a=2;a<10;a++)t[a]+=s,s=t[a]>>>13,t[a]&=8191;t[0]+=s*5,s=t[0]>>>13,t[0]&=8191,t[1]+=s,s=t[1]>>>13,t[1]&=8191,t[2]+=s,r[0]=t[0]+5,s=r[0]>>>13,r[0]&=8191;for(let a=1;a<10;a++)r[a]=t[a]+s,s=r[a]>>>13,r[a]&=8191;r[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)r[a]&=i;i=~i;for(let a=0;a<10;a++)t[a]=t[a]&i|r[a];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let o=t[0]+e[0];t[0]=o&65535;for(let a=1;a<8;a++)o=(t[a]+e[a]|0)+(o>>>16)|0,t[a]=o&65535;Ro(r)}update(t){Dg(this);const{buffer:e,blockLen:r}=this;t=y1(t);const s=t.length;for(let i=0;i<s;){const o=Math.min(r-this.pos,s-i);if(o===r){for(;r<=s-i;i+=r)this.process(t,i);continue}e.set(t.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(e,0,!1),this.pos=0)}return this}destroy(){Ro(this.h,this.r,this.buffer,this.pad)}digestInto(t){Dg(this),kT(t,this),this.finished=!0;const{buffer:e,h:r}=this;let{pos:s}=this;if(s){for(e[s++]=1;s<16;s++)e[s]=0;this.process(e,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)t[i++]=r[o]>>>0,t[i++]=r[o]>>>8;return t}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}}function zT(n){const t=(r,s)=>n(s).update(y1(r)).digest(),e=n(new Uint8Array(32));return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=r=>n(r),t}const VT=zT(n=>new $T(n));function HT(n,t,e,r,s,i=20){let o=n[0],a=n[1],c=n[2],l=n[3],h=t[0],d=t[1],f=t[2],g=t[3],y=t[4],p=t[5],w=t[6],v=t[7],x=s,S=e[0],I=e[1],P=e[2],A=o,C=a,T=c,k=l,N=h,$=d,z=f,q=g,U=y,L=p,M=w,R=v,V=x,F=S,K=I,J=P;for(let ae=0;ae<i;ae+=2)A=A+N|0,V=Ie(V^A,16),U=U+V|0,N=Ie(N^U,12),A=A+N|0,V=Ie(V^A,8),U=U+V|0,N=Ie(N^U,7),C=C+$|0,F=Ie(F^C,16),L=L+F|0,$=Ie($^L,12),C=C+$|0,F=Ie(F^C,8),L=L+F|0,$=Ie($^L,7),T=T+z|0,K=Ie(K^T,16),M=M+K|0,z=Ie(z^M,12),T=T+z|0,K=Ie(K^T,8),M=M+K|0,z=Ie(z^M,7),k=k+q|0,J=Ie(J^k,16),R=R+J|0,q=Ie(q^R,12),k=k+q|0,J=Ie(J^k,8),R=R+J|0,q=Ie(q^R,7),A=A+$|0,J=Ie(J^A,16),M=M+J|0,$=Ie($^M,12),A=A+$|0,J=Ie(J^A,8),M=M+J|0,$=Ie($^M,7),C=C+z|0,V=Ie(V^C,16),R=R+V|0,z=Ie(z^R,12),C=C+z|0,V=Ie(V^C,8),R=R+V|0,z=Ie(z^R,7),T=T+q|0,F=Ie(F^T,16),U=U+F|0,q=Ie(q^U,12),T=T+q|0,F=Ie(F^T,8),U=U+F|0,q=Ie(q^U,7),k=k+N|0,K=Ie(K^k,16),L=L+K|0,N=Ie(N^L,12),k=k+N|0,K=Ie(K^k,8),L=L+K|0,N=Ie(N^L,7);let re=0;r[re++]=o+A|0,r[re++]=a+C|0,r[re++]=c+T|0,r[re++]=l+k|0,r[re++]=h+N|0,r[re++]=d+$|0,r[re++]=f+z|0,r[re++]=g+q|0,r[re++]=y+U|0,r[re++]=p+L|0,r[re++]=w+M|0,r[re++]=v+R|0,r[re++]=x+V|0,r[re++]=S+F|0,r[re++]=I+K|0,r[re++]=P+J|0}const qT=UT(HT,{counterRight:!1,counterLength:4,allowShortKeys:!1}),WT=new Uint8Array(16),Lg=(n,t)=>{n.update(t);const e=t.length%16;e&&n.update(WT.subarray(e))},KT=new Uint8Array(32);function Og(n,t,e,r,s){const i=n(t,e,KT),o=VT.create(i);s&&Lg(o,s),Lg(o,r);const a=new Uint8Array(16),c=IT(a);Mg(c,0,BigInt(s?s.length:0),!0),Mg(c,8,BigInt(r.length),!0),o.update(a);const l=o.digest();return Ro(i,a),l}const GT=n=>(t,e,r)=>({encrypt(i,o){const a=i.length;o=Bg(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);n(t,e,c,c,1);const l=Og(n,t,e,c,r);return o.set(l,a),Ro(l),o},decrypt(i,o){o=Bg(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),l=Og(n,t,e,a,r);if(!PT(c,l))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),n(t,e,o,o,1),Ro(l),o}}),Fg=DT({blockSize:64,nonceLength:12,tagLength:16},GT(qT));function QT(n,t,e){return Lu(n),e===void 0&&(e=new Uint8Array(n.outputLen)),cc(n,ai(e),ai(t))}const Gh=new Uint8Array([0]),Ug=new Uint8Array;function YT(n,t,e,r=32){if(Lu(n),to(r),r>255*n.outputLen)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(r/n.outputLen);e===void 0&&(e=Ug);const i=new Uint8Array(s*n.outputLen),o=cc.create(n,t),a=o._cloneInto(),c=new Uint8Array(o.outputLen);for(let l=0;l<s;l++)Gh[0]=l+1,a.update(l===0?Ug:c).update(e).update(Gh).digestInto(c),i.set(c,n.outputLen*l),o._cloneInto(a);return o.destroy(),a.destroy(),c.fill(0),Gh.fill(0),i.slice(0,r)}const XT={hashSHA256(n){return ds(n.subarray())},getHKDF(n,t){const e=QT(ds,t,n),s=YT(ds,e,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const n=Rc.utils.randomPrivateKey();return{publicKey:Rc.getPublicKey(n),privateKey:n}},generateX25519KeyPairFromSeed(n){return{publicKey:Rc.getPublicKey(n),privateKey:n}},generateX25519SharedKey(n,t){return Rc.getSharedSecret(n.subarray(),t.subarray())},chaCha20Poly1305Encrypt(n,t,e,r){return Fg(r,t,e).encrypt(n.subarray())},chaCha20Poly1305Decrypt(n,t,e,r,s){return Fg(r,t,e).decrypt(n.subarray(),s)}},ZT=XT;function JT(n){return{generateKeypair:n.generateX25519KeyPair,dh:(t,e)=>n.generateX25519SharedKey(t.privateKey,e).subarray(0,32),encrypt:n.chaCha20Poly1305Encrypt,decrypt:n.chaCha20Poly1305Decrypt,hash:n.hashSHA256,hkdf:n.getHKDF}}const Zl=n=>{const t=sr(2);return t[0]=n>>8,t[1]=n,t};Zl.bytes=2;const ul=n=>{if(n.length<2)throw RangeError("Could not decode int16BE");if(n instanceof Uint8Array){let t=0;return t+=n[0]<<8,t+=n[1],t}return n.getUint16(0)};ul.bytes=2;function jT(n){return{xxHandshakeSuccesses:n.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:n.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:n.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:n.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:n.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function F8(n,t){!t.enabled||!mc||(n?(t(`LOCAL_STATIC_PUBLIC_KEY ${Z(n.publicKey,"hex")}`),t(`LOCAL_STATIC_PRIVATE_KEY ${Z(n.privateKey,"hex")}`)):t("Missing local static keys."))}function U8(n,t){!t.enabled||!mc||(n?(t(`LOCAL_PUBLIC_EPHEMERAL_KEY ${Z(n.publicKey,"hex")}`),t(`LOCAL_PRIVATE_EPHEMERAL_KEY ${Z(n.privateKey,"hex")}`)):t("Missing local ephemeral keys."))}function eC(n,t){!t.enabled||!mc||t(n?`REMOTE_STATIC_PUBLIC_KEY ${Z(n.subarray(),"hex")}`:"Missing remote static public key.")}function $8(n,t){!t.enabled||!mc||t(n?`REMOTE_EPHEMERAL_PUBLIC_KEY ${Z(n.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function z8(n,t,e){!e.enabled||!mc||(e(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k&&Z(n.k,"hex")}`),e(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&Z(t.k,"hex")}`))}function ks(n,t){if(n.length!==t.length)throw new Error("Inputs should have the same length");const e=sr(n.length);for(let r=0;r<n.length;r++)e[r]=n[r]^t[r];return e}const _u=class _u extends Error{constructor(e="Invalid crypto exchange"){super(e);u(this,"code");this.code=_u.code}};u(_u,"code","ERR_INVALID_CRYPTO_EXCHANGE");let Sa=_u;const tC=0,rC=4294967295,nC="Cipherstate has reached maximum n, a new handshake must be performed";class sC{constructor(t=tC){u(this,"n");u(this,"bytes");u(this,"view");this.n=t,this.bytes=Ee(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>rC)throw new Error(nC)}}const no=Ee(0);class Vc{constructor(t,e=void 0,r=0){u(this,"k");u(this,"n");u(this,"crypto");this.crypto=t,this.k=e,this.n=new sC(r)}hasKey(){return!!this.k}encryptWithAd(t,e){if(!this.hasKey())return e;this.n.assertValue();const r=this.crypto.encrypt(e,this.n.getBytes(),t,this.k);return this.n.increment(),r}decryptWithAd(t,e,r){if(!this.hasKey())return e;this.n.assertValue();const s=this.crypto.decrypt(e,this.n.getBytes(),t,this.k,r);return this.n.increment(),s}}class iC{constructor(t,e){u(this,"cs");u(this,"ck");u(this,"h");u(this,"crypto");this.crypto=t;const r=Y(e,"utf-8");this.h=aC(t,r),this.ck=this.h,this.cs=new Vc(t)}mixKey(t){const[e,r]=this.crypto.hkdf(this.ck,t);this.ck=e,this.cs=new Vc(this.crypto,r)}mixHash(t){this.h=this.crypto.hash(new ye(this.h,t))}encryptAndHash(t){const e=this.cs.encryptWithAd(this.h,t);return this.mixHash(e),e}decryptAndHash(t){const e=this.cs.decryptWithAd(this.h,t);return this.mixHash(t),e}split(){const[t,e]=this.crypto.hkdf(this.ck,no);return[new Vc(this.crypto,t),new Vc(this.crypto,e)]}}class oC{constructor(t){u(this,"ss");u(this,"s");u(this,"e");u(this,"rs");u(this,"re");u(this,"initiator");u(this,"crypto");const{crypto:e,protocolName:r,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=t;this.crypto=e,this.ss=new iC(e,r),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const t=this.crypto.generateKeypair();return this.ss.mixHash(t.publicKey),this.e=t,t.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(t,e=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(t.byteLength<e+32)throw new Error("message is not long enough");this.re=t.sublist(e,e+32),this.ss.mixHash(this.re)}readS(t,e=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(t.byteLength<e+r)throw new Error("message is not long enough");const s=t.sublist(e,e+r);return this.rs=this.ss.decryptAndHash(s),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class V8 extends oC{writeMessageA(t){return new ye(this.writeE(),this.ss.encryptAndHash(t))}writeMessageB(t){const e=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new ye(e,r,this.ss.encryptAndHash(t))}writeMessageC(t){const e=this.writeS();return this.writeSE(),new ye(e,this.ss.encryptAndHash(t))}readMessageA(t){try{return this.readE(t),this.ss.decryptAndHash(t.sublist(32))}catch(e){throw new Sa(`handshake stage 0 validation fail: ${e.message}`)}}readMessageB(t){try{this.readE(t),this.readEE();const e=this.readS(t,32);return this.readES(),this.ss.decryptAndHash(t.sublist(32+e))}catch(e){throw new Sa(`handshake stage 1 validation fail: ${e.message}`)}}readMessageC(t){try{const e=this.readS(t);return this.readSE(),this.ss.decryptAndHash(t.sublist(e))}catch(e){throw new Sa(`handshake stage 2 validation fail: ${e.message}`)}}}function aC(n,t){if(t.length<=32){const e=Ee(32);return e.set(t),e}else return n.hash(t)}var Jl;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.webtransportCerthashes!=null)for(const i of e.webtransportCerthashes)r.uint32(10),r.bytes(i);if(e.streamMuxers!=null)for(const i of e.streamMuxers)r.uint32(18),r.string(i);s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c;const i={webtransportCerthashes:[],streamMuxers:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const l=e.uint32();switch(l>>>3){case 1:{if(((a=s.limits)==null?void 0:a.webtransportCerthashes)!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new Fe('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(e.bytes());break}case 2:{if(((c=s.limits)==null?void 0:c.streamMuxers)!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new Fe('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(e.string());break}default:{e.skipType(l&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Jl||(Jl={}));var jl;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.identityKey!=null&&e.identityKey.byteLength>0&&(r.uint32(10),r.bytes(e.identityKey)),e.identitySig!=null&&e.identitySig.byteLength>0&&(r.uint32(18),r.bytes(e.identitySig)),e.extensions!=null&&(r.uint32(34),Jl.codec().encode(e.extensions,r)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a;const i={identityKey:Ee(0),identitySig:Ee(0)},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.identityKey=e.bytes();break}case 2:{i.identitySig=e.bytes();break}case 4:{i.extensions=Jl.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.extensions});break}default:{e.skipType(c&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(jl||(jl={}));async function H8(n,t,e){const r=await n.sign(W8(t));return jl.encode({identityKey:Ur(n.publicKey),identitySig:r,extensions:e})}async function q8(n,t,e){try{const r=jl.decode(n),s=ir(r.identityKey);if((e==null?void 0:e.equals(s))===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${e}`);if(!t)throw new Error("Remote static does not exist");const i=W8(t);if(!await s.verify(i,r.identitySig))throw new Error("Invalid payload signature");return r}catch(r){throw new W4(r.message)}}function W8(n){const t=Y("noise-libp2p-static-key:");return n instanceof Uint8Array?ft([t,n],t.length+n.length):(n.prepend(t),n)}async function cC(n,t){const{log:e,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=n,h=await H8(i,a.publicKey,l),d=new V8({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});F8(d.s,e),e.trace("Stage 0 - Initiator starting to send first message."),await r.write(d.writeMessageA(no),t),e.trace("Stage 0 - Initiator finished sending first message."),U8(d.e,e),e.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=d.readMessageB(await r.read(t));e.trace("Stage 1 - Initiator received the message."),$8(d.re,e),eC(d.rs,e),e.trace("Initiator going to check remote's signature...");const g=await q8(f,d.rs,c);e.trace("All good with the signature!"),e.trace("Stage 2 - Initiator sending third handshake message."),await r.write(d.writeMessageC(h),t),e.trace("Stage 2 - Initiator sent message with signed payload.");const[y,p]=d.ss.split();return z8(y,p,e),{payload:g,encrypt:w=>y.encryptWithAd(no,w),decrypt:(w,v)=>p.decryptWithAd(no,w,v)}}async function lC(n,t){const{log:e,connection:r,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=n,h=await H8(i,a.publicKey,l),d=new V8({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});F8(d.s,e),e.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await r.read(t)),e.trace("Stage 0 - Responder received first message."),$8(d.re,e),e.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await r.write(d.writeMessageB(h),t),e.trace("Stage 1 - Responder sent the second handshake message with signed payload."),U8(d.e,e),e.trace("Stage 2 - Responder waiting for third handshake message...");const f=d.readMessageC(await r.read(t));e.trace("Stage 2 - Responder received the message, finished handshake.");const g=await q8(f,d.rs,c),[y,p]=d.ss.split();return z8(y,p,e),{payload:g,encrypt:w=>p.encryptWithAd(no,w),decrypt:(w,v)=>y.decryptWithAd(no,w,v)}}const $g=16;function uC(n,t){return async function*(e){for await(const r of e)for(let s=0;s<r.length;s+=Pg){let i=s+Pg;i>r.length&&(i=r.length);let o;r instanceof Uint8Array?o=n.encrypt(r.subarray(s,i)):o=n.encrypt(r.sublist(s,i)),t==null||t.encryptedPackets.increment(),yield new ye(Zl(o.byteLength),o)}}}function hC(n,t){return async function*(e){for await(const r of e)for(let s=0;s<r.length;s+=Ka){let i=s+Ka;if(i>r.length&&(i=r.length),i-$g<s)throw new Error("Invalid chunk");const o=r.sublist(s,i),a=r.subarray(s,i-$g);try{const c=n.decrypt(o,a);t==null||t.decryptedPackets.increment(),yield c}catch(c){throw t==null||t.decryptErrors.increment(),c}}}}var O3,F3;F3=Symbol.toStringTag,O3=Pt;class dC{constructor(t,e={}){u(this,"protocol","/noise");u(this,"crypto");u(this,"prologue");u(this,"staticKey");u(this,"extensions");u(this,"metrics");u(this,"components");u(this,F3,"@chainsafe/libp2p-noise");u(this,O3,["@libp2p/connection-encryption","@chainsafe/libp2p-noise"]);const{staticNoiseKey:r,extensions:s,crypto:i,prologueBytes:o}=e,{metrics:a}=t;this.components=t;const c=i??ZT;this.crypto=JT(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?jT(a):void 0,r?this.staticKey=c.generateX25519KeyPairFromSeed(r):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??Ee(0)}async secureOutbound(t,e){var a,c;const r=Do(t,{lengthEncoder:Zl,lengthDecoder:ul,maxDataLength:Ka}),s=await this.performHandshakeInitiator(r,this.components.privateKey,(a=e==null?void 0:e.remotePeer)==null?void 0:a.publicKey,e),i=await this.createSecureConnection(r,s);t.source=i.source,t.sink=i.sink;const o=ir(s.payload.identityKey);return{conn:t,remoteExtensions:s.payload.extensions,remotePeer:ko(o),streamMuxer:this.getStreamMuxer((c=s.payload.extensions)==null?void 0:c.streamMuxers)}}getStreamMuxer(t){if(t==null)return;const e=this.components.upgrader.getStreamMuxers();if(e!=null)for(const r of t){const s=e.get(r);if(s!=null)return s}if(t.length)throw new Ny("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(t,e){var a,c;const r=Do(t,{lengthEncoder:Zl,lengthDecoder:ul,maxDataLength:Ka}),s=await this.performHandshakeResponder(r,this.components.privateKey,(a=e==null?void 0:e.remotePeer)==null?void 0:a.publicKey,e),i=await this.createSecureConnection(r,s);t.source=i.source,t.sink=i.sink;const o=ir(s.payload.identityKey);return{conn:t,remoteExtensions:s.payload.extensions,remotePeer:ko(o),streamMuxer:this.getStreamMuxer((c=s.payload.extensions)==null?void 0:c.streamMuxers)}}async performHandshakeInitiator(t,e,r,s){var o,a;let i;try{i=await cC({connection:t,privateKey:e,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:[...this.components.upgrader.getStreamMuxers().keys()],webtransportCerthashes:[],...this.extensions}},s),(o=this.metrics)==null||o.xxHandshakeSuccesses.increment()}catch(c){throw(a=this.metrics)==null||a.xxHandshakeErrors.increment(),c}return i}async performHandshakeResponder(t,e,r,s){var o,a;let i;try{i=await lC({connection:t,privateKey:e,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:[...this.components.upgrader.getStreamMuxers().keys()],webtransportCerthashes:[],...this.extensions}},s),(o=this.metrics)==null||o.xxHandshakeSuccesses.increment()}catch(c){throw(a=this.metrics)==null||a.xxHandshakeErrors.increment(),c}return i}async createSecureConnection(t,e){const[r,s]=_T(),i=t.unwrap();return await It(r,uC(e,this.metrics),i,o=>Eo(o,{lengthDecoder:ul}),hC(e,this.metrics),r),s}}function K8(n={}){return t=>new dC(t,n)}function G8(n){if(n!=null){if(typeof n[Symbol.iterator]=="function")return n[Symbol.iterator]();if(typeof n[Symbol.asyncIterator]=="function")return n[Symbol.asyncIterator]();if(typeof n.next=="function")return n}throw new Error("argument is not an iterator or iterable")}class Gs extends Error{constructor(t="The frame was invalid"){super(t),this.name="InvalidFrameError"}}u(Gs,"name","InvalidFrameError");class m0 extends Error{constructor(t="Unrequested ping error"){super(t),this.name="UnrequestedPingError"}}u(m0,"name","UnrequestedPingError");class y0 extends Error{constructor(t="Unrequested ping error"){super(t),this.name="NotMatchingPingError"}}u(y0,"name","NotMatchingPingError");class Q8 extends Error{constructor(t="Invalid state"){super(t),this.name="InvalidStateError"}}u(Q8,"name","InvalidStateError");class Y8 extends Error{constructor(t="Strean already exists"){super(t),this.name="StreamAlreadyExistsError"}}u(Y8,"name","StreamAlreadyExistsError");class X8 extends Error{constructor(t="Decode invalid version"){super(t),this.name="DecodeInvalidVersionError"}}u(X8,"name","DecodeInvalidVersionError");class Z8 extends Error{constructor(t="Both clients"){super(t),this.name="BothClientsError"}}u(Z8,"name","BothClientsError");class w0 extends Error{constructor(t="Receive window exceeded"){super(t),this.name="ReceiveWindowExceededError"}}u(w0,"name","ReceiveWindowExceededError");const fC=new Set([Gs.name,m0.name,y0.name,Y8.name,X8.name,Z8.name,w0.name]),b0=256*1024,gC=16*1024*1024,pC={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:b0,maxStreamWindowSize:gC,maxMessageSize:64*1024};function mC(n){if(n.keepAliveInterval<=0)throw new W("keep-alive interval must be positive");if(n.maxInboundStreams<0)throw new W("max inbound streams must be larger or equal 0");if(n.maxOutboundStreams<0)throw new W("max outbound streams must be larger or equal 0");if(n.initialStreamWindowSize<b0)throw new W("InitialStreamWindowSize must be larger or equal 256 kB");if(n.maxStreamWindowSize<n.initialStreamWindowSize)throw new W("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(n.maxStreamWindowSize>2**32-1)throw new W("MaxStreamWindowSize must be less than equal MAX_UINT32");if(n.maxMessageSize<1024)throw new W("MaxMessageSize must be greater than a kilobyte")}var vt;(function(n){n[n.Data=0]="Data",n[n.WindowUpdate=1]="WindowUpdate",n[n.Ping=2]="Ping",n[n.GoAway=3]="GoAway"})(vt||(vt={}));var nt;(function(n){n[n.SYN=1]="SYN",n[n.ACK=2]="ACK",n[n.FIN=4]="FIN",n[n.RST=8]="RST"})(nt||(nt={}));Object.values(nt).filter(n=>typeof n!="string");const yC=0;var en;(function(n){n[n.NormalTermination=0]="NormalTermination",n[n.ProtocolError=1]="ProtocolError",n[n.InternalError=2]="InternalError"})(en||(en={}));const xa=12,zg=2**24;function wC(n){if(n[0]!==yC)throw new Gs("Invalid frame version");return{type:n[1],flag:(n[2]<<8)+n[3],streamID:n[4]*zg+(n[5]<<16)+(n[6]<<8)+n[7],length:n[8]*zg+(n[9]<<16)+(n[10]<<8)+n[11]}}let bC=class{constructor(t){u(this,"source");u(this,"buffer");u(this,"frameInProgress");this.source=vC(t),this.buffer=new ye,this.frameInProgress=!1}async*emitFrames(){for await(const t of this.source)for(this.buffer.append(t);;){const e=this.readHeader();if(e===void 0)break;const{type:r,length:s}=e;r===vt.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,s)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new Q8("decoding frame already in progress");if(this.buffer.length<xa)return;const t=wC(this.buffer.subarray(0,xa));return this.buffer.consume(xa),t}async readBytes(t){if(this.buffer.length<t){for await(const r of this.source)if(this.buffer.append(r),this.buffer.length>=t)break}const e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function vC(n){if(n[Symbol.iterator]!==void 0){const t=n[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(n[Symbol.asyncIterator]!==void 0){const t=n[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function Vg(n){const t=new Uint8Array(xa);return t[1]=n.type,t[2]=n.flag>>>8,t[3]=n.flag,t[4]=n.streamID>>>24,t[5]=n.streamID>>>16,t[6]=n.streamID>>>8,t[7]=n.streamID,t[8]=n.length>>>24,t[9]=n.length>>>16,t[10]=n.length>>>8,t[11]=n.length,t}function EC(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function J8(n,t){var r,s;const e=(s=(r=G8(n)).return)==null?void 0:s.call(r);EC(e)&&e.catch(i=>{t.error("could not cause iterator to return",i)})}const SC=5e3;function Qh(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class v0{constructor(t){u(this,"id");u(this,"direction");u(this,"timeline");u(this,"protocol");u(this,"metadata");u(this,"source");u(this,"status");u(this,"readStatus");u(this,"writeStatus");u(this,"log");u(this,"sinkController");u(this,"sinkEnd");u(this,"closed");u(this,"endErr");u(this,"streamSource");u(this,"onEnd");u(this,"onCloseRead");u(this,"onCloseWrite");u(this,"onReset");u(this,"onAbort");u(this,"sendCloseWriteTimeout");u(this,"sendingData");this.sinkController=new AbortController,this.sinkEnd=me(),this.closed=me(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??SC,this.onEnd=t.onEnd,this.onCloseRead=t==null?void 0:t.onCloseRead,this.onCloseWrite=t==null?void 0:t.onCloseWrite,this.onReset=t==null?void 0:t.onReset,this.onAbort=t==null?void 0:t.onAbort,this.source=this.streamSource=gn({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new xl(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const e={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(e);Qh(s)&&await s}const r=()=>{J8(t,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let s of t){s=s instanceof Uint8Array?new ye(s):s;const i=this.sendData(s,e);Qh(i)&&(this.sendingData=me(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){var e;this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),(e=this.onCloseRead)==null||e.call(this),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){var e;this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),(e=this.onCloseWrite)==null||e.call(this),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await fr(Promise.all([this.closeWrite(t),this.closeRead(t),this.closed.promise]),t==null?void 0:t.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await fr(this.sink([]),t.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await fr(this.sendingData.promise,t.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await fr(this.sinkEnd.promise,t.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){var r;if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");const e=this.sendReset();Qh(e)&&e.catch(s=>{this.log.error("error sending reset message",s)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),(r=this.onAbort)==null||r.call(this,t)}reset(){var e;if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const t=new G4("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),(e=this.onReset)==null||e.call(this)}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}}var Lr;(function(n){n[n.Init=0]="Init",n[n.SYNSent=1]="SYNSent",n[n.SYNReceived=2]="SYNReceived",n[n.Established=3]="Established",n[n.Finished=4]="Finished"})(Lr||(Lr={}));class xC extends v0{constructor(e){super({...e,onEnd:r=>{var s;this.state=Lr.Finished,(s=e.onEnd)==null||s.call(e,r)}});u(this,"name");u(this,"state");u(this,"config");u(this,"_id");u(this,"sendWindowCapacity");u(this,"sendWindowCapacityUpdate");u(this,"recvWindow");u(this,"recvWindowCapacity");u(this,"epochStart");u(this,"getRTT");u(this,"sendFrame");this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=b0,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=ql(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,r={}){var s,i;for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&((s=this.log)==null||s.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(r),this.status==="closed"||this.status==="aborted"||this.status==="reset")){(i=this.log)==null||i.trace("%s while waiting for send window capacity",this.status);return}const o=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-xa,e.length),a=this.getSendFlags();this.sendFrame({type:vt.Data,flag:a,streamID:this._id,length:o},e.sublist(0,o)),this.sendWindowCapacity-=o,e.consume(o)}}async sendReset(){this.sendFrame({type:vt.WindowUpdate,flag:nt.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|nt.FIN;this.sendFrame({type:vt.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){var o,a;if(this.sendWindowCapacity>0)return;let r,s;const i=()=>{this.status==="open"||this.status==="closing"?s(new ii("Stream aborted")):r()};(o=e.signal)==null||o.addEventListener("abort",i);try{await new Promise((c,l)=>{this.sendWindowCapacityUpdate=()=>{c()},s=l,r=c})}finally{(a=e.signal)==null||a.removeEventListener("abort",i)}}handleWindowUpdate(e){var s,i;(s=this.log)==null||s.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const r=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,r===0&&e.length>0&&((i=this.sendWindowCapacityUpdate)==null||i.call(this))}async handleData(e,r){var i;if((i=this.log)==null||i.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new w0("Receive window exceeded");const s=await r();this.recvWindowCapacity-=e.length,this.sourcePush(s)}processFlags(e){(e&nt.ACK)===nt.ACK&&this.state===Lr.SYNSent&&(this.state=Lr.Established),(e&nt.FIN)===nt.FIN&&this.remoteCloseWrite(),(e&nt.RST)===nt.RST&&this.reset()}getSendFlags(){switch(this.state){case Lr.Init:return this.state=Lr.SYNSent,nt.SYN;case Lr.SYNReceived:return this.state=Lr.Established,nt.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),r=Date.now(),s=this.getRTT();if(e===0&&s>-1&&r-this.epochStart<s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=r,this.sendFrame({type:vt.WindowUpdate,flag:e,streamID:this._id,length:i})}}const j8="/yamux/1.0.0",_C=500;var U3,$3;$3=Symbol.toStringTag,U3=Pt;class kC{constructor(t,e={}){u(this,"protocol",j8);u(this,"_components");u(this,"_init");u(this,$3,"@chainsafe/libp2p-yamux");u(this,U3,["@libp2p/stream-multiplexing"]);this._components=t,this._init=e}createStreamMuxer(t){return new IC(this._components,{...this._init,...t})}}class IC{constructor(t,e){u(this,"protocol",j8);u(this,"source");u(this,"sink");u(this,"config");u(this,"log");u(this,"logger");u(this,"closeController");u(this,"nextStreamID");u(this,"_streams");u(this,"nextPingID");u(this,"activePing");u(this,"rtt");u(this,"client");u(this,"localGoAway");u(this,"remoteGoAway");u(this,"numInboundStreams");u(this,"numOutboundStreams");u(this,"onIncomingStream");u(this,"onStreamEnd");var r;this.client=e.direction==="outbound",this.config={...pC,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),mC(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=gn({onEnd:()=>{var s;(s=this.log)==null||s.trace("muxer source ended"),this._streams.forEach(i=>{i.destroy()})}}),this.sink=async s=>{var c,l,h;const i=()=>{const d=G8(s);if(d.return!=null){const f=d.return();AC(f)&&f.catch(g=>{var y;(y=this.log)==null||y.call(this,"could not cause sink source to return",g)})}};let o,a;try{const d=new bC(s);try{this.closeController.signal.addEventListener("abort",i);for await(const f of d.emitFrames())await this.handleFrame(f.header,f.readData)}finally{this.closeController.signal.removeEventListener("abort",i)}o=en.NormalTermination}catch(d){fC.has(d.name)?((c=this.log)==null||c.error("protocol error in sink",d),o=en.ProtocolError):((l=this.log)==null||l.error("internal error in sink",d),o=en.InternalError),a=d}(h=this.log)==null||h.trace("muxer sink ended"),a!=null?this.abort(a,o):await this.close({reason:o})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,(r=this.log)==null||r.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(s=>{var i;return(i=this.log)==null?void 0:i.error("keepalive error: %s",s)}),this.ping().catch(s=>{var i;return(i=this.log)==null?void 0:i.error("ping error: %s",s)})}get streams(){return Array.from(this._streams.values())}newStream(t){var s;if(this.remoteGoAway!==void 0)throw new $s("Muxer closed remotely");if(this.localGoAway!==void 0)throw new $s("Muxer closed locally");const e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new Du("max outbound streams exceeded");(s=this.log)==null||s.trace("new outgoing stream id=%s",e);const r=this._newStream(e,t,Lr.Init,"outbound");return this._streams.set(e,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new $s("Muxer closed remotely");if(this.localGoAway!==void 0)throw new $s("Muxer closed locally");if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new $s("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:t};const e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const r=Date.now();this.rtt=r-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){var r;if(this.closeController.signal.aborted)return;const e=(t==null?void 0:t.reason)??en.NormalTermination;if((r=this.log)==null||r.trace("muxer close reason=%s",e),t.signal==null){const s=AbortSignal.timeout(_C);t={...t,signal:s}}try{await Promise.all([...this._streams.values()].map(async s=>s.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(s){this.abort(s)}}abort(t,e){var r;if(!this.closeController.signal.aborted){e=e??en.InternalError,(r=this.log)==null||r.error("muxer abort reason=%s error=%s",e,t);for(const s of this._streams.values())s.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,r,s){if(this._streams.get(t)!=null)throw new W("Stream already exists with that id");const i=new xC({id:t.toString(),name:e,state:r,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{var o;this.closeStream(t),(o=this.onStreamEnd)==null||o.call(this,i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){var e;const t=new Promise((r,s)=>{this.closeController.signal.addEventListener("abort",s,{once:!0})});for((e=this.log)==null||e.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let r;try{await Promise.race([t,new Promise(s=>{r=setTimeout(s,this.config.keepAliveInterval)})]),this.ping().catch(s=>{var i;return(i=this.log)==null?void 0:i.error("ping error: %s",s)})}catch{clearInterval(r);return}}}async handleFrame(t,e){var o;const{streamID:r,type:s,length:i}=t;if((o=this.log)==null||o.trace("received frame %o",t),r===0)switch(s){case vt.Ping:{this.handlePing(t);return}case vt.GoAway:{this.handleGoAway(i);return}default:throw new Gs("Invalid frame type")}else switch(t.type){case vt.Data:case vt.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new Gs("Invalid frame type")}}handlePing(t){var e,r;if(t.flag===nt.SYN)(e=this.log)==null||e.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,nt.ACK);else if(t.flag===nt.ACK)(r=this.log)==null||r.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new Gs("Invalid frame flag")}handlePingResponse(t){if(this.activePing===void 0)throw new m0("ping not requested");if(this.activePing.id!==t)throw new y0("ping doesn't match our id");this.activePing.resolve()}handleGoAway(t){var e;(e=this.log)==null||e.trace("received GoAway reason=%s",en[t]??"unknown"),this.remoteGoAway=t;for(const r of this._streams.values())r.reset();this._closeMuxer()}async handleStreamMessage(t,e){var a,c;const{streamID:r,flag:s,type:i}=t;(s&nt.SYN)===nt.SYN&&this.incomingStream(r);const o=this._streams.get(r);if(o===void 0){if(i===vt.Data){if((a=this.log)==null||a.call(this,"discarding data for stream id=%s",r),e===void 0)throw new Error("unreachable");await e()}else(c=this.log)==null||c.trace("frame for missing stream id=%s",r);return}switch(i){case vt.WindowUpdate:{o.handleWindowUpdate(t);return}case vt.Data:{if(e===void 0)throw new Error("unreachable");await o.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){var r,s,i;if(this.client!==(t%2===0))throw new W("Both endpoints are clients");if(this._streams.has(t))return;if((r=this.log)==null||r.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:vt.WindowUpdate,flag:nt.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){(s=this.log)==null||s.call(this,"maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:vt.WindowUpdate,flag:nt.RST,streamID:t,length:0});return}const e=this._newStream(t,void 0,Lr.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),(i=this.onIncomingStream)==null||i.call(this,e)}sendFrame(t,e){var r;if((r=this.log)==null||r.trace("sending frame %o",t),t.type===vt.Data){if(e===void 0)throw new Gs("Invalid frame");this.source.push(new ye(Vg(t),e))}else this.source.push(Vg(t))}sendPing(t,e=nt.SYN){var r,s;e===nt.SYN?(r=this.log)==null||r.trace("sending ping request pingId=%s",t):(s=this.log)==null||s.trace("sending ping response pingId=%s",t),this.sendFrame({type:vt.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=en.NormalTermination){var e;(e=this.log)==null||e.call(this,"sending GoAway reason=%s",en[t]),this.localGoAway=t,this.sendFrame({type:vt.GoAway,flag:0,streamID:0,length:t})}}function AC(n){return n!=null&&typeof n.then=="function"}function TC(n={}){return t=>new kC(t,n)}const CC=41;function em(n){try{const[[t,e]]=n.stringTuples();if(e==null)return!1;if(t===CC)return QI("2000::/3",e)}catch{}return!1}const PC=4,DC=41;function tm(n){try{const[[t]]=n.stringTuples();return t===PC||t===DC}catch{}return!1}function gi(n){try{if(!tm(n))return!1;const[[,t]]=n.stringTuples();return t==null?!1:Ds(t)??!1}catch{}return!0}function RC(n,t,e){let r,s;function i(){const a={signal:s.signal};if((e==null?void 0:e.timeout)!=null){const c=Ne([s.signal,AbortSignal.timeout(e.timeout)]);a.signal=c}Promise.resolve().then(async()=>{await n(a)}).catch(()=>{}).finally(()=>{s.signal.aborted||(r=setTimeout(i,t))})}let o=!1;return{setInterval:a=>{t=a,r!=null&&(clearTimeout(r),r=setTimeout(i,t))},setTimeout:a=>{e==null&&(e={}),e.timeout=a},start:()=>{o||(o=!0,s=new AbortController,s.signal,(e==null?void 0:e.runImmediately)===!0?queueMicrotask(()=>{i()}):r=setTimeout(i,t))},stop:()=>{clearTimeout(r),s==null||s.abort(),o=!1}}}function Wt(n,t){const e=Do(n,t),r={read:async(s,i)=>{const o=await e.read(i);return s.decode(o)},write:async(s,i,o)=>{await e.write(i.encode(s),o)},writeV:async(s,i,o)=>{await e.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>r.read(s,i),write:async(i,o)=>r.write(i,s,o),writeV:async(i,o)=>r.writeV(i,s,o),unwrap:()=>r}),unwrap:()=>e.unwrap()};return r}const BC="libp2p",MC="autonat",NC="1.0.0",LC=3e4,OC=2,FC=20,UC=80,$C=8192;var Xe;(function(n){(function(s){s.DIAL="DIAL",s.DIAL_RESPONSE="DIAL_RESPONSE"})(n.MessageType||(n.MessageType={}));let t;(function(s){s[s.DIAL=0]="DIAL",s[s.DIAL_RESPONSE=1]="DIAL_RESPONSE"})(t||(t={})),function(s){s.codec=()=>Ht(t)}(n.MessageType||(n.MessageType={})),function(s){s.OK="OK",s.E_DIAL_ERROR="E_DIAL_ERROR",s.E_DIAL_REFUSED="E_DIAL_REFUSED",s.E_BAD_REQUEST="E_BAD_REQUEST",s.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(n.ResponseStatus||(n.ResponseStatus={}));let e;(function(s){s[s.OK=0]="OK",s[s.E_DIAL_ERROR=100]="E_DIAL_ERROR",s[s.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",s[s.E_BAD_REQUEST=200]="E_BAD_REQUEST",s[s.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"})(e||(e={})),function(s){s.codec=()=>Ht(e)}(n.ResponseStatus||(n.ResponseStatus={})),function(s){let i;s.codec=()=>(i==null&&(i=de((o,a,c={})=>{if(c.lengthDelimited!==!1&&a.fork(),o.id!=null&&(a.uint32(10),a.bytes(o.id)),o.addrs!=null)for(const l of o.addrs)a.uint32(18),a.bytes(l);c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{var d;const l={addrs:[]},h=a==null?o.len:o.pos+a;for(;o.pos<h;){const f=o.uint32();switch(f>>>3){case 1:{l.id=o.bytes();break}case 2:{if(((d=c.limits)==null?void 0:d.addrs)!=null&&l.addrs.length===c.limits.addrs)throw new Fe('Decode error - map field "addrs" had too many elements');l.addrs.push(o.bytes());break}default:{o.skipType(f&7);break}}}return l})),i),s.encode=o=>he(o,s.codec()),s.decode=(o,a)=>ue(o,s.codec(),a)}(n.PeerInfo||(n.PeerInfo={})),function(s){let i;s.codec=()=>(i==null&&(i=de((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.peer!=null&&(a.uint32(10),n.PeerInfo.codec().encode(o.peer,a)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{var d;const l={},h=a==null?o.len:o.pos+a;for(;o.pos<h;){const f=o.uint32();switch(f>>>3){case 1:{l.peer=n.PeerInfo.codec().decode(o,o.uint32(),{limits:(d=c.limits)==null?void 0:d.peer});break}default:{o.skipType(f&7);break}}}return l})),i),s.encode=o=>he(o,s.codec()),s.decode=(o,a)=>ue(o,s.codec(),a)}(n.Dial||(n.Dial={})),function(s){let i;s.codec=()=>(i==null&&(i=de((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.status!=null&&(a.uint32(8),n.ResponseStatus.codec().encode(o.status,a)),o.statusText!=null&&(a.uint32(18),a.string(o.statusText)),o.addr!=null&&(a.uint32(26),a.bytes(o.addr)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},h=a==null?o.len:o.pos+a;for(;o.pos<h;){const d=o.uint32();switch(d>>>3){case 1:{l.status=n.ResponseStatus.codec().decode(o);break}case 2:{l.statusText=o.string();break}case 3:{l.addr=o.bytes();break}default:{o.skipType(d&7);break}}}return l})),i),s.encode=o=>he(o,s.codec()),s.decode=(o,a)=>ue(o,s.codec(),a)}(n.DialResponse||(n.DialResponse={}));let r;n.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.type!=null&&(i.uint32(8),n.MessageType.codec().encode(s.type,i)),s.dial!=null&&(i.uint32(18),n.Dial.codec().encode(s.dial,i)),s.dialResponse!=null&&(i.uint32(26),n.DialResponse.codec().encode(s.dialResponse,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l,h;const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.type=n.MessageType.codec().decode(s);break}case 2:{a.dial=n.Dial.codec().decode(s,s.uint32(),{limits:(l=o.limits)==null?void 0:l.dial});break}case 3:{a.dialResponse=n.DialResponse.codec().decode(s,s.uint32(),{limits:(h=o.limits)==null?void 0:h.dialResponse});break}default:{s.skipType(d&7);break}}}return a})),r),n.encode=s=>he(s,n.codec()),n.decode=(s,i)=>ue(s,n.codec(),i)})(Xe||(Xe={}));const zC=4,VC=8;var z3,V3;class HC{constructor(t,e){u(this,"components");u(this,"protocol");u(this,"timeout");u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"maxMessageSize");u(this,"started");u(this,"log");u(this,"topologyId");u(this,"dialResults");u(this,"findPeers");u(this,"addressFilter");u(this,"connectionThreshold");u(this,V3,"@libp2p/autonat");u(this,z3,["@libp2p/autonat"]);this.components=t,this.log=t.logger.forComponent("libp2p:auto-nat"),this.started=!1,this.protocol=`/${e.protocolPrefix??BC}/${MC}/${NC}`,this.timeout=e.timeout??LC,this.maxInboundStreams=e.maxInboundStreams??OC,this.maxOutboundStreams=e.maxOutboundStreams??FC,this.connectionThreshold=e.connectionThreshold??UC,this.maxMessageSize=e.maxMessageSize??$C,this.dialResults=new Map,this.findPeers=RC(this.findRandomPeers.bind(this),6e4),this.addressFilter=hi(1024)}get[(V3=Symbol.toStringTag,z3=Pt,ms)](){return["@libp2p/identify"]}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,t=>{this.handleIncomingAutonatStream(t).catch(e=>{this.log.error("error handling incoming autonat stream - %e",e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.topologyId=await this.components.registrar.register(this.protocol,{onConnect:(t,e)=>{this.verifyExternalAddresses(e).catch(r=>{this.log.error("could not verify addresses - %e",r)})}}),this.findPeers.start(),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.topologyId!=null&&await this.components.registrar.unhandle(this.topologyId),this.dialResults.clear(),this.findPeers.stop(),this.started=!1}allAddressesAreVerified(){return this.components.addressManager.getAddressesWithMetadata().every(t=>t.expires>Date.now()?!0:t.verified)}async findRandomPeers(t){if(this.allAddressesAreVerified())return;const e=Ne([AbortSignal.timeout(1e4),t==null?void 0:t.signal]);try{this.log("starting random walk to find peers to run AutoNAT");for await(const r of this.components.randomWalk.walk({signal:e})){if(!await this.components.connectionManager.isDialable(r.multiaddrs)){this.log.trace("random peer %p was not dialable %s",r.id,r.multiaddrs.map(s=>s.toString()).join(", "));continue}try{this.log.trace("dial random peer %p",r.id),await this.components.connectionManager.openConnection(r.multiaddrs,{signal:e})}catch{}if(this.allAddressesAreVerified()){this.log("stopping random walk, all addresses are verified");return}if(!this.hasConnectionCapacity()){this.log("stopping random walk, too close to max connections");return}}}catch{}}async handleIncomingAutonatStream(t){const e=AbortSignal.timeout(this.timeout),r=Wt(t.stream,{maxDataLength:this.maxMessageSize}).pb(Xe);try{const s=await r.read({signal:e}),i=await this.handleAutonatMessage(s,t.connection,{signal:e});await r.write(i,{signal:e}),await r.unwrap().unwrap().close({signal:e})}catch(s){this.log.error("error handling incoming autonat stream - %e",s),t.stream.abort(s)}}async handleAutonatMessage(t,e,r){const s=this.components.addressManager.getAddresses().map(d=>d.toOptions().host),i=t.dial;if(i==null)return this.log.error("dial was missing from message"),{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}};let o;const a=i.peer;if((a==null?void 0:a.id)==null)return this.log.error("PeerId missing from message"),{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}};try{const d=bt(a.id);o=pr(d)}catch(d){return this.log.error("invalid PeerId - %e",d),{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}}if(this.log("incoming request from %p",o),!e.remotePeer.equals(o))return this.log("target peer %p did not equal sending peer %p",o,e.remotePeer),{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}};const c=a.addrs.map(d=>fe(d)).filter(d=>{const f=d.toOptions();return gi(d)?!1:f.host!==e.remoteAddr.toOptions().host?(this.log.trace("not dialing %a - target host did not match remote host %a",d,e.remoteAddr),!1):s.includes(f.host)?!1:this.components.transportManager.dialTransportForMultiaddr(d)==null?(this.log.trace("not dialing %a - transport unsupported",d),!1):!0}).map(d=>(d.getPeerId()==null&&(d=d.encapsulate(`/p2p/${o.toString()}`)),d));if(c.length===0)return this.log("refused to dial all multiaddrs for %p from message",o),{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}};this.log("dial multiaddrs %s for peer %p",c.map(d=>d.toString()).join(", "),o);let l="",h=c[0];for await(const d of c){let f;h=d;try{if(f=await this.components.connectionManager.openConnection(d,r),!f.remoteAddr.equals(d))throw this.log.error("tried to dial %a but dialed %a",d,f.remoteAddr),new Error("Unexpected remote address");return this.log("successfully dialed %p via %a",o,d),{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.OK,addr:f.remoteAddr.decapsulateCode(ge("p2p").code).bytes}}}catch(g){this.log.error("could not dial %p - %e",o,g),l=g.message}finally{f!=null&&await f.close()}}return{type:Xe.MessageType.DIAL_RESPONSE,dialResponse:{status:Xe.ResponseStatus.E_DIAL_ERROR,statusText:l,addr:h.bytes}}}getFirstUnverifiedMultiaddr(t,e){var s,i;const r=this.components.addressManager.getAddressesWithMetadata().sort((o,a)=>o.type==="observed"&&a.type!=="observed"?1:a.type==="observed"&&o.type!=="observed"?-1:0).filter(o=>!(!(o.expires<Date.now())||o.multiaddr.toOptions().family===6&&(!e||!em(o.multiaddr))||gi(o.multiaddr)));for(const o of r){const a=o.multiaddr.toString();let c=this.dialResults.get(a);if(c!=null){if(c.networkSegments.includes(t)){this.log.trace("%a already has a network segment result from %s",c.multiaddr,t);continue}if(c.queue.size>10){this.log.trace("%a already has enough peers queued",c.multiaddr);continue}}if(c==null){const l=o.expires<Date.now();if(l&&((i=(s=this.addressFilter).remove)==null||i.call(s,a)),this.addressFilter.has(a))continue;this.addressFilter.add(a),this.log.trace("creating dial result %s %s",l?"to revalidate":"for",a),c={multiaddr:o.multiaddr,success:0,failure:0,networkSegments:[],verifyingPeers:RS(),queue:new ys({concurrency:3,maxSize:50}),type:o.type,lastVerified:o.lastVerified},this.dialResults.set(a,c)}return c}}removeOutdatedMultiaddrResults(){const t=new Set(this.components.addressManager.getAddressesWithMetadata().filter(({expires:e})=>e<Date.now()).map(({multiaddr:e})=>e.toString()));for(const e of this.dialResults.keys())t.has(e)||(this.log.trace("remove results for %a",e),this.dialResults.delete(e))}async verifyExternalAddresses(t){if(!this.isStarted())return;this.removeOutdatedMultiaddrResults();const r=(await this.components.peerStore.get(t.remotePeer)).addresses.some(({multiaddr:o})=>o.toOptions().family===6),s=this.getNetworkSegment(t.remoteAddr),i=this.getFirstUnverifiedMultiaddr(s,r);if(i==null){this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification",t.remotePeer);return}if(!this.hasConnectionCapacity()){i.lastVerified!=null?(this.log("automatically re-verifying %a because we are too close to the connection limit",i.multiaddr),this.confirmAddress(i)):this.log("skipping verifying %a because we are too close to the connection limit",i.multiaddr);return}i.queue.add(async o=>{await this.askPeerToVerify(t,s,o)},{peerId:t.remotePeer,multiaddr:i.multiaddr}).catch(o=>{(i==null?void 0:i.result)==null&&this.log.error("error from %p verifying address %a - %e",t.remotePeer,i==null?void 0:i.multiaddr,o)})}async askPeerToVerify(t,e,r){let s=this.dialResults.get(r.multiaddr.toString());if(s==null){this.log("%a was verified while %p was queued",r.multiaddr,t.remotePeer);return}const i=AbortSignal.timeout(this.timeout);this.log.trace("asking %p to verify multiaddr %s",t.remotePeer,r.multiaddr);const o=await t.newStream(this.protocol,{signal:i});try{const a=Wt(o).pb(Xe),[,c]=await Promise.all([a.write({type:Xe.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toMultihash().bytes,addrs:[r.multiaddr.bytes]}}},{signal:i}),a.read({signal:i})]);if(c.type!==Xe.MessageType.DIAL_RESPONSE||c.dialResponse==null){this.log("invalid autonat response from %p - %j",t.remotePeer,c);return}const l=c.dialResponse.status;if(this.log.trace("autonat response from %p for %a is %s",t.remotePeer,r.multiaddr,l),l!==Xe.ResponseStatus.OK&&l!==Xe.ResponseStatus.E_DIAL_ERROR)return;if(s=this.dialResults.get(r.multiaddr.toString()),s==null){this.log.trace("peer reported %a as %s but there is no result object",r.multiaddr,c.dialResponse.status);return}if(s.networkSegments.includes(e)){this.log.trace("%a results included network segment %s",r.multiaddr,e);return}if(s.result!=null){this.log.trace("already resolved result for %a, ignoring response from",r.multiaddr,t.remotePeer);return}if(s.verifyingPeers.has(t.remotePeer)){this.log.trace("peer %p has already verified %a, ignoring response",t.remotePeer,r.multiaddr);return}if(s.verifyingPeers.add(t.remotePeer),s.networkSegments.push(e),l===Xe.ResponseStatus.OK){if(s.success++,s.type!=="observed"){this.confirmAddress(s);return}}else l===Xe.ResponseStatus.E_DIAL_ERROR&&s.failure++;this.log("%a success %d failure %d",s.multiaddr,s.success,s.failure),s.success===zC&&this.confirmAddress(s),s.failure===VC&&this.unconfirmAddress(s)}finally{try{await o.close({signal:i})}catch(a){o.abort(a)}}}hasConnectionCapacity(){const e=this.components.connectionManager.getConnections().length,r=this.components.connectionManager.getMaxConnections();return e/r*100<this.connectionThreshold}confirmAddress(t){this.log("%s address %a is externally dialable",t.type,t.multiaddr),this.components.addressManager.confirmObservedAddr(t.multiaddr),this.dialResults.delete(t.multiaddr.toString()),t.result=!0,t.queue.abort()}unconfirmAddress(t){this.log("%s address %a is not externally dialable",t.type,t.multiaddr),this.components.addressManager.removeObservedAddr(t.multiaddr),this.dialResults.delete(t.multiaddr.toString()),t.result=!1,t.queue.abort()}getNetworkSegment(t){const e=t.toOptions();return e.family===4?e.host.split(".")[0].padStart(3,"0"):e.host.split(":")[0].padStart(4,"0")}}function qC(n={}){return t=>new HC(t,n)}const WC=ee("dns4"),KC=ee("dns6"),GC=ee("dnsaddr"),pi=mt(ee("dns"),GC,WC,KC),sh=mt(ee("ip4"),ee("ip6")),Bo=mt(le(sh,ee("tcp")),le(pi,ee("tcp"))),ih=le(sh,ee("udp")),QC=le(ih,ee("utp")),YC=le(ih,ee("quic")),XC=le(ih,ee("quic-v1")),v1=mt(le(Bo,ee("ws")),le(pi,ee("ws"))),eu=mt(le(v1,ee("p2p")),v1),E1=mt(le(Bo,ee("wss")),le(pi,ee("wss")),le(Bo,ee("tls"),ee("ws")),le(pi,ee("tls"),ee("ws"))),tu=mt(le(E1,ee("p2p")),E1),S1=mt(le(Bo,ee("http")),le(sh,ee("http")),le(pi,ee("http"))),x1=mt(le(Bo,ee("https")),le(sh,ee("https")),le(pi,ee("https"))),Hg=le(ih,ee("webrtc-direct"),ee("certhash")),rm=mt(le(Hg,ee("p2p")),Hg),qg=le(XC,ee("webtransport"),ee("certhash"),ee("certhash")),nm=mt(le(qg,ee("p2p")),qg),sm=mt(le(eu,ee("p2p-webrtc-star"),ee("p2p")),le(tu,ee("p2p-webrtc-star"),ee("p2p")),le(eu,ee("p2p-webrtc-star")),le(tu,ee("p2p-webrtc-star")));mt(le(eu,ee("p2p-websocket-star"),ee("p2p")),le(tu,ee("p2p-websocket-star"),ee("p2p")),le(eu,ee("p2p-websocket-star")),le(tu,ee("p2p-websocket-star")));const im=mt(le(S1,ee("p2p-webrtc-direct"),ee("p2p")),le(x1,ee("p2p-webrtc-direct"),ee("p2p")),le(S1,ee("p2p-webrtc-direct")),le(x1,ee("p2p-webrtc-direct"))),mi=mt(v1,E1,S1,x1,sm,im,Bo,QC,YC,pi,rm,nm);mt(le(mi,ee("p2p-stardust"),ee("p2p")),le(mi,ee("p2p-stardust")));const as=mt(le(mi,ee("p2p")),sm,im,rm,nm,ee("p2p")),Wg=mt(le(as,ee("p2p-circuit"),as),le(as,ee("p2p-circuit")),le(ee("p2p-circuit"),as),le(mi,ee("p2p-circuit")),le(ee("p2p-circuit"),mi),ee("p2p-circuit")),om=()=>mt(le(Wg,om),Wg),Hs=om(),ZC=mt(le(Hs,as,Hs),le(as,Hs),le(Hs,as),Hs,as);mt(le(Hs,ee("webrtc"),ee("p2p")),le(Hs,ee("webrtc")),le(mi,ee("webrtc"),ee("p2p")),le(mi,ee("webrtc")),ee("webrtc"));function am(n){function t(e){let r;try{r=fe(e)}catch{return!1}const s=n(r.protoNames());return s===null?!1:s===!0||s===!1?s:s.length===0}return t}function le(...n){function t(e){if(e.length<n.length)return null;let r=e;return n.some(s=>(r=typeof s=="function"?s().partialMatch(e):s.partialMatch(e),Array.isArray(r)&&(e=r),r===null)),r}return{toString:function(){return"{ "+n.join(" ")+" }"},input:n,matches:am(t),partialMatch:t}}function mt(...n){function t(r){let s=null;return n.some(i=>{const o=typeof i=="function"?i().partialMatch(r):i.partialMatch(r);return o!=null?(s=o,!0):!1}),s}return{toString:function(){return"{ "+n.join(" ")+" }"},input:n,matches:am(t),partialMatch:t}}function ee(n){const t=n;function e(s){let i;try{i=fe(s)}catch{return!1}const o=i.protoNames();return o.length===1&&o[0]===t}function r(s){return s.length===0?null:s[0]===t?s.slice(1):null}return{toString:function(){return t},matches:e,partialMatch:r}}const JC="bootstrap",jC=50,eP=1e3;var H3,q3,W3,K3;class cm extends(K3=Et,W3=El,q3=Symbol.toStringTag,H3=Pt,K3){constructor(e,r={list:[]}){if(r.list==null||r.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();u(this,"log");u(this,"timer");u(this,"list");u(this,"timeout");u(this,"components");u(this,"_init");u(this,W3,this);u(this,q3,"@libp2p/bootstrap");u(this,H3,["@libp2p/peer-discovery"]);this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=r.timeout??eP,this.list=[];for(const s of r.list){if(!ZC.matches(s)){this.log.error("Invalid multiaddr");continue}const i=fe(s),o=i.getPeerId();if(o==null){this.log.error("Invalid bootstrap multiaddr without peer id");continue}const a={id:ut(o),multiaddrs:[i]};this.list.push(a)}this._init=r}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error(e)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??JC]:{value:this._init.tagValue??jC,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(r=>{this.log.error("could not dial bootstrap peer %p",e.id,r)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}u(cm,"tag","bootstrap");function lm(n){return t=>new cm(t,n)}var ru;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(r.uint32(10),r.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(r.uint32(18),r.bytes(e.payloadType)),e.payload!=null&&e.payload.byteLength>0&&(r.uint32(26),r.bytes(e.payload)),e.signature!=null&&e.signature.byteLength>0&&(r.uint32(42),r.bytes(e.signature)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={publicKey:Ee(0),payloadType:Ee(0),payload:Ee(0),signature:Ee(0)},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=e.bytes();break}case 5:{i.signature=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(ru||(ru={}));class tP extends Error{constructor(t="Invalid signature"){super(t),this.name="InvalidSignatureError"}}const jn=class jn{constructor(t){u(this,"publicKey");u(this,"payloadType");u(this,"payload");u(this,"signature");u(this,"marshaled");const{publicKey:e,payloadType:r,payload:s,signature:i}=t;this.publicKey=e,this.payloadType=r,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=ru.encode({publicKey:Ur(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(t){return _e(this.marshal(),t.marshal())}async validate(t){const e=Kg(t,this.payloadType,this.payload);return this.publicKey.verify(e.subarray(),this.signature)}};u(jn,"createFromProtobuf",async t=>{const e=ru.decode(t),r=ir(e.publicKey);return new jn({publicKey:r,payloadType:e.payloadType,payload:e.payload,signature:e.signature})}),u(jn,"seal",async(t,e)=>{if(e==null)throw new Error("Missing private key");const r=t.domain,s=t.codec,i=t.marshal(),o=Kg(r,s,i),a=await e.sign(o.subarray());return new jn({publicKey:e.publicKey,payloadType:s,payload:i,signature:a})}),u(jn,"openAndCertify",async(t,e)=>{const r=await jn.createFromProtobuf(t);if(!await r.validate(e))throw new tP("Envelope signature is not valid for the given domain");return r});let Is=jn;const Kg=(n,t,e)=>{const r=Y(n),s=Lt(r.byteLength),i=Lt(t.length),o=Lt(e.length);return new ye(s,r,i,t,o,e)};function rP(n,t){const e=(r,s)=>r.toString().localeCompare(s.toString());return n.length!==t.length?!1:(t.sort(e),n.sort(e).every((r,s)=>t[s].equals(r)))}const nP="libp2p-peer-record",sP=Uint8Array.from([3,1]);var nu;(function(n){(function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:Ee(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)})(n.AddressInfo||(n.AddressInfo={}));let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.peerId!=null&&e.peerId.byteLength>0&&(r.uint32(10),r.bytes(e.peerId)),e.seq!=null&&e.seq!==0n&&(r.uint32(16),r.uint64(e.seq)),e.addresses!=null)for(const i of e.addresses)r.uint32(26),n.AddressInfo.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c;const i={peerId:Ee(0),seq:0n,addresses:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const l=e.uint32();switch(l>>>3){case 1:{i.peerId=e.bytes();break}case 2:{i.seq=e.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Fe('Decode error - map field "addresses" had too many elements');i.addresses.push(n.AddressInfo.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{e.skipType(l&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(nu||(nu={}));const In=class In{constructor(t){u(this,"peerId");u(this,"multiaddrs");u(this,"seqNumber");u(this,"domain",In.DOMAIN);u(this,"codec",In.CODEC);u(this,"marshaled");const{peerId:e,multiaddrs:r,seqNumber:s}=t;this.peerId=e,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=nu.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(t=>({multiaddr:t.bytes}))})),this.marshaled}equals(t){return!(!(t instanceof In)||!this.peerId.equals(t.peerId)||this.seqNumber!==t.seqNumber||!rP(this.multiaddrs,t.multiaddrs))}};u(In,"createFromProtobuf",t=>{const e=nu.decode(t),r=pr(bt(e.peerId)),s=(e.addresses??[]).map(o=>fe(o.multiaddr)),i=e.seq;return new In({peerId:r,multiaddrs:s,seqNumber:i})}),u(In,"DOMAIN",nP),u(In,"CODEC",sP);let dn=In;const iP=290,oP=1,um=2e3,aP=100,Hc=`${Iu}-circuit-relay`;BigInt(1<<17);const su="/libp2p/circuit/relay/0.2.0/hop",Gg="/libp2p/circuit/relay/0.2.0/stop",Qg=300,cP=4096,lP=.001;var Mo;(function(n){(function(r){r.RESERVE="RESERVE",r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let t;(function(r){r[r.RESERVE=0]="RESERVE",r[r.CONNECT=1]="CONNECT",r[r.STATUS=2]="STATUS"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.Type||(n.Type={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),No.codec().encode(r.peer,s)),r.reservation!=null&&(s.uint32(26),iu.codec().encode(r.reservation,s)),r.limit!=null&&(s.uint32(34),Lo.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(40),$t.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{var c,l,h;const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const d=r.uint32();switch(d>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=No.codec().decode(r,r.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.reservation=iu.codec().decode(r,r.uint32(),{limits:(l=i.limits)==null?void 0:l.reservation});break}case 4:{o.limit=Lo.codec().decode(r,r.uint32(),{limits:(h=i.limits)==null?void 0:h.limit});break}case 5:{o.status=$t.codec().decode(r);break}default:{r.skipType(d&7);break}}}return o})),e),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>ue(r,n.codec(),s)})(Mo||(Mo={}));var kn;(function(n){(function(r){r.CONNECT="CONNECT",r.STATUS="STATUS"})(n.Type||(n.Type={}));let t;(function(r){r[r.CONNECT=0]="CONNECT",r[r.STATUS=1]="STATUS"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.Type||(n.Type={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.peer!=null&&(s.uint32(18),No.codec().encode(r.peer,s)),r.limit!=null&&(s.uint32(26),Lo.codec().encode(r.limit,s)),r.status!=null&&(s.uint32(32),$t.codec().encode(r.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{var c,l;const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const h=r.uint32();switch(h>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.peer=No.codec().decode(r,r.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.limit=Lo.codec().decode(r,r.uint32(),{limits:(l=i.limits)==null?void 0:l.limit});break}case 4:{o.status=$t.codec().decode(r);break}default:{r.skipType(h&7);break}}}return o})),e),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>ue(r,n.codec(),s)})(kn||(kn={}));var No;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.id!=null&&e.id.byteLength>0&&(r.uint32(10),r.bytes(e.id)),e.addrs!=null)for(const i of e.addrs)r.uint32(18),r.bytes(i);s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a;const i={id:Ee(0),addrs:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.id=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new Fe('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}default:{e.skipType(c&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(No||(No={}));var iu;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.expire!=null&&e.expire!==0n&&(r.uint32(8),r.uint64(e.expire)),e.addrs!=null)for(const i of e.addrs)r.uint32(18),r.bytes(i);e.voucher!=null&&(r.uint32(26),au.codec().encode(e.voucher,r)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c;const i={expire:0n,addrs:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const l=e.uint32();switch(l>>>3){case 1:{i.expire=e.uint64();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new Fe('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}case 3:{i.voucher=au.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.voucher});break}default:{e.skipType(l&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(iu||(iu={}));var Lo;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.duration!=null&&(r.uint32(8),r.uint32(e.duration)),e.data!=null&&(r.uint32(16),r.uint64(e.data)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.duration=e.uint32();break}case 2:{i.data=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Lo||(Lo={}));var $t;(function(n){n.UNUSED="UNUSED",n.OK="OK",n.RESERVATION_REFUSED="RESERVATION_REFUSED",n.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",n.PERMISSION_DENIED="PERMISSION_DENIED",n.CONNECTION_FAILED="CONNECTION_FAILED",n.NO_RESERVATION="NO_RESERVATION",n.MALFORMED_MESSAGE="MALFORMED_MESSAGE",n.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})($t||($t={}));var _1;(function(n){n[n.UNUSED=0]="UNUSED",n[n.OK=100]="OK",n[n.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",n[n.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",n[n.PERMISSION_DENIED=202]="PERMISSION_DENIED",n[n.CONNECTION_FAILED=203]="CONNECTION_FAILED",n[n.NO_RESERVATION=204]="NO_RESERVATION",n[n.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",n[n.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(_1||(_1={}));(function(n){n.codec=()=>Ht(_1)})($t||($t={}));var ou;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.relay!=null&&e.relay.byteLength>0&&(r.uint32(10),r.bytes(e.relay)),e.peer!=null&&e.peer.byteLength>0&&(r.uint32(18),r.bytes(e.peer)),e.expiration!=null&&e.expiration!==0n&&(r.uint32(24),r.uint64(e.expiration)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={relay:Ee(0),peer:Ee(0),expiration:0n},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.relay=e.bytes();break}case 2:{i.peer=e.bytes();break}case 3:{i.expiration=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(ou||(ou={}));var au;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(r.uint32(10),r.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(r.uint32(18),r.bytes(e.payloadType)),e.payload!=null&&(r.uint32(26),ou.codec().encode(e.payload,r)),e.signature!=null&&e.signature.byteLength>0&&(r.uint32(42),r.bytes(e.signature)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a;const i={publicKey:Ee(0),payloadType:Ee(0),signature:Ee(0)},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=ou.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.payload});break}case 5:{i.signature=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(au||(au={}));class k1 extends Error{constructor(){super(...arguments);u(this,"name","HadEnoughRelaysError")}}u(k1,"name","HadEnoughRelaysError");class hm extends Error{constructor(){super(...arguments);u(this,"name","DoubleRelayError")}}u(hm,"name","DoubleRelayError");class dm extends Error{constructor(){super(...arguments);u(this,"name","RelayQueueFullError")}}u(dm,"name","RelayQueueFullError");function Yg(n){const t=n*BigInt(1e3),e=new Date().getTime();return Number(t-BigInt(e))}class Xg{constructor(t){u(this,"expires");u(this,"bytes");(t==null?void 0:t.duration)!=null&&(t==null?void 0:t.duration)!==0&&(this.expires=Date.now()+t.duration*1e3),this.bytes=t==null?void 0:t.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(t){this.bytes!=null&&(this.bytes-=BigInt(t.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const t={};if(this.bytes!=null){const e=this;Object.defineProperty(t,"bytes",{get(){return e.bytes}})}if(this.expires!=null){const e=this;Object.defineProperty(t,"seconds",{get(){return Math.round(((e.expires??0)-Date.now())/1e3)}})}return t}}const fm=Qe(xe(a8.matchers[0],Se("p2p-circuit"))),gm=Qe(Se("p2p-circuit"));function Zg(n){const{stream:t,remoteAddr:e,logger:r,onDataRead:s,onDataWrite:i}=n,o=r.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=t.close.bind(t);t.close=async y=>{await l(y),g(!0)};const h=t.abort.bind(t);t.abort=y=>{h(y),g(!0)};const d=t.sink.bind(t);t.sink=async y=>{try{await d(It(y,p=>ql(p,w=>i==null?void 0:i(w))))}catch(p){p.type!=="aborted"&&o.error("%s error in sink",e,p)}finally{c=!0,g()}};const f={log:o,sink:t.sink,source:async function*(){try{for await(const y of t.source)s==null||s(y),yield y}finally{a=!0,g()}}(),remoteAddr:e,timeline:{open:Date.now(),close:void 0},close:t.close,abort:t.abort};function g(y){y===!0&&(a=!0,c=!0),a&&c&&f.timeline.close==null&&(f.timeline.close=Date.now())}return f}class uP extends Et{constructor(e,r={}){super();u(this,"peerStore");u(this,"registrar");u(this,"connectionManager");u(this,"randomWalk");u(this,"started");u(this,"running");u(this,"topologyId");u(this,"log");u(this,"discoveryController");u(this,"filter");u(this,"queue");this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=r.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(su,{filter:this.filter,onConnect:e=>{var r,s;this.log.trace("discovered relay %p queue (length: %d, active %d)",e,(r=this.queue)==null?void 0:r.size,(s=this.queue)==null?void 0:s.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){var e;this.topologyId!=null&&this.registrar.unregister(this.topologyId),(e=this.discoveryController)==null||e.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{var s;this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[i=>i.protocols.includes(su)],orders:[()=>Math.random()<.5?1:-1,(i,o)=>{const a=Jg(i),c=Jg(o);return a>c?-1:c>a?1:0}]});for(const i of e)this.log.trace("found relay peer %p in peer store",i.id),this.safeDispatchEvent("relay:discover",{detail:i.id});this.log("found %d relay peers in peer store",e.length);const r=this.queue=new ys({concurrency:5});this.log("start random walk");for await(const i of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",i.id),r.has(i.id)){this.log.trace("random peer %p was already in queue",i.id);continue}if(((s=this.connectionManager.getConnections(i.id))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",i.id);continue}if(!await this.connectionManager.isDialable(i.multiaddrs)){this.log.trace("random peer %p was not dialable",i.id,i.multiaddrs.map(o=>o.toString()));continue}r.queued>10&&(this.log.trace("wait for space in queue for %p",i.id),await r.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",i.id,r.size,r.running),r.add(async()=>{const o=Ne([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(i.id,{signal:o})}finally{o.clear()}},{peerId:i.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p",i.id,o)})}this.log("stop random walk"),await r.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){var e;this.log("stop discovery"),this.running=!1,(e=this.discoveryController)==null||e.abort()}}function Jg(n){const t=n.metadata.get("last-dial-success");return t==null?0:new Date(Z(t)).getTime()}class hP extends Et{constructor(e,r={}){super();u(this,"connectionManager");u(this,"addressManager");u(this,"reservationStore");u(this,"listeningAddrs");u(this,"log");u(this,"listenTimeout");u(this,"reservationId");u(this,"relay");u(this,"_onRemoveRelayPeer",e=>{var r,s;this.log("relay removed %p our relay %p",e.detail.relay,this.relay,(r=this.relay)==null?void 0:r.equals(e.detail.relay)),((s=this.relay)==null?void 0:s.equals(e.detail.relay))===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(i=>{this.addressManager.removeObservedAddr(i)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});u(this,"_onAddRelayPeer",e=>{const{details:r}=e.detail;r.type!=="configured"&&r.id===this.reservationId&&this.addedRelay(e.detail)});this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=r.listenTimeout??um,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(e){if(gm.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(fm.exactMatch(e)){this.log("listen on specific relay server %a",e);const r=AbortSignal.timeout(this.listenTimeout),s=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(s,{signal:r});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const o=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(o)}}else throw new _l(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(r=>fe(r).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(r=>{this.addressManager.confirmObservedAddr(r,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function dP(n){return new hP(n)}const fP="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let gP=(n=21)=>{let t="",e=crypto.getRandomValues(new Uint8Array(n|=0));for(;n--;)t+=fP[e[n]&63];return t};const pP=60*1e3*10,mP=60*1e3*5,yP=30*1e3;var rr,pm,ma,ya;class wP extends Et{constructor(e,r){super();ve(this,rr);u(this,"peerId");u(this,"connectionManager");u(this,"peerStore");u(this,"events");u(this,"reserveQueue");u(this,"reservations");u(this,"pendingReservations");u(this,"maxReservationQueueLength");u(this,"reservationCompletionTimeout");u(this,"started");u(this,"log");u(this,"relayFilter");this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Ps,this.pendingReservations=[],this.maxReservationQueueLength=(r==null?void 0:r.maxReservationQueueLength)??aP,this.reservationCompletionTimeout=(r==null?void 0:r.reservationCompletionTimeout)??um,this.started=!1,this.relayFilter=hi(100),this.reserveQueue=new ys({concurrency:(r==null?void 0:r.reservationConcurrency)??oP,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",s=>{[...this.reservations.values()].find(o=>o.connection===s.detail.id)!=null&&ie(this,rr,ma).call(this,s.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",s.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[r=>r.tags.has(Hc)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async r=>{await this.peerStore.merge(r.id,{tags:{[Hc]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async r=>this.addRelay(r.id,"discovered"))),ie(this,rr,ya).call(this)}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=gP();return this.pendingReservations.push(e),ie(this,rr,ya).call(this),e}async addRelay(e,r){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new _l("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new dm("The reservation queue is full");const s=this.reserveQueue.find(e);if(s!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),s.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new _l("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const o=this.reservations.get(e);if(o!=null){const p=this.connectionManager.getConnections(e);let w=!1;if(p.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),p.map(v=>v.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),w=!0),w&&Yg(o.reservation.expire)>pP)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:o};await ie(this,rr,ma).call(this,e)}if(r==="discovered"&&this.pendingReservations.length===0)throw new k1("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(e,{signal:a});if(_s.matches(c.remoteAddr))throw new hm("not creating reservation over relayed connection");const l=await ie(this,rr,pm).call(this,c,{signal:a}),h=Yg(l.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+h).toString());const d=Math.min(Math.max(h-mP,yP),Math.pow(2,31)-1),f=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,r).catch(async p=>{this.log.error("could not refresh reservation to relay %p - %e",e,p),await ie(this,rr,ma).call(this,e)}).catch(p=>{this.log.error("could not remove expired reservation to relay %p - %e",e,p)})},d);let g;if(r==="discovered"){const p=this.pendingReservations.pop();if(p==null)throw new k1("Made reservation on relay but did not need any more discovered relays");g={timeout:f,reservation:l,type:r,connection:c.id,id:p}}else g={timeout:f,reservation:l,type:r,connection:c.id};this.reservations.set(e,g),await this.peerStore.merge(e,{tags:{[Hc]:{value:1,ttl:h}}}),ie(this,rr,ya).call(this);const y={relay:e,details:g};return this.safeDispatchEvent("relay:created-reservation",{detail:y}),y}catch(o){throw r==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),ie(this,rr,ma).call(this,e).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,a)}),o}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){var r;return(r=this.reservations.get(e))==null?void 0:r.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((r,s)=>(s.type===e&&r++,r),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}}rr=new WeakSet,pm=async function(e,r){var l;(l=r.signal)==null||l.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const s=await e.newStream(su,r),o=Wt(s).pb(Mo);this.log.trace("send RESERVE to %p",e.remotePeer),await o.write({type:Mo.Type.RESERVE},r);let a;try{this.log.trace("reading response from %p",e.remotePeer),a=await o.read(r)}catch(h){throw s.abort(h),h}finally{s.status!=="closed"&&await s.close(r)}if(this.log.trace("read response %o",a),a.status===$t.OK&&a.reservation!=null){const h=new Set;h.add(e.remoteAddr.toString());for(const d of a.reservation.addrs){let f=fe(d);f.getPeerId()==null&&(f=f.encapsulate(`/p2p/${e.remotePeer}`)),f=fe(f.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),h.add(f.toString())}return a.reservation.addrs=[...h].map(d=>fe(d).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},ma=async function(e){const r=this.reservations.get(e);r!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(r.timeout),this.reservations.delete(e),r.type==="discovered"&&this.pendingReservations.push(r.id),await this.peerStore.merge(e,{tags:{[Hc]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:r}}),ie(this,rr,ya).call(this))},ya=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=hi(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};const bP=n=>{if(n.peer==null)return!1;try{n.peer.addrs.forEach(fe)}catch{return!1}return!0},jg={maxInboundStopStreams:Qg,maxOutboundStopStreams:Qg};var G3,Q3,Y3,X3;class vP{constructor(t,e={}){u(this,"discovery");u(this,"registrar");u(this,"peerStore");u(this,"connectionManager");u(this,"transportManager");u(this,"peerId");u(this,"upgrader");u(this,"addressManager");u(this,"connectionGater");u(this,"reservationStore");u(this,"logger");u(this,"maxInboundStopStreams");u(this,"maxOutboundStopStreams");u(this,"started");u(this,"log");u(this,"shutdownController");u(this,X3,"@libp2p/circuit-relay-v2-transport");u(this,Y3,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);u(this,G3,!0);this.log=t.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=t.registrar,this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.transportManager=t.transportManager,this.logger=t.logger,this.peerId=t.peerId,this.upgrader=t.upgrader,this.addressManager=t.addressManager,this.connectionGater=t.connectionGater,this.maxInboundStopStreams=e.maxInboundStopStreams??jg.maxInboundStopStreams,this.maxOutboundStopStreams=e.maxOutboundStopStreams??jg.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new uP(t,{filter:e.discoveryFilter??WS(cP,lP)}),this.discovery.addEventListener("relay:discover",r=>{this.reservationStore.addRelay(r.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",r.detail,s)})}),this.reservationStore=new wP(t,e),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var r;(r=this.discovery)==null||r.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var r;(r=this.discovery)==null||r.stopDiscovery()}),this.started=!1}get[(X3=Symbol.toStringTag,Y3=Pt,Q3=ms,G3=Au,Q3)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,await this.registrar.handle(Gg,t=>{const e=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(t,e).catch(r=>{this.log.error("error while handling STOP protocol",r),t.stream.abort(r)}).finally(()=>{e.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Ln(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Cs(this.discovery,this.reservationStore),await this.registrar.unhandle(Gg),this.started=!1}async dial(t,e){var g,y,p,w,v,x;if(t.protoCodes().filter(S=>S===iP).length!==1){const S="Invalid circuit relay address";throw this.log.error(S,t),new eo(S)}const r=t.toString().split("/p2p-circuit"),s=fe(r[0]),i=fe(r[r.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const S=`ircuit relay dial to ${t.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${S}`),new eo(`C${S}`)}const c=ut(o),l=ut(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),(g=e.onProgress)==null||g.call(e,new se("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,e)):(y=e.onProgress)==null||y.call(e,new se("circuit-relay:reuse-connection"));let f;try{(p=e.onProgress)==null||p.call(e,new se("circuit-relay:open-hop-stream")),f=await d.newStream(su,e);const S=Wt(f),I=S.pb(Mo);(w=e.onProgress)==null||w.call(e,new se("circuit-relay:write-connect-message")),await I.write({type:Mo.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[fe(i).bytes]}},e),(v=e.onProgress)==null||v.call(e,new se("circuit-relay:read-connect-response"));const P=await I.read(e);if(P.status!==$t.OK)throw new We(`failed to connect via relay with status ${((x=P==null?void 0:P.status)==null?void 0:x.toString())??"undefined"}`);const A=new Xg(P.limit),C=Zg({stream:S.unwrap(),remoteAddr:t,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:A.onData,onDataWrite:A.onData});return this.log("new outbound relayed connection %a",C.remoteAddr),await this.upgrader.upgradeOutbound(C,{...e,limits:A.getLimits()})}catch(S){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,S),f==null||f.abort(S),S}}createListener(t){return dP({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>fm.exactMatch(e)||gm.exactMatch(e))}dialFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>_s.exactMatch(e))}async onStop({connection:t,stream:e},r){var h,d;if(!this.reservationStore.hasReservation(t.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([t.remoteAddr.encapsulate("/p2p-circuit")])}catch(f){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",f)}const s=Wt(e).pb(kn),i=await s.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",t.remotePeer,i.type),(i==null?void 0:i.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",t.remotePeer),await s.write({type:kn.Type.STATUS,status:$t.MALFORMED_MESSAGE},{signal:r}),await e.close();return}if(i.type!==kn.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",t.remotePeer),await s.write({type:kn.Type.STATUS,status:$t.UNEXPECTED_MESSAGE},{signal:r}),await e.close();return}if(!bP(i)){this.log.error("invalid stop connect request via peer %p",t.remotePeer),await s.write({type:kn.Type.STATUS,status:$t.MALFORMED_MESSAGE},{signal:r}),await e.close({signal:r});return}const o=pr(bt(i.peer.id));if(await((d=(h=this.connectionGater).denyInboundRelayedConnection)==null?void 0:d.call(h,t.remotePeer,o))===!0){this.log.error("connection gater denied inbound relayed connection from %p",t.remotePeer),await s.write({type:kn.Type.STATUS,status:$t.PERMISSION_DENIED},{signal:r}),await e.close({signal:r});return}this.log.trace("sending success response to %p",t.remotePeer),await s.write({type:kn.Type.STATUS,status:$t.OK},{signal:r});const a=new Xg(i.limit),c=t.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=Zg({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:r}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function EP(n={}){return t=>new vP(t,n)}const ep=()=>{const n=new Error("Delay aborted");return n.name="AbortError",n},SP=new WeakMap;function xP({clearTimeout:n,setTimeout:t}={}){return(e,{value:r,signal:s}={})=>{if(s!=null&&s.aborted)return Promise.reject(ep());let i,o,a;const c=n??clearTimeout,l=()=>{c(i),a(ep())},h=()=>{s&&s.removeEventListener("abort",l)},d=new Promise((f,g)=>{o=()=>{h(),f(r)},a=g,i=(t??setTimeout)(o,e)});return s&&s.addEventListener("abort",l,{once:!0}),SP.set(d,()=>{c(i),i=null,o()}),d}}const mm=xP();var tn;(function(n){(function(r){r.UNUSED="UNUSED",r.CONNECT="CONNECT",r.SYNC="SYNC"})(n.Type||(n.Type={}));let t;(function(r){r[r.UNUSED=0]="UNUSED",r[r.CONNECT=100]="CONNECT",r[r.SYNC=300]="SYNC"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.Type||(n.Type={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{if(i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.observedAddresses!=null)for(const o of r.observedAddresses)s.uint32(18),s.bytes(o);i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{var c;const o={observedAddresses:[]},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const l=r.uint32();switch(l>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{if(((c=i.limits)==null?void 0:c.observedAddresses)!=null&&o.observedAddresses.length===i.limits.observedAddresses)throw new Fe('Decode error - map field "observedAddresses" had too many elements');o.observedAddresses.push(r.bytes());break}default:{r.skipType(l&7);break}}}return o})),e),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>ue(r,n.codec(),s)})(tn||(tn={}));function tp(n,t){return _s.matches(n)||t.dialTransportForMultiaddr(n)==null?!1:e8.matches(n)?!0:PI.matches(n)?Ds(n.toOptions().host)===!1:!1}const rp=1024*4,np=100,qc={timeout:5e3,retries:3,maxInboundStreams:1,maxOutboundStreams:1};var Z3,J3;J3=Symbol.toStringTag,Z3=ms;class _P{constructor(t,e){u(this,"started");u(this,"timeout");u(this,"retries");u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"peerStore");u(this,"registrar");u(this,"connectionManager");u(this,"addressManager");u(this,"transportManager");u(this,"topologyId");u(this,"log");u(this,J3,"@libp2p/dcutr");u(this,Z3,["@libp2p/identify"]);this.log=t.logger.forComponent("libp2p:dcutr"),this.started=!1,this.peerStore=t.peerStore,this.registrar=t.registrar,this.addressManager=t.addressManager,this.connectionManager=t.connectionManager,this.transportManager=t.transportManager,this.timeout=e.timeout??qc.timeout,this.retries=e.retries??qc.retries,this.maxInboundStreams=e.maxInboundStreams??qc.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams??qc.maxOutboundStreams}isStarted(){return this.started}async start(){this.started||(this.topologyId=await this.registrar.register(Wc,{notifyOnLimitedConnection:!0,onConnect:(t,e)=>{_s.exactMatch(e.remoteAddr)&&e.direction==="inbound"&&this.upgradeInbound(e).catch(r=>{this.log.error("error during outgoing DCUtR attempt",r)})}}),await this.registrar.handle(Wc,t=>{this.handleIncomingUpgrade(t.stream,t.connection).catch(e=>{this.log.error("error during incoming DCUtR attempt",e),t.stream.abort(e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){await this.registrar.unhandle(Wc),this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async upgradeInbound(t){if(await this.attemptUnilateralConnectionUpgrade(t))return;let e;for(let r=0;r<this.retries;r++){const s={signal:AbortSignal.timeout(this.timeout)};try{e=await t.newStream([Wc],{signal:s.signal,runOnLimitedConnection:!0});const i=Wt(e,{maxDataLength:rp}).pb(tn);this.log("B sending connect to %p",t.remotePeer);const o=Date.now();await i.write({type:tn.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(d=>d.bytes)},s),this.log("B receiving connect from %p",t.remotePeer);const a=await i.read(s);if(a.type!==tn.Type.CONNECT)throw this.log("A sent wrong message type"),new We("DCUtR message type was incorrect");const c=this.getDialableMultiaddrs(a.observedAddresses);if(c.length===0)throw this.log("A did not have any dialable multiaddrs"),new We("DCUtR connect message had no multiaddrs");const l=Date.now()-o;this.log("A sending sync, rtt %dms",l),await i.write({type:tn.Type.SYNC,observedAddresses:[]},s),this.log("A waiting for half RTT"),await mm(l/2),this.log("B dialing",c);const h=await this.connectionManager.openConnection(c,{signal:s.signal,priority:np,force:!0,initiator:!1});this.log("DCUtR to %p succeeded to address %a, closing relayed connection",t.remotePeer,h.remoteAddr),await t.close(s);break}catch(i){if(this.log.error("error while attempting DCUtR on attempt %d of %d",r+1,this.retries,i),e==null||e.abort(i),r===this.retries)throw i}finally{e!=null&&await e.close(s)}}}async attemptUnilateralConnectionUpgrade(t){const r=(await this.peerStore.get(t.remotePeer)).addresses.map(s=>{const i=s.multiaddr;return i.getPeerId()==null?i.encapsulate(`/p2p/${t.remotePeer}`):i}).filter(s=>tp(s,this.transportManager));if(r.length>0){const s=AbortSignal.timeout(this.timeout);try{this.log("attempting unilateral connection upgrade to %a",r);const i=await this.connectionManager.openConnection(r,{signal:s,force:!0});if(_s.exactMatch(i.remoteAddr))throw new Error("Could not open a new, non-limited, connection");return this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection",t.remotePeer,i.remoteAddr),await t.close({signal:s}),!0}catch(i){this.log.error("unilateral connection upgrade to %p on addresses %a failed",t.remotePeer,r,i)}}else this.log("peer %p has no public addresses, not attempting unilateral connection upgrade",t.remotePeer);return!1}async handleIncomingUpgrade(t,e){const r={signal:AbortSignal.timeout(this.timeout)};try{const s=Wt(t,{maxDataLength:rp}).pb(tn);this.log("A receiving connect");const i=await s.read(r);if(i.type!==tn.Type.CONNECT)throw this.log("B sent wrong message type"),new We("DCUtR message type was incorrect");if(i.observedAddresses.length===0)throw this.log("B sent no multiaddrs"),new We("DCUtR connect message had no multiaddrs");const o=this.getDialableMultiaddrs(i.observedAddresses);if(o.length===0)throw this.log("B had no dialable multiaddrs"),new We("DCUtR connect message had no dialable multiaddrs");if(this.log("A sending connect"),await s.write({type:tn.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(l=>l.bytes)}),this.log("A receiving sync"),(await s.read(r)).type!==tn.Type.SYNC)throw new We("DCUtR message type was incorrect");this.log("A dialing",o);const c=await this.connectionManager.openConnection(o,{signal:r.signal,priority:np,force:!0});this.log("DCUtR to %p succeeded via %a, closing relayed connection",e.remotePeer,c.remoteAddr),await e.close(r)}catch(s){this.log.error("incoming DCUtR from %p failed",e.remotePeer,s),t.abort(s)}finally{await t.close(r)}}getDialableMultiaddrs(t){const e=[];for(const r of t)if(!(r==null||r.length===0))try{const s=fe(r);if(!tp(s,this.transportManager))continue;e.push(s)}catch{}return e}}const Wc="/libp2p/dcutr";function kP(n={}){return t=>new _P(t,n)}const Kc=globalThis.CustomEvent??Event;async function*Rs(n,t={}){let e=t.concurrency??1/0;e<1&&(e=1/0);const r=t.ordered??!1,s=new EventTarget,i=[];let o=me(),a=me(),c=!1,l,h=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const y of n){if(i.length===e&&(o=me(),await o.promise),h)break;const p={done:!1};i.push(p),y().then(w=>{p.done=!0,p.ok=!0,p.value=w,s.dispatchEvent(new Kc("task-complete"))},w=>{p.done=!0,p.err=w,s.dispatchEvent(new Kc("task-complete"))})}c=!0,s.dispatchEvent(new Kc("task-complete"))}catch(y){l=y,s.dispatchEvent(new Kc("task-complete"))}});function d(){var y;return r?(y=i[0])==null?void 0:y.done:!!i.find(p=>p.done)}function*f(){for(;i.length>0&&i[0].done;){const y=i[0];if(i.shift(),y.ok)yield y.value;else throw h=!0,o.resolve(),y.err;o.resolve()}}function*g(){for(;d();)for(let y=0;y<i.length;y++)if(i[y].done){const p=i[y];if(i.splice(y,1),y--,p.ok)yield p.value;else throw h=!0,o.resolve(),p.err;o.resolve()}}for(;;){if(d()||(a=me(),await a.promise),l!=null)throw l;if(r?yield*f():yield*g(),c&&i.length===0)break}}const IP="0.1.0",AP="id",TP="id/push",CP="1.0.0",PP="1.0.0",DP=1024*8,RP=32;var Oo;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.protocolVersion!=null&&(r.uint32(42),r.string(e.protocolVersion)),e.agentVersion!=null&&(r.uint32(50),r.string(e.agentVersion)),e.publicKey!=null&&(r.uint32(10),r.bytes(e.publicKey)),e.listenAddrs!=null)for(const i of e.listenAddrs)r.uint32(18),r.bytes(i);if(e.observedAddr!=null&&(r.uint32(34),r.bytes(e.observedAddr)),e.protocols!=null)for(const i of e.protocols)r.uint32(26),r.string(i);e.signedPeerRecord!=null&&(r.uint32(66),r.bytes(e.signedPeerRecord)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c;const i={listenAddrs:[],protocols:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const l=e.uint32();switch(l>>>3){case 5:{i.protocolVersion=e.string();break}case 6:{i.agentVersion=e.string();break}case 1:{i.publicKey=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.listenAddrs)!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new Fe('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(e.bytes());break}case 4:{i.observedAddr=e.bytes();break}case 3:{if(((c=s.limits)==null?void 0:c.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Fe('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 8:{i.signedPeerRecord=e.bytes();break}default:{e.skipType(l&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Oo||(Oo={}));const Sr={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:DP,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:RP};function BP(n){if(n!=null&&n.length>0)try{return fe(n)}catch{}}function MP(n,t){return t??n.userAgent}async function ym(n,t,e,r,s){if(e("received identify from %p",r.remotePeer),s==null)throw new We("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:fe(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=ir(s.publicKey);if(!ko(c).equals(r.remotePeer))throw new We("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){e.trace("received signedPeerRecord from %p",r.remotePeer);let c=s.signedPeerRecord;const l=await Is.openAndCertify(c,dn.DOMAIN);let h=dn.createFromProtobuf(l.payload);const d=qo(l.publicKey.toCID());if(!h.peerId.equals(d))throw new We("signing key does not match PeerId in the PeerRecord");if(!r.remotePeer.equals(h.peerId))throw new We("signing key does not match remote PeerId");let f;try{f=await n.get(h.peerId)}catch(g){if(g.name!=="NotFoundError")throw g}if(f!=null&&(i.metadata=f.metadata,f.peerRecordEnvelope!=null)){const g=await Is.createFromProtobuf(f.peerRecordEnvelope),y=dn.createFromProtobuf(g.payload);y.seqNumber>=h.seqNumber&&(e("sequence number was lower or equal to existing sequence number - stored: %d received: %d",y.seqNumber,h.seqNumber),h=y,c=f.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=h.multiaddrs.map(g=>({isCertified:!0,multiaddr:g})),o={seq:h.seqNumber,addresses:h.multiaddrs}}else e("%p did not send a signed peer record",r.remotePeer);if(e.trace("patching %p with",r.remotePeer,i),await n.patch(r.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=Y(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=Y(s.protocolVersion)),e.trace("merging %p metadata",r.remotePeer,c),await n.merge(r.remotePeer,{metadata:c})}const a={peerId:r.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>fe(c)),observedAddr:s.observedAddr==null?void 0:fe(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:r};return t.safeDispatchEvent("peer:identify",{detail:a}),a}class wm{constructor(t,e){u(this,"host");u(this,"protocol");u(this,"started");u(this,"timeout");u(this,"peerId");u(this,"privateKey");u(this,"peerStore");u(this,"registrar");u(this,"addressManager");u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"maxMessageSize");u(this,"maxObservedAddresses");u(this,"events");u(this,"runOnLimitedConnection");u(this,"log");this.protocol=e.protocol,this.started=!1,this.peerId=t.peerId,this.privateKey=t.privateKey,this.peerStore=t.peerStore,this.registrar=t.registrar,this.addressManager=t.addressManager,this.events=t.events,this.log=e.log,this.timeout=e.timeout??Sr.timeout,this.maxInboundStreams=e.maxInboundStreams??Sr.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams??Sr.maxOutboundStreams,this.maxMessageSize=e.maxMessageSize??Sr.maxMessageSize,this.maxObservedAddresses=e.maxObservedAddresses??Sr.maxObservedAddresses,this.runOnLimitedConnection=e.runOnLimitedConnection??Sr.runOnLimitedConnection,this.host={protocolVersion:`${e.protocolPrefix??Sr.protocolPrefix}/${IP}`,agentVersion:MP(t.nodeInfo,e.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:Y(this.host.agentVersion),ProtocolVersion:Y(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,t=>{this.handleProtocol(t).catch(e=>{this.log.error(e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}var j3,e4;class NP extends(e4=wm,j3=Pt,e4){constructor(e,r={}){super(e,{...r,protocol:`/${r.protocolPrefix??Sr.protocolPrefix}/${TP}/${PP}`,log:e.logger.forComponent("libp2p:identify-push")});u(this,"connectionManager");u(this,"concurrency");u(this,j3,["@libp2p/identify-push"]);this.connectionManager=e.connectionManager,this.concurrency=r.concurrency??Sr.concurrency,(r.runOnSelfUpdate??Sr.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",s=>{this.push().catch(i=>{this.log.error(i)})})}async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(d=>d.decapsulateCode(ge("p2p").code)),r=new dn({peerId:this.peerId,multiaddrs:e}),s=await Is.seal(r,this.privateKey),i=this.registrar.getProtocols(),o=await this.peerStore.get(this.peerId),a=Z(o.metadata.get("AgentVersion")??Y(this.host.agentVersion)),c=Z(o.metadata.get("ProtocolVersion")??Y(this.host.protocolVersion)),l=this;async function*h(){for(const d of l.connectionManager.getConnections())(await l.peerStore.get(d.remotePeer)).protocols.includes(l.protocol)&&(yield async()=>{let g;const y=AbortSignal.timeout(l.timeout);try{g=await d.newStream(l.protocol,{signal:y,runOnLimitedConnection:l.runOnLimitedConnection}),await Wt(g,{maxDataLength:l.maxMessageSize}).pb(Oo).write({listenAddrs:e.map(w=>w.bytes),signedPeerRecord:s.marshal(),protocols:i,agentVersion:a,protocolVersion:c},{signal:y}),await g.close({signal:y})}catch(p){l.log.error("could not push identify update to peer",p),g==null||g.abort(p)}})}await ws(Rs(h(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:r,stream:s}=e;try{if(this.peerId.equals(r.remotePeer))throw new Error("received push from ourselves?");const i={signal:AbortSignal.timeout(this.timeout)},a=await Wt(s,{maxDataLength:this.maxMessageSize}).pb(Oo).read(i);await s.close(i),await ym(this.peerStore,this.events,this.log,r,a)}catch(i){this.log.error("received invalid message",i),s.abort(i);return}this.log.trace("handled push from %p",r.remotePeer)}}const LP=41;var t4,r4;class OP extends(r4=wm,t4=Pt,r4){constructor(e,r={}){super(e,{...r,protocol:`/${r.protocolPrefix??Sr.protocolPrefix}/${AP}/${CP}`,log:e.logger.forComponent("libp2p:identify")});u(this,t4,["@libp2p/identify"]);(r.runOnConnectionOpen??Sr.runOnConnectionOpen)&&e.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(o=>{o.name!==ic.name&&this.log.error("error during identify trigged by connection:open",o)})})}async _identify(e,r={}){let s;if(r.signal==null){const i=AbortSignal.timeout(this.timeout);r={...r,signal:i}}try{s=await e.newStream(this.protocol,{...r,runOnLimitedConnection:this.runOnLimitedConnection});const o=await Wt(s,{maxDataLength:this.maxMessageSize}).pb(Oo).read(r);return await s.close(r),o}catch(i){throw s==null||s.abort(i),i}}async identify(e,r={}){const s=await this._identify(e,r),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new We("public key was missing from identify message");const c=ir(i),l=qo(c.toCID());if(!e.remotePeer.equals(l))throw new We("identified peer does not match the expected peer");if(this.peerId.equals(l))throw new We("identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("identify completed for peer %p and protocols %o",l,o),ym(this.peerStore,this.events,this.log,e,s)}maybeAddObservedAddress(e){const r=BP(e);if(r==null)return;if(this.log.trace("our observed address was %a",r),gi(r)){this.log.trace("our observed address was private");return}if(r.stringTuples()[0][0]===LP&&!em(r)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Gl.exactMatch(r)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(r))}async handleProtocol(e){const{connection:r,stream:s}=e,i=AbortSignal.timeout(this.timeout);try{const o=await this.peerStore.get(this.peerId),a=this.addressManager.getAddresses().map(d=>d.decapsulateCode(ge("p2p").code));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const d=new dn({peerId:this.peerId,multiaddrs:a});c=(await Is.seal(d,this.privateKey)).marshal().subarray()}let l=r.remoteAddr.bytes;CI.matches(r.remoteAddr)||(l=void 0),await Wt(s).pb(Oo).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:Ur(this.privateKey.publicKey),listenAddrs:a.map(d=>d.bytes),signedPeerRecord:c,observedAddr:l,protocols:o.protocols},{signal:i}),await s.close({signal:i})}catch(o){this.log.error("could not respond to identify request",o),s.abort(o)}}}function bm(n={}){return t=>new OP(t,n)}function FP(n={}){return t=>new NP(t,n)}const yc=1e3,E0=60*yc,oh=60*E0,UP=36*oh,$P="/ipfs/kad/1.0.0",zP=48*oh,VP=24*oh,HP=10,qP=16384,WP=oh,vm=20,S0=3,KP=5*E0,GP=yc,QP=5*yc,YP=5*E0,XP=30*yc,ZP=180*yc,sp=`${Iu}-kad-dht`;var cu;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.key!=null&&e.key.byteLength>0&&(r.uint32(10),r.bytes(e.key)),e.value!=null&&e.value.byteLength>0&&(r.uint32(18),r.bytes(e.value)),e.timeReceived!=null&&e.timeReceived!==""&&(r.uint32(42),r.string(e.timeReceived)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={key:Ee(0),value:Ee(0),timeReceived:""},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.key=e.bytes();break}case 2:{i.value=e.bytes();break}case 5:{i.timeReceived=e.string();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(cu||(cu={}));function JP(n){const t=n.getUTCFullYear(),e=String(n.getUTCMonth()+1).padStart(2,"0"),r=String(n.getUTCDate()).padStart(2,"0"),s=String(n.getUTCHours()).padStart(2,"0"),i=String(n.getUTCMinutes()).padStart(2,"0"),o=String(n.getUTCSeconds()).padStart(2,"0"),a=n.getUTCMilliseconds(),c=String(a*1e3*1e3).padStart(9,"0");return`${t}-${e}-${r}T${s}:${i}:${o}.${c}Z`}function jP(n){const t=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),e=String(n).trim().match(t);if(e==null)throw new Error("Invalid format");const r=parseInt(e[1],10),s=parseInt(e[2],10)-1,i=parseInt(e[3],10),o=parseInt(e[4],10),a=parseInt(e[5],10),c=parseInt(e[6],10),l=parseInt(e[7].slice(0,-6),10);return new Date(Date.UTC(r,s,i,o,a,c,l))}class Ir{constructor(t,e,r){u(this,"key");u(this,"value");u(this,"timeReceived");if(!(t instanceof Uint8Array))throw new Error("key must be a Uint8Array");if(!(e instanceof Uint8Array))throw new Error("value must be a Uint8Array");this.key=t,this.value=e,this.timeReceived=r}serialize(){return cu.encode(this.prepareSerialize())}prepareSerialize(){return{key:this.key,value:this.value,timeReceived:JP(this.timeReceived)}}static deserialize(t){const e=cu.decode(t);return new Ir(e.key,e.value,new Date(e.timeReceived))}static fromDeserialized(t){const e=jP(t.timeReceived);if(t.key==null)throw new Error("key missing from deserialized object");if(t.value==null)throw new Error("value missing from deserialized object");return new Ir(t.key,t.value,e)}}class lu extends Error{constructor(t="Query error"){super(t),this.name="QueryError"}}class eD extends Error{constructor(t="Query aborted"){super(t),this.name="QueryAbortedError"}}class tD extends Error{constructor(t="Invalid record"){super(t),this.name="InvalidRecordError"}}class rD extends Error{constructor(t="No selector function configured for prefix"){super(t),this.name="MissingSelectorError"}}var ip;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.key!=null&&(r.uint32(10),r.bytes(e.key)),e.value!=null&&(r.uint32(18),r.bytes(e.value)),e.author!=null&&(r.uint32(26),r.bytes(e.author)),e.signature!=null&&(r.uint32(34),r.bytes(e.signature)),e.timeReceived!=null&&(r.uint32(42),r.string(e.timeReceived)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.key=e.bytes();break}case 2:{i.value=e.bytes();break}case 3:{i.author=e.bytes();break}case 4:{i.signature=e.bytes();break}case 5:{i.timeReceived=e.string();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(ip||(ip={}));var Ke;(function(n){n.PUT_VALUE="PUT_VALUE",n.GET_VALUE="GET_VALUE",n.ADD_PROVIDER="ADD_PROVIDER",n.GET_PROVIDERS="GET_PROVIDERS",n.FIND_NODE="FIND_NODE",n.PING="PING"})(Ke||(Ke={}));var uu;(function(n){n[n.PUT_VALUE=0]="PUT_VALUE",n[n.GET_VALUE=1]="GET_VALUE",n[n.ADD_PROVIDER=2]="ADD_PROVIDER",n[n.GET_PROVIDERS=3]="GET_PROVIDERS",n[n.FIND_NODE=4]="FIND_NODE",n[n.PING=5]="PING"})(uu||(uu={}));(function(n){n.codec=()=>Ht(uu)})(Ke||(Ke={}));var Fo;(function(n){n.NOT_CONNECTED="NOT_CONNECTED",n.CONNECTED="CONNECTED",n.CAN_CONNECT="CAN_CONNECT",n.CANNOT_CONNECT="CANNOT_CONNECT"})(Fo||(Fo={}));var I1;(function(n){n[n.NOT_CONNECTED=0]="NOT_CONNECTED",n[n.CONNECTED=1]="CONNECTED",n[n.CAN_CONNECT=2]="CAN_CONNECT",n[n.CANNOT_CONNECT=3]="CANNOT_CONNECT"})(I1||(I1={}));(function(n){n.codec=()=>Ht(I1)})(Fo||(Fo={}));var $i;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.id!=null&&e.id.byteLength>0&&(r.uint32(10),r.bytes(e.id)),e.multiaddrs!=null)for(const i of e.multiaddrs)r.uint32(18),r.bytes(i);e.connection!=null&&(r.uint32(24),Fo.codec().encode(e.connection,r)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a;const i={id:Ee(0),multiaddrs:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.id=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.multiaddrs)!=null&&i.multiaddrs.length===s.limits.multiaddrs)throw new Fe('Decode error - map field "multiaddrs" had too many elements');i.multiaddrs.push(e.bytes());break}case 3:{i.connection=Fo.codec().decode(e);break}default:{e.skipType(c&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})($i||($i={}));var ni;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.type!=null&&uu[e.type]!==0&&(r.uint32(8),Ke.codec().encode(e.type,r)),e.clusterLevel!=null&&(r.uint32(80),r.int32(e.clusterLevel)),e.key!=null&&(r.uint32(18),r.bytes(e.key)),e.record!=null&&(r.uint32(26),r.bytes(e.record)),e.closer!=null)for(const i of e.closer)r.uint32(66),$i.codec().encode(i,r);if(e.providers!=null)for(const i of e.providers)r.uint32(74),$i.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c,l,h;const i={type:Ke.PUT_VALUE,closer:[],providers:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const d=e.uint32();switch(d>>>3){case 1:{i.type=Ke.codec().decode(e);break}case 10:{i.clusterLevel=e.int32();break}case 2:{i.key=e.bytes();break}case 3:{i.record=e.bytes();break}case 8:{if(((a=s.limits)==null?void 0:a.closer)!=null&&i.closer.length===s.limits.closer)throw new Fe('Decode error - map field "closer" had too many elements');i.closer.push($i.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.closer$}));break}case 9:{if(((l=s.limits)==null?void 0:l.providers)!=null&&i.providers.length===s.limits.providers)throw new Fe('Decode error - map field "providers" had too many elements');i.providers.push($i.codec().decode(e,e.uint32(),{limits:(h=s.limits)==null?void 0:h.providers$}));break}default:{e.skipType(d&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(ni||(ni={}));function op(n,t={}){var r;const e={...n,name:"SEND_QUERY",type:0,messageName:n.type,messageType:n.type};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:send-query",{detail:e})),e}function A1(n,t={}){var r;const e={...n,name:"PEER_RESPONSE",type:1,messageName:n.messageType,closer:n.closer??[],providers:n.providers??[]};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:peer-response",{detail:e})),e}function Yh(n,t={}){var r;const e={...n,name:"FINAL_PEER",type:2};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:final-peer",{detail:e})),e}function As(n,t={}){var r;const e={...n,name:"QUERY_ERROR",type:3};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:query-error",{detail:e})),e}function ap(n,t={}){var r;const e={...n,name:"PROVIDER",type:4};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:provider",{detail:e})),e}function T1(n,t={}){var r;const e={...n,name:"VALUE",type:5};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:value",{detail:e})),e}function cp(n,t={}){var r;const e={...n,name:"DIAL_PEER",type:7};return(r=t.onProgress)==null||r.call(t,new CustomEvent("kad-dht:query:dial-peer",{detail:e})),e}function nD(n,t,e){if(e.length===0)throw new W("No records given");const s=Z(t).split("/");if(s.length<3)throw new W("Record key does not have a selector function");const i=n[s[1].toString()];if(i==null)throw new rD(`No selector function configured for key type "${s[1]}"`);return e.length===1?0:i(t,e)}function sD(n,t){return 0}const iD={pk:sD};async function x0(n,t){const e=t.key,s=Z(e).split("/");if(s.length<3)return;const i=n[s[1].toString()];if(i==null)throw new W(`No validator available for key type "${s[1]}"`);await i(e,t.value)}const oD=async(n,t)=>{if(!(n instanceof Uint8Array))throw new W('"key" must be a Uint8Array');if(n.byteLength<5)throw new W("Invalid public key record");if(Z(n.subarray(0,4))!=="/pk/")throw new W("key was not prefixed with /pk/");const r=ir(t),s=n.slice(4);if(!_e(s,r.toMultihash().bytes))throw new W("public key does not match passed in key")},aD={pk:oD},cD=Y("/pk/");function lD(n){return{...n,multiaddrs:n.multiaddrs.filter(t=>{const[[e,r]]=t.stringTuples();if(e===53||e===54||e===55)return r!=="localhost";if(e!==4&&e!==6||r==null)return!1;const s=Ds(r);return s==null?!0:!s})}}async function Ga(n){return(await gt.digest(n)).digest}async function Wr(n){return Ga(n.toMultihash().bytes)}function _a(n,t){return new Ge(`${n}/${Z(t,"base32")}`,!1)}function uD(n){return ft([cD,n.toMultihash().bytes])}function hD(n){return Z(n.subarray(0,4))==="/pk/"}function dD(n){const t=bt(n.subarray(4));return pr(t)}function lp(n,t){const e=new Date;return new Ir(n,t,e).serialize()}const fD=290,gD=54,pD=55,mD=56,yD=4,wD=41;function bD(n){const t=n.stringTuples();for(const e of t)if(e[0]===fD)return!1;if(t[0][0]===gD||t[0][0]===pD||t[0][0]===mD)return!0;if(t[0][0]===yD||t[0][0]===wD){const e=Ds(`${t[0][1]}`);return e==null||!e}return!1}function Em(n){const t=n.toString().split("/"),e=t.pop(),r=t.pop();if(e==null||r==null)throw new Error(`incorrectly formatted provider entry key in datastore: ${n.toString()}`);return{cid:te.createV1(qr,bt(Y(r,"base32"))),peerId:ut(e)}}function Xh(n,t,e){const r=typeof t=="string"?t:Z(t.multihash.bytes,"base32"),s=[n,r];return e!=null&&s.push(e.toString()),new Ge(s.join("/"))}function Sm(n){return new Date(yn(n))}function Bi(n,t,e){return async function*(...r){var a,c,l,h,d;const s=(a=t.queryTime)==null?void 0:a.timer(e),i=(c=t.errorTime)==null?void 0:c.timer(e);let o=!1;try{(l=t.queries)==null||l.increment({[e]:!0}),yield*n(...r)}catch(f){throw o=!0,i==null||i(),(h=t.errors)==null||h.increment({[e]:!0}),f}finally{(d=t.queries)==null||d.decrement({[e]:!0}),o||s==null||s()}}}function xm(n,t,e){return async function(...r){var a,c,l,h,d;const s=(a=t==null?void 0:t.queryTime)==null?void 0:a.timer(e),i=(c=t==null?void 0:t.errorTime)==null?void 0:c.timer(e);let o=!1;try{return(l=t.queries)==null||l.increment({[e]:!0}),await n(...r)}catch(f){throw o=!0,i==null||i(),(h=t.errors)==null||h.increment({[e]:!0}),f}finally{(d=t.queries)==null||d.decrement({[e]:!0}),o||s==null||s()}}}class vD{constructor(t,e){u(this,"log");u(this,"components");u(this,"validators");u(this,"selectors");u(this,"peerRouting");u(this,"queryManager");u(this,"network");u(this,"datastorePrefix");var l,h;const{validators:r,selectors:s,peerRouting:i,queryManager:o,network:a,logPrefix:c}=e;this.components=t,this.log=t.logger.forComponent(`${c}:content-fetching`),this.datastorePrefix=`${e.datastorePrefix}/record`,this.validators=r,this.selectors=s,this.peerRouting=i,this.queryManager=o,this.network=a,this.get=((l=t.metrics)==null?void 0:l.traceFunction("libp2p.kadDHT.get",this.get.bind(this),{optionsIndex:1}))??this.get,this.put=((h=t.metrics)==null?void 0:h.traceFunction("libp2p.kadDHT.put",this.put.bind(this),{optionsIndex:2}))??this.put}async getLocal(t){this.log("getLocal %b",t);const e=_a(this.datastorePrefix,t);this.log("fetching record for key %k",e);const r=await this.components.datastore.get(e);this.log("found %k in local datastore",e);const s=Ir.deserialize(r);return await x0(this.validators,s),s}async*sendCorrectionRecord(t,e,r,s={}){this.log("sendCorrection for %b",t);const i=lp(t,r);for(const{value:o,from:a}of e){if(_e(o,r)){this.log("record was ok");continue}if(this.components.peerId.equals(a)){try{const h=_a(this.datastorePrefix,t);this.log(`Storing corrected record for key ${h.toString()}`),await this.components.datastore.put(h,i.subarray())}catch(h){this.log.error("Failed error correcting self",h)}continue}let c=!1;const l={type:Ke.PUT_VALUE,key:t,record:i};for await(const h of this.network.sendRequest(a,l,s))h.name==="PEER_RESPONSE"&&h.record!=null&&_e(h.record.value,Ir.deserialize(i).value)&&(c=!0),yield h;c||(yield As({from:a,error:new lu("Value not put correctly")},s)),this.log.error("Failed error correcting entry")}}async*put(t,e,r={}){this.log("put key %b value %b",t,e);const s=lp(t,e),i=_a(this.datastorePrefix,t);this.log(`storing record for key ${i.toString()}`),await this.components.datastore.put(i,s.subarray()),yield*It(this.peerRouting.getClosestPeers(t,{...r,signal:r.signal}),o=>Un(o,a=>async()=>{if(a.name!=="FINAL_PEER")return[a];const c=[],l={type:Ke.PUT_VALUE,key:t,record:s};this.log("send put to %p",a.peer.id);for await(const h of this.network.sendRequest(a.peer.id,l,r))c.push(h),h.name==="PEER_RESPONSE"&&(h.record!=null&&_e(h.record.value,Ir.deserialize(s).value)||c.push(As({from:a.peer.id,error:new lu("Value not put correctly")},r)));return c}),o=>Rs(o,{ordered:!1,concurrency:S0}),async function*(o){for await(const a of o)yield*a})}async*get(t,e={}){this.log("get %b",t);const r=[];for await(const a of this.getMany(t,e))a.name==="VALUE"&&r.push(a),yield a;if(r.length===0)return;const s=r.map(a=>a.value);let i=0;try{i=nD(this.selectors,t,s)}catch(a){if(a.name!=="InvalidParametersError")throw a}const o=s[i];if(this.log("GetValue %b %b",t,o),o==null)throw new Nt("Best value was not found");yield*this.sendCorrectionRecord(t,r,o,e),yield r[i]}async*getMany(t,e={}){this.log("getMany values for %b",t);try{const i=await this.getLocal(t);yield T1({value:i.value,from:this.components.peerId},e)}catch(i){this.log("error getting local value for %b",t,i)}const r=this,s=async function*({peer:i,signal:o}){for await(const a of r.peerRouting.getValueOrPeers(i,t,{...e,signal:o}))yield a,a.name==="PEER_RESPONSE"&&a.record!=null&&(yield T1({from:i,value:a.record.value},e))};yield*this.queryManager.run(t,s,e)}}function ED(n,t){return{id:n.id.toMultihash().bytes,multiaddrs:(n.multiaddrs??[]).map(r=>r.bytes),connection:t}}function Gc(n){if(n.id==null)throw new Error("Invalid peer in message");const t=bt(n.id);return{id:pr(t),multiaddrs:(n.multiaddrs??[]).map(e=>fe(e))}}class SD{constructor(t,e){u(this,"log");u(this,"components");u(this,"network");u(this,"peerRouting");u(this,"queryManager");u(this,"routingTable");u(this,"providers");var l,h;const{network:r,peerRouting:s,queryManager:i,routingTable:o,providers:a,logPrefix:c}=e;this.components=t,this.log=t.logger.forComponent(`${c}:content-routing`),this.network=r,this.peerRouting=s,this.queryManager=i,this.routingTable=o,this.providers=a,this.findProviders=((l=t.metrics)==null?void 0:l.traceFunction("libp2p.kadDHT.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromYieldedValue:(d,f)=>(d.name==="PROVIDER"&&(f.providers??(f.providers=[]),f.providers.push(...d.providers.map(g=>g.id.toString()))),f)}))??this.findProviders,this.provide=((h=t.metrics)==null?void 0:h.traceFunction("libp2p.kadDHT.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromYieldedValue:(d,f)=>(d.name==="PEER_RESPONSE"&&d.messageName==="ADD_PROVIDER"&&(f.providers??(f.providers=[]),f.providers.push(d.from.toString())),f)}))??this.provide}async*provide(t,e,r={}){this.log("provide %s",t);const s=t.multihash.bytes;await this.providers.addProvider(t,this.components.peerId);const i={type:Ke.ADD_PROVIDER,key:s,providers:[ED({id:this.components.peerId,multiaddrs:e})]};let o=0;const a=c=>async()=>{if(c.name!=="FINAL_PEER")return[c];const l=[];this.log("putProvider %s to %p",t,c.peer.id);try{this.log("sending provider record for %s to %p",t,c.peer.id);for await(const h of this.network.sendMessage(c.peer.id,i,r))h.name==="PEER_RESPONSE"&&(this.log("sent provider record for %s to %p",t,c.peer.id),o++),l.push(h)}catch(h){this.log.error("error sending provide record to peer %p",c.peer.id,h),l.push(As({from:c.peer.id,error:h},r))}return l};yield*It(this.peerRouting.getClosestPeers(s,r),c=>Un(c,l=>a(l)),c=>Rs(c,{ordered:!1,concurrency:S0}),async function*(c){for await(const l of c)yield*l}),this.log("sent provider records to %d peers",o)}async*findProviders(t,e){const r=this.routingTable.kBucketSize;let s=0;const i=t.multihash.bytes,o=this;this.log("findProviders %c",t);const a=await this.providers.getProviders(t);if(a.length>0){const h=[];for(const d of a.slice(0,r))try{const f=await this.components.peerStore.get(d);h.push({id:d,multiaddrs:f.addresses.map(({multiaddr:g})=>g)})}catch(f){if(f.name!=="NotFoundError")throw f;this.log("no peer store entry for %p",d)}if(yield A1({from:this.components.peerId,messageType:Ke.GET_PROVIDERS,providers:h},e),yield ap({from:this.components.peerId,providers:h},e),s+=h.length,s>=r)return}const c=async function*({peer:h,signal:d}){const f={type:Ke.GET_PROVIDERS,key:i};yield*o.network.sendRequest(h,f,{...e,signal:d})},l=new $r(a);for await(const h of this.queryManager.run(i,c,e))if(yield h,h.name==="PEER_RESPONSE"){this.log("Found %d provider entries for %c and %d closer peers",h.providers.length,t,h.closer.length);const d=[];for(const f of h.providers)l.has(f.id)||(l.add(f.id),d.push(f));if(d.length>0&&(yield ap({from:h.from,providers:d},e),s+=d.length,s>=r))return}}}class Zh{constructor(t){u(this,"movingAverage");u(this,"variance");u(this,"deviation");u(this,"forecast");u(this,"timeSpan");u(this,"previousTime");this.timeSpan=t,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(t,e){return 1-Math.exp(-(t-e)/this.timeSpan)}push(t,e=Date.now()){if(this.previousTime!=null){const r=this.alpha(e,this.previousTime),s=t-this.movingAverage,i=r*s;this.movingAverage=r*t+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*s}else this.movingAverage=t;this.previousTime=e}}const xD=1.2,_D=2,kD=2e3;class Qa{constructor(t={}){u(this,"success");u(this,"failure");u(this,"next");u(this,"metric");u(this,"timeoutMultiplier");u(this,"failureMultiplier");u(this,"minTimeout");var e;this.success=new Zh(t.interval??5e3),this.failure=new Zh(t.interval??5e3),this.next=new Zh(t.interval??5e3),this.failureMultiplier=t.failureMultiplier??_D,this.timeoutMultiplier=t.timeoutMultiplier??xD,this.minTimeout=t.minTimeout??kD,t.metricName!=null&&(this.metric=(e=t.metrics)==null?void 0:e.registerMetricGroup(t.metricName))}getTimeoutSignal(t={}){const e=Math.max(Math.round(this.next.movingAverage*(t.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),r=AbortSignal.timeout(e),s=Ne([t.signal,r]);return s.start=Date.now(),s.timeout=e,s}cleanUp(t){var r,s;const e=Date.now()-t.start;t.aborted?(this.failure.push(e),this.next.push(e*this.failureMultiplier),(r=this.metric)==null||r.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:e})):(this.success.push(e),this.next.push(e),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:e}))}}class ID extends Et{constructor(e,r){var s,i,o,a;super();u(this,"log");u(this,"protocol");u(this,"running");u(this,"components");u(this,"timeout");u(this,"metrics");this.components=e,this.log=e.logger.forComponent(`${r.logPrefix}:network`),this.running=!1,this.protocol=r.protocol,this.timeout=new Qa({...r.timeout??{},metrics:e.metrics,metricName:`${r.metricsPrefix}_network_message_send_times_milliseconds`}),this.metrics={operations:(s=e.metrics)==null?void 0:s.registerCounterGroup(`${r.metricsPrefix}_outbound_rpc_requests_total`),errors:(i=e.metrics)==null?void 0:i.registerCounterGroup(`${r.metricsPrefix}_outbound_rpc_errors_total`)},this.sendRequest=((o=e.metrics)==null?void 0:o.traceFunction("libp2p.kadDHT.sendRequest",this.sendRequest.bind(this),{optionsIndex:2,getAttributesFromArgs([c,l],h){return{...h,to:c.toString(),"message type":`${l.type}`}},getAttributesFromYieldedValue:(c,l)=>(c.name==="PEER_RESPONSE"&&(c.providers.length>0&&c.providers.forEach((h,d)=>{l[`providers-${d}`]=h.id.toString()}),c.closer.length>0&&c.closer.forEach((h,d)=>{l[`closer-${d}`]=h.id.toString()})),l)}))??this.sendRequest,this.sendMessage=((a=e.metrics)==null?void 0:a.traceFunction("libp2p.kadDHT.sendMessage",this.sendMessage.bind(this),{optionsIndex:2,getAttributesFromArgs([c,l],h){return{...h,to:c.toString(),"message type":`${l.type}`}},getAttributesFromYieldedValue:(c,l)=>(c.name==="PEER_RESPONSE"&&(c.providers.length>0&&c.providers.forEach((h,d)=>{l[`providers-${d}`]=h.id.toString()}),c.closer.length>0&&c.closer.forEach((h,d)=>{l[`closer-${d}`]=h.id.toString()})),l)}))??this.sendMessage}async start(){this.running||(this.running=!0)}async stop(){this.running=!1}isStarted(){return this.running}async*sendRequest(e,r,s={}){var c,l,h;if(!this.running)return;const i=r.type;if(i==null)throw new W("Message type was missing");this.log("sending %s to %p",r.type,e),yield cp({peer:e},s),yield op({to:e,type:i},s);let o;const a=this.timeout.getTimeoutSignal(s);s={...s,signal:a};try{(c=this.metrics.operations)==null||c.increment({[i]:!0}),o=await(await this.components.connectionManager.openConnection(e,s)).newStream(this.protocol,s);const f=await this._writeReadMessage(o,r,s);o.close(s).catch(g=>{this.log.error("error closing stream to %p",e,g),o==null||o.abort(g)}),yield A1({from:e,messageType:f.type,closer:f.closer.map(Gc),providers:f.providers.map(Gc),record:f.record==null?void 0:Ir.deserialize(f.record)},s)}catch(d){(l=this.metrics.errors)==null||l.increment({[i]:!0}),o==null||o.abort(d),((h=s.signal)==null?void 0:h.aborted)!==!0&&this.log.error("could not send %s to %p - %e",r.type,e,d),yield As({from:e,error:d},s)}finally{this.timeout.cleanUp(a)}}async*sendMessage(e,r,s={}){var c,l;if(!this.running)return;const i=r.type;if(i==null)throw new W("Message type was missing");this.log("sending %s to %p",r.type,e),yield cp({peer:e},s),yield op({to:e,type:i},s);let o;const a=this.timeout.getTimeoutSignal(s);s={...s,signal:a};try{(c=this.metrics.operations)==null||c.increment({[i]:!0}),o=await(await this.components.connectionManager.openConnection(e,s)).newStream(this.protocol,s),await this._writeMessage(o,r,s),o.close(s).catch(d=>{this.log.error("error closing stream to %p",e,d),o==null||o.abort(d)}),yield A1({from:e,messageType:i},s)}catch(h){(l=this.metrics.errors)==null||l.increment({[i]:!0}),o==null||o.abort(h),yield As({from:e,error:h},s)}finally{this.timeout.cleanUp(a)}}async _writeMessage(e,r,s){await Wt(e).write(r,ni,s)}async _writeReadMessage(e,r,s){const i=Wt(e);await i.write(r,ni,s);const o=await i.read(ni,s);return o.closer.forEach(a=>{this.safeDispatchEvent("peer",{detail:Gc(a)})}),o.providers.forEach(a=>{this.safeDispatchEvent("peer",{detail:Gc(a)})}),o}}function Ya(n,t){if(n.byteLength!==t.byteLength)throw new Error("Inputs should have the same length");for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return n[e]<t[e]?-1:1;return 0}class _0{constructor(t,e){u(this,"originDhtKey");u(this,"capacity");u(this,"peerDistances");this.originDhtKey=t,this.capacity=e,this.peerDistances=[]}get length(){return this.peerDistances.length}get peers(){return this.peerDistances.map(t=>t.peer)}async add(t){const e=await Wr(t.id);this.addWithKadId(t,e)}addWithKadId(t,e){if(this.peerDistances.find(i=>i.peer.id.equals(t.id))!=null)return;const r={peer:t,distance:ks(this.originDhtKey,e)};let s=!1;for(let i=0;i<this.peerDistances.length;i++){const o=Ya(this.peerDistances[i].distance,r.distance);if(o===0||o===1){s=!0,this.peerDistances.splice(i,0,r);break}}s||this.peerDistances.push(r),this.peerDistances=this.peerDistances.slice(0,this.capacity)}async isCloser(t){if(this.length===0)return!0;const e=await Wr(t),r=ks(e,this.originDhtKey),s=this.peerDistances[this.peerDistances.length-1].distance;return Ya(r,s)===-1}async anyCloser(t){return t.length===0?!1:Promise.any(t.map(async e=>this.isCloser(e)))}}class AD{constructor(t,e){u(this,"log");u(this,"routingTable");u(this,"network");u(this,"validators");u(this,"queryManager");u(this,"peerStore");u(this,"peerId");var r,s;this.routingTable=e.routingTable,this.network=e.network,this.validators=e.validators,this.queryManager=e.queryManager,this.peerStore=t.peerStore,this.peerId=t.peerId,this.log=t.logger.forComponent(`${e.logPrefix}:peer-routing`),this.findPeer=((r=t.metrics)==null?void 0:r.traceFunction("libp2p.kadDHT.findPeer",this.findPeer.bind(this),{optionsIndex:1}))??this.findPeer,this.getClosestPeers=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.kadDHT.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1}))??this.getClosestPeers}async findPeerLocal(t){let e;const r=await this.routingTable.find(t);if(r!=null){this.log("findPeerLocal found %p in routing table",t);try{e=await this.peerStore.get(r)}catch(s){if(s.name!=="NotFoundError")throw s}}if(e==null)try{e=await this.peerStore.get(t)}catch(s){if(s.name!=="NotFoundError")throw s}if(e!=null)return this.log("findPeerLocal found %p in peer store",t),{id:e.id,multiaddrs:e.addresses.map(s=>s.multiaddr)}}async*_getValueSingle(t,e,r={}){const s={type:Ke.GET_VALUE,key:e};yield*this.network.sendRequest(t,s,r)}async*getPublicKeyFromNode(t,e={}){const r=uD(t);for await(const s of this._getValueSingle(t,r,e))if(yield s,s.name==="PEER_RESPONSE"&&s.record!=null){const i=ir(s.record.value),o=ko(i);if(!o.equals(t))throw new Pa("public key does not match id");if(o.publicKey==null)throw new Pa("public key missing");yield T1({from:t,value:s.record.value},e)}throw new lu(`Node not responding with its public key: ${t.toString()}`)}async*findPeer(t,e={}){if(this.log("findPeer %p",t),e.useCache!==!1){const s=await this.findPeerLocal(t);if(s!=null){this.log("found local"),yield Yh({from:this.peerId,peer:s},e);return}}let r=!1;if(e.useNetwork!==!1){const s=this,i=async function*({peer:o,signal:a}){const c={type:Ke.FIND_NODE,key:t.toMultihash().bytes};for await(const l of s.network.sendRequest(o,c,{...e,signal:a}))if(yield l,l.name==="PEER_RESPONSE"){const h=l.closer.find(d=>d.id.equals(t));h!=null&&(yield Yh({from:l.from,peer:h},e))}};for await(const o of this.queryManager.run(t.toMultihash().bytes,i,e))o.name==="FINAL_PEER"&&(r=!0),yield o}r||(yield As({from:this.peerId,error:new Nt("Not found")},e))}async*getClosestPeers(t,e={}){this.log("getClosestPeers to %b",t);const r=await Ga(t),s=this.routingTable.closestPeers(r),i=this,o=new _0(r,this.routingTable.kBucketSize);await Promise.all(s.map(async c=>{await o.add({id:c,multiaddrs:[]})}));const a=async function*({peer:c,signal:l}){i.log("closerPeersSingle %s from %p",Z(t,"base32"),c);const h={type:Ke.FIND_NODE,key:t};yield*i.network.sendRequest(c,h,{...e,signal:l})};for await(const c of this.queryManager.run(t,a,e))c.name==="PEER_RESPONSE"&&await Promise.all(c.closer.map(async l=>{await o.add(l)})),yield c;this.log("found %d peers close to %b",o.length,t);for(const c of o.peers)yield Yh({from:this.peerId,peer:c},e)}async*getValueOrPeers(t,e,r={}){for await(const s of this._getValueSingle(t,e,r)){if(s.name==="PEER_RESPONSE"&&s.record!=null)try{await this._verifyRecordOnline(s.record)}catch{const o="invalid record received, discarded";this.log(o),yield As({from:s.from,error:new lu(o)},r);continue}yield s}}async _verifyRecordOnline(t){if(t.timeReceived==null)throw new tD("invalid record received");await x0(this.validators,new Ir(t.key,t.value,t.timeReceived))}async getCloserPeersOffline(t,e){const r=[];try{const c=bt(t),l=pr(c),h=await this.peerStore.get(l);r.push({id:h.id,multiaddrs:h.addresses.map(({multiaddr:d})=>d)})}catch{}const s=await Ga(t),i=this.routingTable.closestPeers(s),o=await Wr(e),a=ks(o,s);for(const c of i){const l=await Wr(c),h=ks(l,s);if(Ya(h,a)===-1)try{const d=await this.peerStore.get(c);r.push({id:c,multiaddrs:d.addresses.map(({multiaddr:f})=>f)})}catch(d){if(d.name!=="NotFoundError")throw d}}return r.length>0?this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p",r.length,t,e):this.log("getCloserPeersOffline could not find peer closer to %b than %p with %d peers in the routing table",t,e,this.routingTable.size),r}}class TD{constructor(t,e){u(this,"log");u(this,"datastore");u(this,"datastorePrefix");u(this,"lock");this.log=t.logger.forComponent(`${e.logPrefix}:providers`),this.datastorePrefix=`${e.datastorePrefix}/provider`,this.datastore=t.datastore,this.lock=e.lock}async addProvider(t,e){const r=await this.lock.readLock();try{this.log("%p provides %s",e,t),await this.writeProviderEntry(t,e)}finally{r()}}async removeProvider(t,e){const r=await this.lock.writeLock();try{const s=Xh(this.datastorePrefix,t,e);this.log("%p no longer provides %s",e,t),await this.datastore.delete(s)}finally{r()}}async getProviders(t){const e=await this.lock.readLock();try{this.log("get providers for %c",t);const r=await this.loadProviders(t);return this.log("got %d providers for %c",r.size,t),[...r.keys()]}finally{e()}}async writeProviderEntry(t,e,r=new Date){const s=Xh(this.datastorePrefix,t,e),i=Lt(r.getTime());await this.datastore.put(s,i)}async loadProviders(t){const e=new Ps,r=Xh(this.datastorePrefix,t);for await(const s of this.datastore.query({prefix:r.toString()})){const{peerId:i}=Em(s.key);e.set(i,Sm(s.value))}return e}}async function*CD(n){const{key:t,startingPeer:e,ourPeerId:r,signal:s,query:i,alpha:o,pathIndex:a,numPaths:c,queryFuncTimeout:l,log:h,peersSeen:d,connectionManager:f}=n,g=new oi({concurrency:o,sort:(w,v)=>Ya(w.options.distance,v.options.distance)}),y=await Ga(t);function p(w,v){if(w==null)return;d.add(w);const x=ks(v,y);g.add(async()=>{const S=[s];l!=null&&S.push(AbortSignal.timeout(l));const I=Ne(S);try{for await(const P of i({...n,key:t,peer:w,signal:I,pathIndex:a,numPaths:c})){if(I.aborted)return;if(P.name==="PEER_RESPONSE")for(const A of P.closer){if(d.has(A.id)){h.trace("already seen %p in query",A.id);continue}if(r.equals(A.id)){h("not querying ourselves");continue}if(!await f.isDialable(A.multiaddrs)){h("not querying undialable peer");continue}const C=await Wr(A.id),T=ks(C,y);if(Ya(T,x)!==-1){h.trace("skipping %p as they are not closer to %b than %p",A.id,t,w);continue}h.trace("querying closer peer %p",A.id),p(A.id,C)}g.safeDispatchEvent("completed",{detail:P})}}catch(P){if(!s.aborted)return As({from:w,error:P},n)}finally{I.clear()}},{distance:x}).catch(S=>{h.error(S)})}p(e,await Wr(e));try{for await(const w of g.toGenerator({signal:s}))w!=null&&(yield w)}catch(w){throw s.aborted?new eD("Query aborted"):w}}class PD{constructor(t,e){u(this,"disjointPaths");u(this,"alpha");u(this,"shutDownController");u(this,"running");u(this,"logger");u(this,"peerId");u(this,"connectionManager");u(this,"routingTable");u(this,"initialQuerySelfHasRun");u(this,"logPrefix");this.logPrefix=e.logPrefix,this.disjointPaths=e.disjointPaths??vm,this.alpha=e.alpha??S0,this.initialQuerySelfHasRun=e.initialQuerySelfHasRun,this.routingTable=e.routingTable,this.logger=t.logger,this.peerId=t.peerId,this.connectionManager=t.connectionManager,this.shutDownController=new AbortController,this.shutDownController.signal,this.running=!1}isStarted(){return this.running}async start(){this.running||(this.running=!0,this.shutDownController=new AbortController,this.shutDownController.signal,void 0)}async stop(){this.running=!1,this.shutDownController.abort()}async*run(t,e,r={}){if(!this.running)throw new Error("QueryManager not started");if(r.signal==null){const c=AbortSignal.timeout(ZP);r={...r,signal:c}}const s=new AbortController,i=Ne([this.shutDownController.signal,s.signal,r.signal]);s.signal;const o=this.logger.forComponent(`${this.logPrefix}:query:`+Z(t,"base58btc"));let a=!1;try{r.isSelfQuery!==!0&&this.initialQuerySelfHasRun!=null&&(o("waiting for initial query-self query before continuing"),await fr(this.initialQuerySelfHasRun.promise,i),this.initialQuerySelfHasRun=void 0),o("query:start");const c=await Ga(t),l=this.routingTable.closestPeers(c),h=l.slice(0,Math.min(this.disjointPaths,l.length));if(l.length===0){o.error("Running query with no peers");return}const d=new $r,f=h.map((g,y)=>CD({...r,key:t,startingPeer:g,ourPeerId:this.peerId,signal:i,query:e,pathIndex:y,numPaths:h.length,alpha:this.alpha,queryFuncTimeout:r.queryFuncTimeout,log:o,peersSeen:d,onProgress:r.onProgress,connectionManager:this.connectionManager}));for await(const g of us(...f)){if(g.name==="QUERY_ERROR"&&o.error("query error",g.error),g.name==="PEER_RESPONSE")for(const y of[...g.closer,...g.providers])await this.connectionManager.isDialable(y.multiaddrs)&&await this.routingTable.add(y.id);yield g}a=!0}catch(c){if(!(!this.running&&c.name==="QueryAbortedError"))throw c}finally{a||(o("query exited early"),s.abort()),i.clear(),o("query:done")}}}function DD(n){return n[Symbol.asyncIterator]!=null}function _m(n){if(DD(n))return(async()=>{let t=0;for await(const e of n)t++;return t})();{let t=0;for(const e of n)t++;return t}}const RD=n=>{const t=n.addEventListener||n.on||n.addListener,e=n.removeEventListener||n.off||n.removeListener;if(!t||!e)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(n),removeListener:e.bind(n)}};function BD(n,t,e){let r;const s=new Promise((i,o)=>{var g;if(e={rejectionEvents:["error"],multiArgs:!1,resolveImmediately:!1,...e},!(e.count>=0&&(e.count===Number.POSITIVE_INFINITY||Number.isInteger(e.count))))throw new TypeError("The `count` option should be at least 0 or more");(g=e.signal)==null||g.throwIfAborted();const a=[t].flat(),c=[],{addListener:l,removeListener:h}=RD(n),d=(...y)=>{const p=e.multiArgs?y:y[0];e.filter&&!e.filter(p)||(c.push(p),e.count===c.length&&(r(),i(c)))},f=y=>{r(),o(y)};r=()=>{for(const y of a)h(y,d);for(const y of e.rejectionEvents)h(y,f)};for(const y of a)l(y,d);for(const y of e.rejectionEvents)l(y,f);e.signal&&e.signal.addEventListener("abort",()=>{f(e.signal.reason)},{once:!0}),e.resolveImmediately&&i(c)});if(s.cancel=r,typeof e.timeout=="number"){const i=lc(s,{milliseconds:e.timeout});return i.cancel=r,i}return s}function MD(n,t,e){typeof e=="function"&&(e={filter:e}),e={...e,count:1,resolveImmediately:!1};const r=BD(n,t,e),s=r.then(i=>i[0]);return s.cancel=r.cancel,s}class ND{constructor(t,e){u(this,"log");u(this,"peerId");u(this,"peerRouting");u(this,"routingTable");u(this,"count");u(this,"interval");u(this,"initialInterval");u(this,"queryTimeout");u(this,"running");u(this,"timeoutId");u(this,"controller");u(this,"initialQuerySelfHasRun");u(this,"querySelfPromise");this.peerId=t.peerId,this.log=t.logger.forComponent(`${e.logPrefix}:query-self`),this.running=!1,this.peerRouting=e.peerRouting,this.routingTable=e.routingTable,this.count=e.count??vm,this.interval=e.interval??KP,this.initialInterval=e.initialInterval??GP,this.queryTimeout=e.queryTimeout??QP,this.initialQuerySelfHasRun=e.initialQuerySelfHasRun,this.querySelf=xm(this.querySelf.bind(this),e.operationMetrics,"SELF_QUERY")}isStarted(){return this.running}start(){this.running||(this.running=!0,clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.querySelf().catch(t=>{this.log.error("error running self-query",t)})},this.initialInterval))}stop(){this.running=!1,this.timeoutId!=null&&clearTimeout(this.timeoutId),this.controller!=null&&this.controller.abort()}async querySelf(){if(!this.running){this.log("skip self-query because we are not started");return}if(this.querySelfPromise!=null)return this.log("joining existing self query"),this.querySelfPromise.promise;if(this.querySelfPromise=me(),this.running){this.controller=new AbortController;const t=[this.controller.signal];if(this.initialQuerySelfHasRun==null){const r=AbortSignal.timeout(this.queryTimeout);t.push(r)}const e=Ne(t);this.controller.signal;try{this.routingTable.size===0&&(this.log("routing table was empty, waiting for some peers before running query"),await MD(this.routingTable,"peer:add",{signal:e,filter:i=>!this.peerId.equals(i.detail)}),this.log("routing table has peers, continuing with query")),this.log("run self-query, look for %d peers timing out after %dms",this.count,this.queryTimeout);const r=Date.now(),s=await It(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes,{signal:e,isSelfQuery:!0}),i=>kl(i,this.count),async i=>_m(i));this.log("self-query found %d peers in %dms",s,Date.now()-r)}catch(r){this.log.error("self-query error",r)}finally{e.clear(),this.initialQuerySelfHasRun!=null&&(this.initialQuerySelfHasRun.resolve(),this.initialQuerySelfHasRun=void 0)}}this.querySelfPromise.resolve(),this.querySelfPromise=void 0,this.running&&(this.timeoutId=setTimeout(()=>{this.querySelf().catch(t=>{this.log.error("error running self-query",t)})},this.interval))}}class LD extends Et{constructor(e,r){super();u(this,"log");u(this,"reprovideQueue");u(this,"maxQueueSize");u(this,"datastore");u(this,"timeout");u(this,"reprovideTimeout");u(this,"running");u(this,"shutdownController");u(this,"reprovideThreshold");u(this,"contentRouting");u(this,"datastorePrefix");u(this,"addressManager");u(this,"validity");u(this,"interval");u(this,"lock");u(this,"peerId");this.log=e.logger.forComponent(`${r.logPrefix}:reprovider`),this.peerId=e.peerId,this.reprovideQueue=new oi({concurrency:r.concurrency??HP,metrics:e.metrics,metricName:`${r.metricsPrefix}_reprovide_queue`}),this.reprovideTimeout=new Qa({...r.timeout??{},metrics:e.metrics,metricName:`${r.metricsPrefix}_reprovide_timeout_milliseconds`}),this.datastore=e.datastore,this.addressManager=e.addressManager,this.datastorePrefix=`${r.datastorePrefix}/provider`,this.reprovideThreshold=r.threshold??VP,this.maxQueueSize=r.maxQueueSize??qP,this.validity=r.validity??zP,this.interval=r.interval??WP,this.contentRouting=r.contentRouting,this.lock=r.lock,this.running=!1,this.reprovide=xm(this.reprovide.bind(this),r.operationMetrics,"PROVIDE")}start(){this.running||(this.running=!0,this.shutdownController=new AbortController,this.shutdownController.signal,this.timeout=setTimeout(()=>{this.cleanUp().catch(e=>{this.log.error("error running reprovide/cleanup - %e",e)})},this.interval))}stop(){var e;this.running=!1,this.reprovideQueue.clear(),clearTimeout(this.timeout),(e=this.shutdownController)==null||e.abort()}async cleanUp(){const e=await this.lock.writeLock();try{this.safeDispatchEvent("reprovide:start");for await(const r of this.datastore.query({prefix:this.datastorePrefix}))try{const{cid:s,peerId:i}=Em(r.key),o=Sm(r.value).getTime(),a=o+this.validity,c=Date.now(),l=c>a;this.log.trace("comparing: %d < %d = %s %s",o,c-this.validity,l,l?"(expired)":""),l&&await this.datastore.delete(r.key),this.peerId.equals(i)&&c-a<this.reprovideThreshold&&this.queueReprovide(s).catch(h=>{this.log.error("could not reprovide %c - %e",s,h)})}catch(s){this.log.error("error processing datastore key %s - %e",r.key,s.message)}this.log("reprovide/cleanup successful")}finally{e(),this.safeDispatchEvent("reprovide:end"),this.running&&(this.timeout=setTimeout(()=>{this.cleanUp().catch(r=>{this.log.error("error running re-provide - %e",r)})},this.interval))}}async queueReprovide(e){var s;if(!this.running)return;this.log.trace("waiting for queue capacity before adding %c to re-provide queue",e),await this.reprovideQueue.onSizeLessThan(this.maxQueueSize);const r=this.reprovideQueue.queue.find(i=>i.options.cid.equals(e));if(r!=null)return this.log.trace("not adding %c to re-provide queue - already in queue",e),r.join();this.log.trace("adding %c to re-provide queue",e),this.reprovideQueue.add(async i=>{var a;if((a=i.signal)==null||a.throwIfAborted(),!this.running)return;this.log.trace("re-providing %c",e);const o=this.reprovideTimeout.getTimeoutSignal(i);try{await this.reprovide(i.cid,i)}finally{this.reprovideTimeout.cleanUp(o)}this.log.trace("re-provided %c",e)},{signal:(s=this.shutdownController)==null?void 0:s.signal,cid:e}).catch(i=>{this.log.error("could not re-provide key %c - %e",e,i)})}async reprovide(e,r){await ws(this.contentRouting.provide(e,this.addressManager.getAddresses(),r))}}const OD=20,FD=5e3,UD="kad-close",$D=50;class zD{constructor(t,e){u(this,"routingTable");u(this,"components");u(this,"closestPeers");u(this,"newPeers");u(this,"refreshInterval");u(this,"peerSetSize");u(this,"timeout");u(this,"closeTagName");u(this,"closeTagValue");u(this,"log");u(this,"running");this.components=t,this.log=t.logger.forComponent(`${e.logPrefix}:routing-table`),this.routingTable=e.routingTable,this.refreshInterval=e.refreshInterval??FD,this.peerSetSize=e.peerSetSize??OD,this.closeTagName=e.closeTagName??UD,this.closeTagValue=e.closeTagValue??$D,this.closestPeers=new $r,this.onPeerPing=this.onPeerPing.bind(this),this.running=!1}async start(){if(this.running)return;this.running=!0;const t=await Wr(this.components.peerId);this.newPeers=new _0(t,this.peerSetSize),this.routingTable.addEventListener("peer:ping",this.onPeerPing),this.timeout=setInterval(()=>{this.updatePeerTags().catch(e=>{this.log.error("error updating peer tags - %e",e)})},this.refreshInterval)}stop(){this.running=!1,this.routingTable.removeEventListener("peer:ping",this.onPeerPing),clearTimeout(this.timeout)}onPeerPing(t){var e;(e=this.newPeers)==null||e.add({id:t.detail,multiaddrs:[]}).catch(r=>{this.log.error("error adding peer to distance list - %e",r)})}async updatePeerTags(){var s;const t=new $r((s=this.newPeers)==null?void 0:s.peers.map(i=>i.id)),e=t.difference(this.closestPeers),r=this.closestPeers.difference(t);this.closestPeers=t,await Promise.all([...[...e].map(async i=>{await this.components.peerStore.merge(i,{tags:{[this.closeTagName]:{value:this.closeTagValue},[sp]:{value:1}}})}),...[...r].map(async i=>{await this.components.peerStore.merge(i,{tags:{[this.closeTagName]:void 0,[sp]:void 0}})})])}}function hl(n){return Array.isArray(n==null?void 0:n.peers)}class VD{constructor(t){u(this,"root");u(this,"localPeer");u(this,"prefixLength");u(this,"splitThreshold");u(this,"kBucketSize");u(this,"numberOfNodesToPing");u(this,"lastPingThreshold");u(this,"ping");u(this,"verify");u(this,"onAdd");u(this,"onRemove");u(this,"onMove");u(this,"addingPeerMap");this.prefixLength=t.prefixLength??WD,this.kBucketSize=t.kBucketSize??km,this.splitThreshold=t.splitThreshold??this.kBucketSize,this.numberOfNodesToPing=t.numberOfOldContactsToPing??QD,this.lastPingThreshold=t.lastPingThreshold??JD,this.ping=t.ping,this.verify=t.verify,this.onAdd=t.onAdd,this.onRemove=t.onRemove,this.addingPeerMap=new Ps,this.root={prefix:"",depth:0,peers:[]}}async addSelfPeer(t){this.localPeer={peerId:t,kadId:await Wr(t),lastPing:Date.now()}}async add(t,e){const r={peerId:t,kadId:await Wr(t),lastPing:0},s=this.addingPeerMap.get(t);if(s!=null)return s;try{const i=this._add(r,e);this.addingPeerMap.set(t,i),await i}finally{this.addingPeerMap.delete(t)}}async _add(t,e){var o;const r=this._determineBucket(t.kadId);if(this._indexOf(r,t.kadId)>-1)return;if(r.peers.length===this.splitThreshold&&r.depth<this.prefixLength){await this._split(r),await this._add(t,e);return}if(r.peers.length<this.kBucketSize){if(!qD(t,this.lastPingThreshold)){r.peers.push(t),await((o=this.onAdd)==null?void 0:o.call(this,t,r));return}await this.verify(t,e)&&(t.lastPing=Date.now(),await this._add(t,e));return}const s=r.peers.filter(a=>{var c;return!(a.peerId.equals((c=this.localPeer)==null?void 0:c.peerId)||a.lastPing>Date.now()-this.lastPingThreshold)}).sort((a,c)=>a.lastPing<c.lastPing?-1:a.lastPing>c.lastPing?1:0).slice(0,this.numberOfNodesToPing);let i=!1;for await(const a of this.ping(s,e))i=!0,await this.remove(a.kadId);i&&await this._add(t,e)}*closest(t,e=this.kBucketSize){const r=new _0(t,e);for(const s of this.toIterable())r.addWithKadId({id:s.peerId,multiaddrs:[]},s.kadId);yield*Un(r.peers,s=>s.id)}count(){function t(e){if(hl(e))return e.peers.length;let r=0;return e.left!=null&&(r+=t(e.left)),e.right!=null&&(r+=t(e.right)),r}return t(this.root)}get(t){const e=this._determineBucket(t),r=this._indexOf(e,t);return e.peers[r]}async remove(t){var s;const e=this._determineBucket(t),r=this._indexOf(e,t);if(r>-1){const i=e.peers.splice(r,1)[0];await((s=this.onRemove)==null?void 0:s.call(this,i,e))}}*toIterable(){function*t(e){if(hl(e)){yield*e.peers;return}yield*t(e.left),yield*t(e.right)}yield*t(this.root)}distance(t,e){return BigInt("0x"+Z(ks(t,e),"base16"))}_determineBucket(t){const e=Z(t,"base2");function r(s,i=0){return hl(s)?s:e[i]==="0"?r(s.left,i+1):r(s.right,i+1)}return r(this.root)}_indexOf(t,e){return t.peers.findIndex(r=>_e(r.kadId,e))}async _split(t){var s,i;const e={prefix:"0",depth:t.depth+1,peers:[]},r={prefix:"1",depth:t.depth+1,peers:[]};for(const o of t.peers)Z(o.kadId,"base2")[t.depth]==="0"?(e.peers.push(o),await((s=this.onMove)==null?void 0:s.call(this,o,t,e))):(r.peers.push(o),await((i=this.onMove)==null?void 0:i.call(this,o,t,r)));HD(t,e,r)}}function HD(n,t,e){return delete n.peers,n.left=t,n.right=e,n.prefix===""&&(delete n.depth,delete n.prefix),!0}function qD(n,t){return n.lastPing<Date.now()-t}const km=20,WD=6,KD=20,GD=100,QD=3,YD=20,XD=100,up="kad-peer",ZD=1,JD=6e5,jD=!0,eR=1e3;class tR extends Et{constructor(e,r){super();u(this,"kBucketSize");u(this,"kb");u(this,"network");u(this,"closestPeerTagger");u(this,"log");u(this,"components");u(this,"running");u(this,"pingNewContactTimeout");u(this,"pingNewContactQueue");u(this,"pingOldContactTimeout");u(this,"pingOldContactQueue");u(this,"populateFromDatastoreOnStart");u(this,"populateFromDatastoreLimit");u(this,"protocol");u(this,"peerTagName");u(this,"peerTagValue");u(this,"metrics");this.components=e,this.log=e.logger.forComponent(`${r.logPrefix}:routing-table`),this.kBucketSize=r.kBucketSize??km,this.running=!1,this.protocol=r.protocol,this.network=r.network,this.peerTagName=r.peerTagName??up,this.peerTagValue=r.peerTagValue??ZD,this.pingOldContacts=this.pingOldContacts.bind(this),this.verifyNewContact=this.verifyNewContact.bind(this),this.peerAdded=this.peerAdded.bind(this),this.peerRemoved=this.peerRemoved.bind(this),this.populateFromDatastoreOnStart=r.populateFromDatastoreOnStart??jD,this.populateFromDatastoreLimit=r.populateFromDatastoreLimit??eR,this.pingOldContactQueue=new ys({concurrency:r.pingOldContactConcurrency??YD,metricName:`${r.metricsPrefix}_ping_old_contact_queue`,metrics:this.components.metrics,maxSize:r.pingOldContactMaxQueueSize??XD}),this.pingOldContactTimeout=new Qa({...r.pingOldContactTimeout??{},metrics:this.components.metrics,metricName:`${r.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`}),this.pingNewContactQueue=new ys({concurrency:r.pingNewContactConcurrency??KD,metricName:`${r.metricsPrefix}_ping_new_contact_queue`,metrics:this.components.metrics,maxSize:r.pingNewContactMaxQueueSize??GD}),this.pingNewContactTimeout=new Qa({...r.pingNewContactTimeout??{},metrics:this.components.metrics,metricName:`${r.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`}),this.kb=new VD({kBucketSize:r.kBucketSize,prefixLength:r.prefixLength,splitThreshold:r.splitThreshold,numberOfOldContactsToPing:r.numberOfOldContactsToPing,lastPingThreshold:r.lastPingThreshold,ping:this.pingOldContacts,verify:this.verifyNewContact,onAdd:this.peerAdded,onRemove:this.peerRemoved}),this.closestPeerTagger=new zD(this.components,{logPrefix:r.logPrefix,routingTable:this,peerSetSize:r.closestPeerSetSize,refreshInterval:r.closestPeerSetRefreshInterval,closeTagName:r.closeTagName,closeTagValue:r.closeTagValue}),this.components.metrics!=null&&(this.metrics={routingTableSize:this.components.metrics.registerMetric(`${r.metricsPrefix}_routing_table_size`),routingTableKadBucketTotal:this.components.metrics.registerMetric(`${r.metricsPrefix}_routing_table_kad_bucket_total`),routingTableKadBucketAverageOccupancy:this.components.metrics.registerMetric(`${r.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),routingTableKadBucketMinOccupancy:this.components.metrics.registerMetric(`${r.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),routingTableKadBucketMaxOccupancy:this.components.metrics.registerMetric(`${r.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),routingTableKadBucketMaxDepth:this.components.metrics.registerMetric(`${r.metricsPrefix}_routing_table_kad_bucket_max_depth`),kadBucketEvents:this.components.metrics.registerCounterGroup(`${r.metricsPrefix}_kad_bucket_events_total`)})}isStarted(){return this.running}async start(){this.running||(this.running=!0,await Ln(this.closestPeerTagger),await this.kb.addSelfPeer(this.components.peerId))}async afterStart(){Promise.resolve().then(async()=>{if(!this.populateFromDatastoreOnStart)return;let e=0;for(const r of await this.components.peerStore.all({filters:[s=>s.protocols.includes(this.protocol)&&s.tags.has(up)],limit:this.populateFromDatastoreLimit})){if(!this.running)return;try{await this.add(r.id),e++}catch{this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e"),await this.components.peerStore.merge(r.id,{tags:{[this.peerTagName]:void 0}})}}this.log("added %d peer store peers to the routing table",e)}).catch(e=>{this.log.error("error adding peer store peers to the routing table %e",e)})}async stop(){this.running=!1,await Cs(this.closestPeerTagger),this.pingOldContactQueue.abort(),this.pingNewContactQueue.abort()}async peerAdded(e,r){var s;this.components.peerId.equals(e.peerId)||await this.components.peerStore.merge(e.peerId,{tags:{[this.peerTagName]:{value:this.peerTagValue}}}),this.updateMetrics(),(s=this.metrics)==null||s.kadBucketEvents.increment({peer_added:!0}),this.safeDispatchEvent("peer:add",{detail:e.peerId})}async peerRemoved(e,r){var s;this.components.peerId.equals(e.peerId)||await this.components.peerStore.merge(e.peerId,{tags:{[this.peerTagName]:void 0}}),this.updateMetrics(),(s=this.metrics)==null||s.kadBucketEvents.increment({peer_removed:!0}),this.safeDispatchEvent("peer:remove",{detail:e.peerId})}async*pingOldContacts(e,r){var i;if(!this.running)return;const s=[];for(const o of e){if(this.kb.get(o.kadId)==null){this.log("asked to ping contact %p that was not in routing table",o.peerId);continue}(i=this.metrics)==null||i.kadBucketEvents.increment({ping_old_contact:!0}),s.push(async()=>{const a=this.pingOldContactQueue.find(o.peerId);if(a!=null)return this.log("asked to ping contact %p was already being pinged",o.peerId),await a.join(r)?void 0:o;if(!await this.pingOldContactQueue.add(async l=>{var f;const h=this.pingOldContactTimeout.getTimeoutSignal(),d=Ne([h,l==null?void 0:l.signal]);try{return await this.pingContact(o,l)}catch{return(f=this.metrics)==null||f.kadBucketEvents.increment({ping_old_contact_error:!0}),!0}finally{this.pingOldContactTimeout.cleanUp(h),d.clear()}},{peerId:o.peerId,signal:r==null?void 0:r.signal}))return o})}for await(const o of Rs(s))o!=null&&(yield o)}async verifyNewContact(e,r){var o;const s=this.pingNewContactTimeout.getTimeoutSignal(),i=Ne([s,r==null?void 0:r.signal]);try{const a=this.pingNewContactQueue.find(e.peerId);return a!=null?(this.log("joining existing ping to add new peer %p to routing table",e.peerId),await a.join({signal:i})):await this.pingNewContactQueue.add(async c=>{var l;return(l=this.metrics)==null||l.kadBucketEvents.increment({ping_new_contact:!0}),this.log("pinging new peer %p before adding to routing table",e.peerId),this.pingContact(e,c)},{peerId:e.peerId,signal:i})}catch{return this.log.trace("tried to add peer %p but they were not online",e.peerId),(o=this.metrics)==null||o.kadBucketEvents.increment({ping_new_contact_error:!0}),!1}finally{this.pingNewContactTimeout.cleanUp(s),i.clear()}}async pingContact(e,r){try{this.log("pinging contact %p",e.peerId);for await(const s of this.network.sendRequest(e.peerId,{type:Ke.PING},r))if(s.type===C1.PEER_RESPONSE)return s.messageType===Ke.PING?(this.log("contact %p ping ok",e.peerId),this.safeDispatchEvent("peer:ping",{detail:e.peerId}),!0):!1;return!1}catch(s){return this.log("error pinging old contact %p - %e",e.peerId,s),!1}}get size(){return this.kb==null?0:this.kb.count()}async find(e){var s;const r=await Wr(e);return(s=this.kb.get(r))==null?void 0:s.peerId}closestPeer(e){const r=this.closestPeers(e,1);if(r.length>0)return r[0]}closestPeers(e,r=this.kBucketSize){return this.kb==null?[]:[...this.kb.closest(e,r)]}async add(e,r){if(this.kb==null)throw new Error("RoutingTable is not started");await this.kb.add(e,r)}async remove(e){if(this.kb==null)throw new Error("RoutingTable is not started");const r=await Wr(e);await this.kb.remove(r)}updateMetrics(){if(this.metrics==null||this.kb==null)return;let e=0,r=0,s=0,i=20,o=0;function a(c){if(hl(c)){c.depth>s&&(s=c.depth),r++,e+=c.peers.length,c.peers.length<i&&(i=c.peers.length),c.peers.length>o&&(o=c.peers.length);return}a(c.left),a(c.right)}a(this.kb.root),this.metrics.routingTableSize.update(e),this.metrics.routingTableKadBucketTotal.update(r),this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(e/r)),this.metrics.routingTableKadBucketMinOccupancy.update(i),this.metrics.routingTableKadBucketMaxOccupancy.update(o),this.metrics.routingTableKadBucketMaxDepth.update(s)}}const rR=[77591,22417,43971,28421,740,29829,71467,228973,196661,78537,27689,36431,44415,14362,19456,106025,96308,2882,49509,21149,87173,131409,75844,23676,121838,30291,17492,2953,7564,110620,129477,127283,53113,72417,165166,109690,21200,102125,24049,71504,90342,25307,72039,26812,26715,32264,133800,71161,88956,171987,51779,24425,16671,30251,186294,247761,14202,2121,8465,35024,4876,85917,169730,3638,256836,96184,943,18678,6583,52907,35807,112254,214097,18796,11595,9243,23554,887,268203,382004,24590,111335,11625,16619,29039,102425,69006,97976,92362,32552,63717,41433,128974,137630,59943,10019,13986,35430,33665,108037,43799,43280,38195,29078,58629,18265,14425,46832,235538,40830,77881,110717,58937,3463,325358,51300,47623,117252,19007,10170,20540,91237,294813,4951,79841,56232,36270,128547,69209,66275,100156,32063,73531,34439,80937,28892,44466,88595,216307,32583,49620,16605,82127,45807,21630,78726,20235,40163,111007,96926,5567,72083,21665,58844,39419,179767,48328,42662,51550,5251,37811,49608,81056,50854,55513,20922,18891,197409,164656,32593,71449,220474,58919,85682,67854,13758,35066,3565,61905,214793,119572,141419,21504,10302,27354,67003,46131,32668,15165,64871,34450,17821,2757,11452,34189,5160,12257,85523,560,53385,65887,119549,135620,312353,115979,122356,10867,193231,124537,54783,90675,120791,4715,142253,50943,17271,43358,25331,4917,120566,34580,12878,33786,160528,32523,4869,301307,104817,81491,23276,8832,97911,31265,52065,7998,49622,9715,43998,34091,84587,20664,69041,29419,53205,10838,58288,116145,6185,5154,141795,35924,21307,144738,43730,12085,8279,10002,119,133779,199668,72938,31768,39176,67875,38453,9700,44144,4121,116048,41733,12868,82669,92308,128,34262,11332,7712,90764,36141,13553,71312,77470,117314,96549,49135,23602,54468,28605,6327,62308,17171,67531,21319,14105,894,107722,46157,8503,51069,100472,45138,15246,14577,35609,191464,1757,13364,161349,32067,91705,81144,52339,5408,91066,21983,14157,100545,4372,26630,129112,1423,29676,213626,4397,88436,99190,6877,49958,26122,114348,60661,29818,293118,50042,179738,16400,163423,89627,31040,43973,36638,45952,5153,1894,109322,1898,134021,12402,112077,68309,190269,69866,31938,107383,11522,105232,11248,14868,39852,71707,186525,16530,38162,106212,11700,5130,16608,26998,59586,108399,230033,43683,48135,82179,2073,5015,196684,189293,16378,23452,8301,35640,11632,214551,29240,57644,33137,91949,55157,52384,117313,5090,17717,89668,49363,82238,241035,66216,29066,184088,97206,62820,26595,4241,135635,173672,8202,459,71355,146294,29587,3008,135385,141203,14803,6634,45094,69362,50925,546,51884,62011,83296,234584,44515,56050,89476,87751,19373,12691,149923,19794,13833,35846,87557,58339,2884,19145,25647,12224,11024,77338,64608,122297,53025,7205,36189,36294,170779,21750,7739,173883,75192,35664,224240,113121,30181,26267,27036,117827,92015,106516,55628,203549,67949,60462,60844,35911,20457,1820,920,19773,8738,73173,181993,38521,98254,76257,46008,92796,5384,26868,151566,22124,2411,15919,186872,180021,28099,152961,78811,80237,62352,102653,74259,184890,16792,123702,224945,29940,19512,75283,14059,112691,92811,233329,20411,138569,53341,109802,50600,134528,66747,5529,166531,31578,64732,67189,1596,126357,967,167999,206598,109752,119431,207825,78791,91938,10301,27311,24233,252343,28831,32812,66002,112267,90895,8786,8095,16824,22866,21813,60507,174833,19549,130985,117051,52110,6938,81923,123864,38061,919,18680,53534,46739,112893,161529,85429,26761,11900,81121,91968,15390,217947,56524,1713,6654,37089,85630,138866,61850,16491,75577,16884,98296,73523,6140,44645,6062,36366,29844,57946,37932,42472,5266,20834,19309,33753,127182,134259,35810,41805,45878,312001,14881,47757,49251,120050,44252,3708,25856,107864,120347,1228,36550,41682,34496,47025,8393,173365,246526,12894,161607,35670,90785,126572,2095,124731,157033,58694,554,12786,9642,4817,16136,47864,174698,66992,4639,69284,10625,40710,27763,51738,30404,264105,137904,109882,52487,42824,57514,2740,10479,146799,107390,16586,88038,174951,9410,16185,44158,5568,40658,46108,12763,97385,26175,108859,664,230732,67470,46663,14395,50750,141320,93140,15361,47997,55784,6791,307840,118569,107326,18056,58281,260415,54691,8790,73332,45633,7511,45674,143373,14031,11799,94491,35646,96544,14560,26049,32983,25791,83814,42094,231370,63955,139212,2359,169908,3108,183486,105867,28197,32941,124968,26402,88267,149768,23053,3078,19091,52924,25383,19209,111548,97361,3959,24880,235061,9099,24921,161254,151405,20508,7159,34381,20133,11434,74036,19974,34769,36585,1076,22454,17354,38727,235160,111547,96454,117448,156940,91330,37299,7310,26915,117060,51369,22620,61861,322264,106850,111694,15091,2624,40345,300446,177064,1707,27389,54792,327783,132669,183543,59003,17744,20603,151134,106923,53084,71803,279424,319816,11579,21946,16728,38274,72711,5085,83391,88646,40159,25027,34680,10752,12988,54126,30365,18338,100445,230674,44874,84974,143877,123253,139372,28082,91477,144002,13096,219729,46016,50029,42377,14601,6660,58244,58978,23918,88206,113611,64452,17541,41032,10942,12021,49189,10978,40175,37156,10947,71709,106894,112538,57007,137486,150608,152719,40615,7746,279716,13101,19524,28708,40578,72320,1096,182051,94527,51275,22833,45164,81917,77519,48508,5421,140302,37845,149830,5587,27579,5357,428725,248187,6326,206760,39814,32585,89923,44341,288753,284443,96368,31201,94189,119504,20359,52073,103216,179,27934,32801,96035,34111,34309,101326,18198,20704,210266,37643,27880,141873,106e3,19414,56614,167714,66483,107885,86602,4379,20796,75467,4987,5017,118857,26003,34308,114428,29198,6686,29697,73632,3739,69795,16798,41504,7207,30722,21436,36735,28067,28545,3239,11221,36031,41889,100010,19247,317673,29495,174554,6424,129725,53845,94986,7955,59676,2604,191497,19735,102214,62954,23844,11872,179525,261436,34492,428,78404,142035,16747,17246,27578,37021,33672,57944,26056,135760,2369,61674,122066,31327,19374,157065,40553,130982,69619,71290,38855,72100,92903,95940,51422,165999,65713,57873,50726,7288,20272,2081,42326,22624,81120,57914,79352,19447,1684,72302,11774,302559,161481,96396,13692,414988,3721,79066,56627,46883,21150,11747,12184,5856,113458,176117,84416,52079,27933,3354,59765,141359,2212,216309,2555,23458,196722,142463,45701,44548,28798,19418,215,29916,9396,10574,114226,84475,13520,18694,34056,4524,90302,62930,13539,19407,77209,7728,38088,9535,2263,23875,183945,17750,26274,67172,10585,28042,22199,7478,51331,66030,26774,192929,31434,25850,50197,52926,178158,4679,181256,70184,229600,9959,105594,72158,73974,2726,35085,78087,23284,35568,51713,155676,5401,27254,11966,17569,223253,71993,103357,111477,55722,30504,26034,46774,35392,36285,214814,41143,163465,1051,16094,81044,6636,76489,179102,20712,39178,35683,125177,54219,30617,52994,25324,50123,2543,87529,58995,10688,125199,12388,60158,125481,131646,7642,133350,65874,3438,97277,101450,10075,56344,116821,50778,60547,98016,106135,13859,14255,16300,77373,173521,8285,45932,37426,4054,114295,55947,7703,39114,52,51119,128135,19714,60715,9554,50492,88180,2823,118271,52993,122625,97919,23859,37895,25040,33614,32102,20431,3577,9275,15686,43031,157741,110358,1884,40291,125391,13736,5008,64881,87336,77381,70711,43032,49155,118587,70494,4318,10168,30126,12580,10524,280104,104001,145413,2862,84140,6603,106005,13566,12780,11251,42830,571,179910,82443,13146,469,42714,32591,265217,424024,92553,54721,134100,6007,15242,114681,59030,16718,85465,200214,85982,55174,165013,23493,56964,82529,109150,32706,27568,82442,5350,14976,13165,44890,60021,21343,33978,17264,4655,22328,27819,75730,16567,55483,14510,17926,45827,150609,3704,7385,272531,161543,76904,122163,52405,2039,19165,41623,14423,228354,3369,176360,85491,7122,35789,303724,4465,13628,2233,55311,118771,20713,10006,221519,45115,71021,35650,29775,7337,10864,20665,21142,1746,15080,1624,32449,10905,105743,229797,7701,3940,22997,178467,57208,389057,39683,59403,63344,63125,54847,69691,18336,56448,3362,37202,18282,29648,138224,35867,10495,5911,28814,26653,31514,176702,26550,45621,11734,4525,40543,73944,121080,27858,155561,14887,44670,30742,8796,107455,113472,56369,75581,183777,240095,133699,153299,8768,160464,26058,49078,103971,21875,71486,44888,17156,9678,89541,123019,102337,3972,83930,21245,87852,109660,287918,183019,686,10100,39177,283941,11274,24736,26793,26214,25995,77011,141580,4070,23742,46285,46632,30700,26669,19056,35951,115575,174034,56097,35463,87425,24575,44245,38701,82317,85922,281616,100333,147697,61503,7730,84330,8530,59917,61597,17173,9092,32658,90288,193136,39023,20381,56654,31132,7779,1919,1375,117128,30819,11169,40938,23935,115201,101155,151034,4835,11231,74550,89388,59951,91704,107312,167882,115062,12732,72738,88703,464019,158267,57995,60496,737,14371,123867,4174,243339,159946,7568,16025,134556,110916,38103,191,80226,88794,29688,27230,10454,76308,57647,77409,113483,66864,14745,19808,12023,46583,84805,16015,17102,2231,20611,3547,95740,250131,34559,108894,8498,15853,159169,148920,20942,2813,93160,45188,210613,45531,52587,149062,39782,28194,57849,60965,84954,89766,84453,100927,16501,27658,165311,103841,54192,207341,19558,20084,319622,5672,205467,98462,61849,36279,13609,147177,24726,165015,209489,59591,31157,6551,117580,75060,141146,277310,21072,22023,106474,63041,137443,122965,68371,5383,42146,98961,113467,30863,23794,4843,99630,30392,82679,13699,241612,33601,93146,24319,18643,32155,95669,40440,15333,34089,67799,142144,58245,38633,114531,117400,77861,188726,5507,2568,8853,10987,107222,2663,2421,11530,13345,30075,41785,118661,104786,17459,12490,16281,71936,193555,17431,5944,71758,26485,77317,20803,367167,158,7362,93430,11735,172445,46002,11532,54482,930,62911,2235,23004,179236,4764,101859,208113,22477,55163,95579,14098,67320,162556,90709,156949,3826,57492,4025,34092,87442,104565,6718,186015,28214,14209,10039,107186,233912,58877,81637,55265,39828,6194,145813,50831,105849,4974,88319,122296,10272,197216,95714,51540,72418,23324,91555,8743,140452,250249,51666,34124,7229,38592,129641,78169,174242,22464,149964,51450,14034,10026,95376,26190,120062,14401,8700,265,31386,143573,7203,229889,61567,4227,140981,2466,72052,10787,10062,30958,6099,38471,30103,23202,208101,70847,467,58934,32271,32984,36637,24107,30771,17109,73353,13650,2098,157040,67366,66904,106018,265380,107238,18535,44025,32681,144983,62505,91295,56120,3082,77508,10322,63023,36700,81885,224127,16721,45023,239261,111272,13852,7866,149243,204199,32309,22084,42029,38316,126644,104973,14406,43454,67322,61310,15789,40285,24026,181047,6301,70927,23319,115823,27248,66693,115875,278566,63007,146844,56841,59007,87368,180001,22370,42114,80605,12022,10374,308,25079,14689,12618,63368,7936,264973,212291,136713,95999,105801,18965,32075,48700,52230,35119,96912,32992,8586,16606,101333,101812,14969,39930,759,193090,27387,42914,12937,5058,62646,64528,38624,25743,37502,3716,4435,30352,178687,26461,132611,42002,138442,35833,59582,16345,8048,60319,49349,309,47800,49739,90482,26405,34470,63786,32479,85028,39866,47846,11649,23934,29466,2816,42864,31828,7410,74885,49632,47629,111801,90749,19536,18767,105764,59606,21223,10746,76298,22220,39408,7190,79654,64856,11602,82156,272765,17079,70089,245473,51813,184407,384678,1576,122249,5064,27481,6188,25790,74361,27541,318284,45430,31488,620,93579,45723,192118,22670,51913,4162,70244,35966,26397,16199,50899,209613,121702,287507,2993,36101,132229,67345,33062,76295,118628,78705,52316,34375,107083,107454,44863,127561,33964,3073,154010,190914,55967,39074,6272,31047,5550,41123,26154,98638,47110,19998,148091,50229,31329,59900,195442,19106,61347,73497,70015,682,45850,25776,38022,148951,6288,37411,232526,109277,27286,32342,9262,5220,16651,23175,46740,129438,78614,121925,66914,88710,127952,5563,21500,34521,10739,14863,191006,62956,17359,16749,67027,56284,69134,43301,35039,58883,54466,60823,404451,75743,59856,86979,7923,34273,83785,32142,7693,268986,197428,282681,17049,22346,22990,92245,107180,3357,37104,96724,49153,7683,31197,43267,82231,164276,23696,20848,188364,22309,24821,158707,1018,22514,70922,27792,45589,59709,10765,736,35218,63479,51987,24275,63588,55361,92929,81964,4658,20122,12330,44058,13065,311456,72224,8337,211229,38979,22590,138478,52757,32595,133600,8838,31549,94412,43391,90056,1585,94802,127271,6223,31889,137038,132910,2165,57616,230152,6080,10748,36737,74579,134062,50525,180532,119270,34556,76155,82394,52595,29258,31435,87820,67996,26943,183878,38007,2410,13526,180297,69856,3503,187396,167700,7838,16701,9199,56267,3661,37407,65994,23767,5708,62508,221700,67088,86978,46776,84434,32088,5612,9149,88244,21685,95151,46750,189612,2979,506311,2594,3628,40074,105039,78243,28523,6651,38058,71999,30992,12764,68261,108991,6165,26450,61961,13400,22426,7490,60890,109623,2070,12958,50355,67979,257096,7213,42578,52121,35716,65461,7516,124758,39268,302,64712,14977,1467,219452,2840,34229,11121,21602,19270,63574,8024,1532,17331,79839,78885,52029,180767,57957,6069,91265,61380,55767,8927,32881,287603,22149,35029,68876,6428,199567,46926,13412,104132,21434,366616,45060,110046,81924,128910,45886,52821,130416,29416,77342,21762,67329,121432,79924,11724,38625,81006,102033,28338,13326,3250,82056,82526,38212,21112,12382,111495,3263,7414,86274,93490,40844,30224,45212,24019,48411,71367,24941,76729,57776,3769,38114,202019,197745,31953,237533,33270,201580,255648,100798,44741,32241,98468,106931,10085,15090,170358,33154,66787,18819,69760,25061,234005,82660,6295,131975,16874,9076,4094,25005,17740,40908,19533,220019,44330,99792,50040,19619,13950,55228,24423,31253,95308,103177,184795,28590,82285,5059,3210,75525,49894,70007,56178,10580,36051,139681,21617,98736,3555,106306,164189,37352,63915,47824,24883,145530,61904,28444,11483,19837,145446,30420,112972,85939,11835,191233,2262,20705,58630,1753,148334,1197,144714,6887,11223,107667,60879,77914,4151,57417,81594,96681,169430,1784,20444,95138,254041,27038,596,7117,72808,13759,3353,126776,21074,55322,27081,36942,39547,139830,179275,4453,713,8722,71399,19204,25785,22794,23923,104114,11291,25458,102309,88396,75288,230440,206396,104551,58447,130857,37247,94734,31548,176529,226077,65159,20104,10096,66881,94191,237909,27109,37404,1520,27421,25220,113003,23423,24884,50585,6286,231877,150800,11789,3226,90004,60642,5053,202400,61442,132531,175329,57138,30116,103847,9973,75367,16452,32360,59119,21246,10191,164804,23305,61051,37348,154530,13214,5468,50403,66754,130976,50559,80515,14436,155492,84017,5472,43107,41240,2890,90431,70188,382,76234,48040,50211,281038,237007,32115,142178,1536,22761,96429,1811,31243,1679,49143,55209,17402,235054,61494,7462,77030,34925,87609,78002,9499,9027,73289,201078,101379,63544,27666,5469,10642,30029,49816,132979,95620,58086,351930,116300,2110,2043,30845,6154,11279,16727,4122,2277,27281,4971,3650,39060,61970,65951,39674,75686,38151,11370,130809,177895,32665,63725,122267,7857,39618,118483,44792,157755,178624,136994,24260,41308,22471,12404,21707,12486,30473,52781,50246,20247,39065,909,56825,103158,128603,31542,1089,41935,32744,12428,37963,84420,33134,72921,208449,42622,168151,127335,147107,46699,38216,12591,94342,85814,31423,24944,2605,87542,67473,192551,4496,56321,91819,17630,6300,256183,114569,202090,33209,35289,34897,24967,40520,43470,5344,10199,34810,14283,10381,10017,62923,49924,23233,64539,13051,35686,19698,11570,135555,120868,44924,87065,52318,52335,47586,140906,245885,109834,78668,9065,46990,25258,72022,61243,40838,4545,146387,10537,11557,17470,36930,68104,46711,24264,79401,81043,18225,120488,24746,84338,81652,28266,13776,21878,46973,1047,230465,73357,95777,24973,210160,62210,58404,110633,169651,6937,41870,9909,26822,191062,76553,27519,96256,239070,2478,205678,67955,58532,20601,50120,19148,78501,195724,110740,8249,109665,27446,30568,57631,31425,49752,32820,65504,50079,3663,102256,219898,23849,211315,14645,4359,91767,9528,12449,49366,7941,49763,107848,8930,27086,50686,9744,10447,81935,39513,46514,1670,29229,6172,22312,137280,97759,9806,14445,22976,56458,73391,34983,93760,174219,52573,33149,59747,2429,136277,75123,165263,91040,7446,57632,48633,97140,246081,84766,151684,79918,93268,120346,54059,54875,77858,32996,103590,45276,11968,19600,25849,17159,132907,42828,16817,4913,99462,103303,27395,5737,74184,20749,21160,14377,77062,131403,158735,10999,27799,77785,9320,34366,51593,61070,33746,47048,29268,36675,30262,53297,9832,82e3,20188,122292,39917,7331,18160,68301,185935,134830,15031,4935,10004,165845,185534,46923,30109,44134,122631,18874,22903,112790,26561,18549,348902,82871,140345,255565,135390,63556,103747,145055,179600,145662,296111,61661,211987,23952,52342,126343,48450,32919,44277,82185,9591,62139,205363,376969,394874,108461,18040,120885,14798,39863,16571,16794,58271,81025,55206,14640,118656,6361,44092,85970,6262,153863,108244,180200,72264,79947,38044,10050,5735,61221,80712,5471,115689,11391,11661,184257,20010,60116,30320,19327,134598,45455,27542,18004,125092,452272,1549,91523,46567,180063,156026,2608,11174,58848,37788,65907,80194,30490,5786,40775,119519,106241,11323,156297,8425,61495,2617,29675,2425,59886,112582,49142,59618,4863,50597,86710,50650,168632,27693,85641,83643,18993,25768,84284,28090,93592,36627,312804,43381,9887,9402,100931,97165,3311,173330,66805,28935,4963,184460,3201,78102,19126,21607,37496,24938,22615,16153,32862,134792,153318,61120,6067,2812,12826,12792,23825,37559,64662,202250,102694,155488,85881,149193,46233,65383,15521,106982,11358,176786,25752,39717,34208,24510,32464,77742,39371,72028,138229,60688,71386,102834,132477,2208,11548,63670,271279,28351,30338,38620,32491,99845,143885,152266,13252,2825,178663,108097,1775,78201,14897,113573,163346,62292,171129,22183,96598,38733,64971,166776,117445,9968,146393,44677,74867,20908,97328,12761,25656,26785,9148,112344,26115,99176,110121,22437,49547,6180,79320,5835,31392,43328,33377,75870,119860,69497,80273,7325,155219,43167,111173,28347,20222,3763,71752,55041,47252,14618,28088,15012,97805,194698,54636,2036,41349,6173,96604,61530,51859,43782,13361,24334,22668,24792,7070,23441,16789,3209,36211,208475,26242,32880,122181,182407,21444,31060,88459,29929,77907,12716,10934,97005,20599,31690,8403,58445,30303,22700,10336,86731,103115,337709,72556,46788,112566,47684,67089,53548,36874,56487,41387,125985,26893,40071,106683,73712,18787,40105,72992,67246,137276,50802,36790,70328,138827,22466,39263,183295,29858,50975,9322,57397,10654,24364,30383,55799,41600,23584,127295,296610,129078,143558,244131,86397,36049,1085,80677,3820,108139,5476,34767,24683,7758,13060,7239,131671,250593,59556,103392,29810,4188,252323,39404,116877,7651,43600,40338,13554,157253,39196,25978,144387,61211,234,50104,6129,10449,93777,9240,356378,274148,4439,72970,3724,147770,78680,62570,115877,40027,40547,36817,224392,64609,34795,165027,67440,2477,37206,23431,50754,164797,46018,94995,170982,27051,7957,22767,3674,27900,56419,18930,60701,41302,2692,84749,339721,61996,111094,80221,50129,1045,8153,62945,19202,8250,37208,37418,32560,79477,41106,88569,33963,36693,5892,30570,1581,66471,49647,11922,160717,29442,5643,114865,82962,95982,132098,22633,22838,94726,54556,28566,205039,162340,33216,16849,35847,221339,94851,26533,71469,1805,3804,12935,45483,71020,36310,65381,192960,34240,35165,59773,1248,46954,155332,96864,4246,388800,16129,57133,74592,44807,442014,38203,42574,80818,91592,26377,36424,65760,977,77387,22628,147610,28018,30561,98454,6969,119628,63648,18170,36854,26601,64018,22027,37279,51395,152934,21153,9430,58760,194742,5330,55115,34158,28917,174111,13171,122326,1526,43896,66094,25325,4234,148354,11450,275,18999,112191,44365,22723,68409,8733,57746,96565,75007,14196,108844,29475,88599,177563,100792,106156,86323,93726,14248,135341,194131,40126,47099,14779,8272,39597,95983,171398,65882,28052,10393,47213,40689,22120,72212,106829,34964,109146,753,648,21660,30047,17527,181025,5619,145357,4085,216883,9359,186951,24779,53931,24545,36197,223296,62628,168101,4243,107313,30321,26642,13049,51059,31027,107912,807,73550,26551,84369,122422,165872,49754,74213,234264,33151,52014,33100,87183,22365,52500,40013,23302,5652,72723,21404,26107,48434,587,94049,168493,96418,32871,70860,31709,25128,443,71597,166253,15670,70994,26341,133675,28280,75491,54756,47955,56028,26182,11952,113272,472197,64640,110753,17919,337,50642,22576,142,87371,53391,93210,126694,15285,19642,85667,14148,1506,42092,52962,33243,11970,20734,135843,57044,58880,13002,219134,22876,64754,232519,4257,43120,321573,24799,64526,124728,52579,81472,70831,276848,17403,74359,23021,182101,74597,23744,148267,12055,7976,5349,11772,67540,167347,65318,18720,127832,108238,22828,90233,9987,259080,118185,73209,79270,13775,90100,137742,90799,70569,15699,19961,9087,67475,57872,39731,8810,134897,131868,146849,19898,3334,2281,167061,91073,60356,467742,74712,188,53179,137679,92769,29241,9537,132595,80119,1041,88962,5976,40171,44911,102859,139059,104558,98987,47761,19272,71472,113864,175377,73338,10857,23402,23758,1591,139864,5644,4076,118760,16427,134198,18853,20291,100849,37423,22038,36677,19071,195521,57445,11069,31869,55718,66882,148490,44,41296,75242,49704,166810,9906,20943,122258,49112,105667,15969,10344,6408,187694,21399,72742,58970,14867,14376,81889,41856,23225,15042,56993,16074,131389,74276,72407,53875,383108,53597,37363,68993,44854,122548,430927,198279,38430,80409,12245,2981,628,2818,17760,37437,238229,7968,46892,2200,3730,34190,65983,37959,112291,87850,70827,6522,20750,73913,111621,41652,19587,2780,58668,25916,85259,18200,168962,95781,42445,102050,7776,57662,103313,47742,96358,41964,66174,100396,29069,204735,19679,27978,7479,40264,22534,61183,36081,107436,58223,14680,23002,101311,24716,124108,12908,5646,31750,40380,14215,232799,102772,14122,96775,61398,50917,12096,149880,67833,598749,124194,155871,49216,790,14677,65319,56917,7440,145744,95701,12206,49405,129269,76199,45732,9767,11058,9047,210885,11051,7392,26307,2130,8132,147526,20802,232698,115660,50060,59789,57344,107623,80343,112676,23291,9866,160971,34032,118291,15719,59730,164911,28975,2659,58046,78480,21854,66209,53863,109085,116045,29021,46481,107552,22130,18764,70254,31272,11300,52460,43933,84738,20721,53869,190840,79673,105300,7561,321817,66924,13940,33281,101046,183181,32176,71878,5678,62924,79535,56646,40303,19559,27703,93042,73368,42187,3670,37376,46440,7023,36816,109628,20680,5940,276440,275233,170848,112093,136996,14984,20226,111441,77693,112960,48577,39370,55707,50314,123404,26570,54281,61372,123391,4857,35928,246740,132507,106646,44241,7196,92258,9825,37688,51197,303141,5590,15476,132986,10955,85782,34486,26696,7991,28813,18858,39546,11703,11365,38185,5716,93555,11925,40121,60002,6985,10976,171384,3887,43394,13337,56346,6381,252336,39573,75042,53711,1028,31781,44295,95925,131713,7214,68125,43571,70954,213234,1628,8760,13391,65485,17320,56038,1710,25248,60803,57399,19839,3870,326,281556,50945,72400,21460,316244,75619,56246,98775,481,13513,55765,50427,7388,123519,32929,57908,27124,61316,101097,57467,30228,48792,10788,20402,37318,50526,155730,34456,158065,145305,17832,43733,64052,4506,35072,205355,177028,184004,187081,68616,35938,83703,10367,36892,93186,260137,51934,89970,4985,23445,26755,21558,7948,78741,23376,124405,85594,68596,57536,49351,12619,56593,132668,99924,109728,71844,71935,196018,65464,17617,14987,89701,143773,33997,8687,22701,33258,2914,4436,72108,85610,9671,49067,2327,82988,1361,1672,44033,35777,30269,24057,10605,82236,616,15793,13919,47249,112086,116698,9484,80207,90574,33304,68624,93127,56101,42210,160929,4827,38995,38095,4701,125119,5027,33680,9236,231236,14135,87837,23318,70261,78893,30151,81482,14332,1084,74256,27532,46644,79185,3148,62615,6981,55672,31668,36825,1849,14536,37446,14738,23779,43058,162749,72199,1168,21346,5592,85932,85302,9668,18351,57135,150360,2080,228015,77953,34670,119302,151751,31009,106725,84265,45214,59289,74178,113071,263206,111009,4021,44449,188119,192629,123592,392506,292847,114487,12831,205858,9852,20780,79648,75767,357014,97721,18166,21005,67950,33226,204009,16536,2987,11335,66717,144910,47950,17262,55060,15063,2934,51038,26775,178497,66008,3427,49433,128592,20036,157553,63861,3089,23015,51210,28696,35933,49942,71135,231518,99620,17248,21835,176536,20676,16944,38700,165831,233253,295625,36723,13023,52745,10907,19423,67972,125868,95473,82875,1183,108455,52685,33417,64095,21433,52438,33191,127809,44505,211823,7810,2752,95548,162031,7185,91196,47563,61721,33359,17897,23682,42806,178101,22874,49707,199897,75419,82456,8618,11171,79712,116847,18783,44190,46564,5346,59046,95032,7893,14916,3214,26800,24172,121453,34362,10250,17408,18888,4840,68696,22831,13162,36005,32512,14800,62357,41723,45046,27247,37486,5372,2564,34261,298500,66509,133920,89138,31305,117697,19097,108304,81386,84106,23802,46411,63304,946,51417,41777,41041,19501,115864,60743,294354,37955,94165,18116,1156,17937,20645,57114,90804,58042,48643,92288,9861,2557,88546,61333,101008,12853,5148,87856,4152,144503,73841,18718,9789,147565,10846,42085,12789,30223,8993,56352,67203,2448,28215,6052,23540,126319,75933,36689,80235,23231,23561,21383,38800,77548,102798,21234,31468,158608,46188,63960,191679,8051,67014,11185,170078,42186,28827,34777,41930,212079,12421,34750,24111,110344,73918,45171,70826,141949,40063,23979,24254,37309,26724,27179,24718,83648,54938,14591,17425,29525,102675,48975,48654,12316,8929,60640,41709,50168,63264,89812,50716,48632,38755,138583,160123,55579,71829,24230,233277,46322,39650,166388,34718,24108,98252,7031,106695,62498,18258,35062,217827,78731,34824,33354,19520,60852,2432,60224,8587,2836,62955,702,20227,42285,40560,95592,62486,11094,53035,143291,18842,46177,77994,1770,9657,107422,172915,32655,128716,25886,25164,156740,119928,165875,85817,11007,89110,33956,12652,65156,180266,8494,36889,19958,20955,96,1264,118288,135769,44754,86671,5632,19026,168220,289120,33569,93821,66144,70635,7687,5642,2714,55445,56636,71545,184182,93133,7332,37389,12643,52315,22729,11014,158742,17050,152889,50178,34601,41945,52136,9948,26914,63548,95721,115951,40759,8960,158258,38938,49232,48325,42234,81523,253019,66128,40978,20048,238048,38760,62928,122560,118532,43687,137472,163689,26680,9878,17448,51035,16211,60834,36749,29178,14241,59868,150086,2305,26477,42422,34342,165341,83279,33894,14257,29928,12743,13957,125571,89134,66712,10952,16507,147839,30146,7249,16565,45399,39874,114565,215780,31990,230881,171477,102,196546,44538,10880,84948,281705,86651,10617,31395,2342,453658,43569,60561,132901,21845,17727,58556,258242,22262,58728,4008,77997,11806,37431,30599,81375,109137,185787,114085,217292,97453,169085,30593,60212,11544,102056,65580,2384,91655,4855,95725,7295,157994,16228,20669,53276,141590,105246,17334,25440,76067,17967,39321,38911,11362,28559,63807,21627,26468,85816,40120,1025,15234,58319,69516,66512,124548,75845,78873,22137,46681,51242,85683,32909,76747,35555,43396,101465,1765,73094,1077,2962,39028,66777,57831,42048,15828,13962,36041,63657,52412,5242,58846,2141,5506,219012,134451,3936,182230,17558,17153,152237,22621,49377,170216,35257,68233,65374,6510,11126,212151,7184,2480,22517,3437,33073,30156,16557,3768,55067,86829,91e3,12350,148650,66017,79424,70885,49066,28250,21369,51213,34533,11510,3258,18176,18465,84413,6315,36411,163765,4346,356,107618,598,13727,285026,162695,8749,14583,7132,63521,184253,32378,25991,5604,30961,53675,4874,84693,5086,34811,26978,56564,7904,33519,51221,113942,69253,6664,125563,22055,220680,102008,742,51930,19494,176108,44424,35123,13025,75685,11759,74335,22250,181453,131147,16984,132115,154311,11991,76452,52609,85351,196,30969,9198,74919,2529,56838,71779,29187,116304,3504,62330,41190,86153,28393,254926,104228,105189,13264,84359,3574,12415,8534,57147,10175,188174,59504,60932,66318,16407,107921,17638,99103,49278,28403,39786,145865,8462,3558,43406,142271,29139,21989,36552,93955,72365,7176,13556,106185,37957,321774,17782,129017,51154,27938,24952,1935,39366,2791,33489,41582,56078,24558,9311,5449,218786,27808,190429,68013,36020,86003,29735,3404,87348,119357,115714,2324,86796,81973,40992,43376,93621,28784,16808,36367,2517,2909,191926,24978,55303,53308,205724,60068,3098,21375,64784,23949,26579,63121,12319,80145,39967,97861,6757,70143,67642,37082,34698,69140,122883,46151,62187,80934,429,19437,135071,137885,222647,13331,154065,327,61778,74257,40116,37493,14855,85079,237641,42342,102164,199965,71204,4662,29368,5042,113914,122214,8955,13149,102503,43173,5659,163787,69003,307084,63392,171080,21390,81918,86666,36622,24126,28887,5736,28054,207170,163428,79891,346467,95363,38980,111806,80828,9200,19288,294896,114468,87405,111715,141705,7015,72754,68463,48738,243147,33397,101210,37051,98801,82847,20397,4940,185559,18716,54718,83491,11725,40803,1128,12128,23060,5174,7745,67007,46701,1571,27807,180186,256996,18975,16837,7877,212758,250379,15440,87954,57755,24719,124057,83461,258,50864,8874,29038,71289,31627,15429,9005,4061,113851,107716,82819,13651,79656,117851,17539,111446,12938,39724,190787,4352,15402,21070,62708,8539,23777,73853,13552,38810,86117,16285,56400,1718,75342,142863,29033,378,110113,180321,32586,23606,26393,160984,207987,23783,8406,16904,24596,47274,11693,46539,60524,78595,48423,31718,20170,9009,146268,15183,191060,172765,1349,138436,37365,10970,40509,225817,20021,70394,152138,21541,66559,66544,89352,2725,17258,91345,7313,3815,115868,8660,40362,4071,103524,39388,118275,21950,6549,38226,32754,209574,29201,43495,18028,20296,40597,18370,47520,202450,24134,2219,8195,69545,38041,136934,46374,19041,159811,84865,58620,846,98749,13569,30714,97246,32186,4479,27355,92973,35214,151491,75963,37631,1561,27200,238083,23182,60756,12291,25766,39355,102333,87362,65741,59906,19538,201575,48772,102938,24438,292580,39964,66366,9004,61379,50548,37622,38732,28379,68180,76622,17488,69849,5963,7219,48143,43413,55358,540,58691,29506,19245,52193,48621,5518,13048,118625,44755,191081,42061,89197,2259,60665,66994,71210,51232,3585,142096,55024,7892,8345,58653,463307,65658,64319,137941,136323,53499,12746,43492,6978,95163,29925,60175,5128,7352,41463,184756,121146,20473,18426,4598,5309,54580,14277,121151,10691,56711,43880,63409,76682,11830,172218,264898,32632,66536,81062,31649,25788,92774,60222,11100,63159,9432,224657,25240,53613,152,138620,163829,2397,85345,12501,37507,64932,38575,43522,65789,80198,78796,35226,3851,108891,73311,3060,28391,93671,39663,46142,30982,66041,37281,68157,26553,71872,81142,211527,39747,118119,22695,2859,11066,20232,168911,7933,197005,17066,111071,44434,133994,120798,12766,227798,45756,132852,29917,36076,55352,65281,129800,41958,18944,84678,18580,168093,132621,39997,54092,27740,32354,3770,114118,103242,43918,15899,18574,145944,3190,123469,219903,24169,100571,62403,16776,92779,14535,17168,16475,14304,37231,1712,28218,242754,61688,28980,1318,51359,222657,99200,67989,31772,23932,35351,201251,49041,27306,19128,40135,3986,77333,19649,120683,151927,21081,7076,78375,77501,101599,8011,89585,96715,58179,5378,102138,106793,26051,217276,4197,16297,27014,46721,13322,22806,5278,29629,70632,9647,71519,58818,40603,128530,8903,36770,56900,31483,26935,43845,34265,34920,87658,6114,84767,64250,47318,50720,19264,162514,33357,13117,6705,46696,75032,71054,87004,42035,69138,11903,99854,102328,19611,34525,69312,6431,49842,101600,133178,108751,41829,89939,225664,48916,99556,9195,130387,5960,36857,116724,53518,94002,39077,53996,6945,22261,64291,8314,152785,57588,16522,9091,5048,87671,35441,39509,1945,12423,158923,178413,37549,14095,1475,73188,62878,4819,24012,68534,42606,4010,120809,57497,59564,101758,103718,32701,80116,12345,95834,46918,21468,53213,15665,31200,3867,5140,96013,250744,21016,10069,13968,35449,180829,27683,39704,59956,22893,3115,26293,32785,75934,62445,141162,62720,2018,83638,19949,114012,95006,3330,99829,130935,309272,9565,55874,121727,37017,23586,319858,40970,27602,8625,112329,61060,100088,118525,25922,16232,1907,60671,51583,44553,80993,5262,94679,8676,940,20736,11823,3020,16476,12340,152600,97416,3703,25744,66826,16245,16876,46446,84798,74227,176020,45192,61955,75496,23946,23626,40372,26036,6149,11822,30582,16541,41914,82385,232823,40921,80773,14930,3631,7517,39619,4348,36180,126106,138939,62611,1477,113512,47321,25052,14546,118881,29060,23589,128322,36795,18401,137921,104699,267929,36194,172791,18113,4766,188215,30083,332586,94089,5805,77909,22194,68234,154976,43220,40660,70001,184893,138095,11128,103010,22663,5108,212615,8485,5565,49222,54614,26530,42639,16319,55062,152662,105595,21114,22216,10294,68158,10436,86950,7206,62115,3977,3657,59874,456,118617,18156,106663,112229,80992,17442,8217,55551,5133,34344,251927,51153,39364,201321,7816,66803,23057,156724,145664,14276,95705,979,2796,6875,13429,212525,50602,26276,28284,3424,19465,52397,46963,31420,51399,206476,92317,48851,637,100820,83349,10317,60227,21972,6908,282439,32857,224767,95629,83882,42106,87338,69757,29840,68709,37665,45244,114577,49188,175943,54009,186746,106158,70168,3358,234002,50555,9221,129338,9562,20118,32923,78479,118280,65752,4977,10474,102174,60947,129006,10570,83451,8598,8078,159367,123785,80438,16742,5905,5281,181513,42402,6977,163136,93179,42191,14968,50421,112401,105440,33456,57347,121611,4221,94954,36517,24046,27796,6255,33394,72990,135408,116627,1233,57874,25654,95419,68156,401399,313338,55208,45573,93124,119251,47200,38196,11909,130667,45391,73904,64964,167846,4137,115606,52036,62214,7969,160925,7187,1132,134835,40309,73195,64494,80472,444841,61111,26500,45323,40743,53625,52797,22659,15631,29739,36706,28841,39147,102836,26794,10536,14845,87305,45874,12241,127587,83833,57183,79722,30844,41304,84655,20825,92500,3722,25655,27811,10157,81634,31362,34088,92487,70123,22190,185100,72658,139035,192523,88241,2078,230490,44528,85638,100198,22088,29982,291233,241062,13865,4445,137791,37835,107218,31726,19718,38234,72528,23046,19177,66695,5109,17251,28077,5617,21554,47839,72425,133825,1486,73065,181275,141508,21768,62971,63082,2512,34200,9904,120309,6392,91243,68416,268253,41199,116757,138551,185526,41246,28986,4093,19057,17295,4148,245766,122360,35356,112075,20301,75441,10998,7977,19769,62922,937,63547,100196,26427,157820,20983,236696,22935,8140,90315,156004,47204,140973,7726,45097,52725,22636,23436,257282,105247,522,88389,216031,202204,46812,211666,19693,68828,81691,45925,11256,30292,372,5236,167826,88328,232776,151611,5360,82104,18841,80393,25465,18285,20320,72377,31730,33160,45803,38715,27705,37379,24163,18360,103586,4015,32305,269494,91252,20080,36567,54650,7797,57073,12650,31164,42209,6375,261663,105528,81661,106002,2800,5375,17247,43151,4442,15727,194619,100855,144898,62320,78465,39929,16454,1967,28311,61363,17219,9395,8745,121445,76939,80385,162380,22009,54191,44248,16299,122830,48151,74429,78291,64755,14238,44966,2511,17712,67954,93583,829,105899,49935,84750,11591,33185,85447,42717,27409,208542,28965,62052,52525,5597,25694,65594,16343,63224,276188,12475,9331,127507,38522,57287,24128,133161,79723,105548,133695,48917,27558,43278,46520,13778,141954,110785,83366,17715,46317,105763,66298,147013,41086,94180,16478,220447,44611,730,19722,78975,117889,125643,26254,16574,18480,65006,15806,38549,246418,46052,36056,8440,34984,30170,3163,59800,4458,115442,4283,41970,33507,104078,1653,22,121158,276486,3655,6338,24048,133421,23641,2161,24422,36006,8086,10675,181474,12307,29514,59143,14729,52509,87128,122470,19446,80852,33314,24573,119864,14237,9652,57779,6612,51851,15284,98871,90581,124466,156831,21190,22015,71380,161906,87247,69201,18392,17908,108470,72962,40719,14338,17911,95260,43339,20610,78916,20710,72451,11315,31448,17263,58853,178878,48111,116002,45497,80506,82605,85880,36300,121755,25215,36118,301929,88728,405223,276136,553,34704,212438,49970,78329,922,20711,25036,257130,38295,145369,18128,15385,30829,55656,48345,8012,3561,28004,122041,192900,58338,112508,41085,29976,87040,47117,23905,4336,92061,138880,97407,42083,172121,6256,25192,172671,5,93568,1420,12677,31605,56743,40620,6015,78415,231077,31298,80026,13902,19048,24924,170586,32955,176119,87859,36731,6773,27711,24658,26475,115216,133207,93250,95820,88522,8317,5714,124047,55219,86860,19677,23961,22928,162209,8904,225992,359835,56084,96201,29392,96558,86071,93643,55114,13347,8183,95129,82012,2017,123336,34219,115554,157159,47747,101684,41008,18735,193781,104151,226906,7552,179874,124113,31159,21162,44010,14771,51268,166128,31382,73124,77438,92830,205709,12113,1292,38937,13114,1334,2118,15597,69581,14449,21934,76618,48728,67038,14967,51495,24243,87736,147249,26720,11119,46063,43749,5843,44147,152629,133428,65703,14269,45604,57982,28672,55616,45957,8438,95433,37698,220862,132034,39456,61870,4161,26501,73560,56418,9845,4654,20916,10456,88920,119358,9015,65931,96507,48029,38534,21676,109081,43078,34943,25089,6131,28766,23665,5477,10255,16695,67,45778,42443,42770,29534,23733,100513,62617,42630,48746,14191,43753,50295,26007,8792,57243,43119,54725,164253,58250,112304,131796,25165,4651,3188,24831,47748,3705,19540,13211,102095,5593,18699,23666,32005,117571,33541,60584,74573,86311,99443,25172,27222,168938,7143,11853,53560,18834,19960,86522,28217,53266,117700,72989,34323,18721,66450,34346,74056,47217,202002,46269,9429,68582,75458,37823,82843,96652,32549,145144,27958,19820,158086,31955,201406,135379,31207,192545,12950,51704,9094,248263,76147,64028,110009,79407,89345,99284,223492,47966,26848,15359,201137,2861,110507,71231,72297,31851,118777,71039,151051,240855,16333,50766,14727,7939,4149,80908,418780,88378,59276,1327,7284,38576,79814,65820,42199,84860,49574,62596,12396,70598,40117,8648,7994,16836,7630,14047,359699,106878,525,29037,28064,13380,11675,50669,74216,103539,180314,27449,56299,172344,19274,7301,246099,32043,19422,36506,129317,6806,30140,4614,46639,66926,932,86600,6322,27847,233103,10541,39025,34887,3517,12972,26220,2031,66561,115015,48658,47596,12714,33845,3893,16165,35237,89983,14769,11962,147224,47018,29977,27979,5552,82338,86023,131368,1218,24853,237840,132193,15455,40873,3668,65351,53388,15229,59889,272245,47934,11858,34347,18038,90853,86981,300602,19343,114181,29362,84921,6095,106059,79472,38015,1206,48741,6208,8e4,21916,17423,6002,108083,24479,34931,56661,9511,26995,100694,163853,35997,81254,58321,18919,171890,86877,91341,74503,70477,53412,7027,59281,39892,131302,5864,15947,61301,67466,162369,47956,27874,35624,282324,21270,111847,102548,41482,30955,116737,28264,8592,55458,22301,75090,29821,30697,51709,3041,19208,8038,24634,30467,87509,126428,19389,18814,152686,20701,83474,45832,80891,105808,11378,153223,120770,98186,150633,49838,9141,12755,30962,5260,74490,21256,31678,65062,33326,289838,187831,20595,89768,2805,58535,10844,70085,12090,2451,138068,98544,24461,4511,6754,41684,28203,3383,65355,82833,30161,83924,234361,128424,28921,222594,33975,125491,34069,11508,67464,144226,41850,98703,34371,7901,21254,38398,65651,23549,53883,213340,123269,12028,71764,177701,28758,2623,68395,11549,15232,68603,9660,63116,36079,57093,31198,20475,48467,89984,35619,186847,107469,31389,43631,73867,41949,68841,114250,1605,30564,63403,17588,27680,99533,12641,70325,50428,73426,78379,11855,91651,72081,91720,60198,15743,12065,83398,140046,6761,46598,45900,5068,886,62448,148968,37347,19405,9680,15819,43496,63370,75667,163700,37639,3633,22774,34341,183131,134335,37200,23915,7054,14194,12970,26438,13350,285521,25594,8219,104410,91039,168804,138480,149734,15907,33818,61132,60082,4622,110187,56736,13551,73571,3945,73463,65498,17758,263266,17593,2710,27585,54469,38200,45367,63754,28881,3473,12791,98287,31895,65787,4463,94536,24951,36332,59901,28803,52130,86403,7668,181822,74831,18977,9850,177206,145485,109798,7292,31421,26280,77211,58511,12507,127004,11113,147,8729,56208,43066,79926,129937,31345,83947,39915,46146,98763,42566,1337,13192,18323,105163,80570,117753,16555,72883,11077,159438,40764,70933,83329,26066,12276,72059,21655,173836,126713,69454,153482,91585,70644,102558,110483,6764,127864,190133,3961,101798,20945,71138,82402,90884,69669,44753,923,16939,59700,164258,25969,27082,31399,43846,6306,246093,51342,6153,151581,202801,182731,56475,162188,89426,141356,14355,121815,27536,28023,65257,77523,106668,127314,24947,12790,38796,169698,23555,10725,44573,183083,42088,62716,43265,105958,32050,44067,50118,1668,3874,6243,318411,16599,1691,94999,52378,28671,216728,123258,2059,34969,69225,5913,136280,171443,141515,91662,22175,135282,80020,92270,1663,4808,4482,3495,34691,5226,109830,108512,17342,107488,11606,123190,100247,29666,146527,113014,15794,30894,13224,39585,243192,22351,9903,7836,47699,11078,25468,122291,48821,26780,122679,75521,81450,630,4895,92900,55074,74293,17441,3563,111657,103102,51613,12318,52370,36191,68245,34269,40445,41354,122901,168604,182500,62012,42557,11259,24428,115113,86345,12362,3909,78430,86852,134602,20459,47853,93879,22577,7659,3688,38555,13349,17381,56715,91639,12493,10895,92438,3142,37057,28928,2004,36427,32268,34222,209974,10432,67436,41989,173518,107930,27079,62729,30908,55558,5828,45031,14902,53546,8204,144263,60255,14520,88212,86582,109589,69356,8064,47449,8505,66558,16886,4844,52817,111260,215129,12941,91118,650,20770,6273,73089,40618,62790,2873,35002,14023,97208,19386,102646,36993,143736,135457,35385,113601,17893,32627,84439,100619,56016,6581,57264,172160,45452,111710,203627,70131,24100,322787,1996,35665,70078,22358,90922,83658,4097,63200,58499,14542,99153,52159,6615,12414,63415,31986,16823,1579,65405,137809,8841,16898,48082,259,33014,42375,12260,179850,73667,91389,98882,29532,17311,326251,41092,5928,20742,44964,48019,43505,9317,49265,6643,192712,48424,163487,19861,20113,70848,31928,105333,23685,78563,14638,54755,7158,24142,44018,20774,125255,20331,24280,10163,1285,2336,39851,4299,117269,46714,63816,87779,159624,11731,9971,990,137317,108831,50994,74554,162680,23640,131597,146962,170620,34829,91205,21184,1913,63616,18427,93136,156592,17519,67565,115882,138220,78622,88535,18115,2711,33554,109492,54298,971,24914,25863,36363,45715,27099,194995,14299,178181,111488,72395,322385,157719,130787,11897,81843,83999,11369,49280,118604,40922,61332,110343,53407,75639,40582,300440,54722,25637,13694,48248,48278,194521,56203,52779,48783,72627,10953,376,16733,280238,26351,230789,15132,25168,137270,3588,63704,73376,94031,74284,19443,159557,9697,39901,13351,119050,15406,146455,3460,29556,75195,37673,102524,92329,47289,98413,15311,100684,56345,7116,95480,11590,7200,167,23610,58426,17730,136656,27944,53151,2701,8824,103124,3017,90744,113588,53216,79736,65940,26931,498,29568,80540,143543,21292,1740,59268,16561,180816,42323,50174,40890,52866,10703,57169,4700,17191,4424,93511,49698,166650,26972,48631,165169,82879,69326,202970,4007,2376,231325,139592,22119,62851,37504,68816,58345,67398,186643,43331,277416,53749,15746,23102,17432,4793,151138,48822,54265,48203,198688,14305,54287,2291,18018,113378,123260,7180,97549,87027,120085,2920,76080,8190,102005,5641,64580,14955,59802,54028,58884,19367,81779,412567,85957,97053,103637,78871,29364,27637,141728,4767,30686,112738,130146,42745,12730,105040,14844,232,210944,36581,152317,135543,29744,3129,55647,58149,46319,27265,17499,28005,59948,7170,34138,5702,293047,110892,408,91760,218674,18469,46095,81403,14389,4610,35672,73060,11006,74848,104820,118143,190357,20043,105358,141735,5115,27093,45924,123073,52599,29433,9616,238350,78610,24851,58858,26769,31969,24613,18294,4982,32735,39639,143563,112073,202205,12567,4873,88601,44897,81503,101648,81362,34662,85277,17574,48173,21435,221188,40215,39576,80786,26544,64668,81841,10731,37733,247986,149188,127703,495,18382,54388,72446,43071,30974,198723,89608,41360,190,33045,8386,31658,19992,237838,119015,137622,50890,100913,6460,116233,267230,26621,104129,65114,14190,41542,14888,85962,23342,23041,26453,43725,71809,45186,4770,46452,53894,56616,221286,18973,9038,109299,55365,19366,26863,18808,60909,69353,41738,83463,12100,68561,72860,3980,13796,49340,12332,31311,27418,4255,53430,18976,45523,510,14224,30477,26581,4530,3651,101663,139840,22709,150861,31996,63923,120623,262522,3076,10528,2929,14672,130238,18087,9816,121894,100308,25085,55111,14565,18952,53293,2042,369988,23674,61789,133529,28783,108293,35477,47119,36448,71049,40015,33055,78598,198442,1833,159937,40654,77444,189245,113153,8621,18599,38553,35223,166072,2375,11659,21786,89523,6032,12116,63046,159398,18454,3678,32521,47626,11411,103527,38896,42946,15696,26370,10185,8413,37080,165583,4331,63555,14907,72220,50056,6623,62236,36565,49783,10049,17503,100581,55951,146244,24724,9626,17969,25524,109300,173965,99994,101056,46459,43647,53737,277968,8347,123521,74858,33829,44762,77574,877,81377,222525,123532,30602,43881,53145,2973,16284,81940,61281,127044,63620,9875,14756,114829,19032,9202,52759,119141,23928,120551,19607,3599,33401,76821,73233,117430,39968,36539,7071,5446,121735,194059,15206,45283,6706,15603,65615,1207,165723,92275,34773,104447,8396,32353,205240,164323,13600,60555,79205,25532,22907,33410,57480,107111,69630,32137,47832,70913,33161,20321,2371,117348,10714,86246,1625,11763,17900,268,78457,99175,97940,101092,86660,32221,14041,128504,125080,53744,124263,31017,13897,403,31859,21964,5633,111630,5547,77329,17961,18241,84995,25984,12983,67491,62168,47262,5241,297,51191,7351,8967,147212,82060,16821,782,11033,82431,62957,5026,43459,77963,203477,53528,6247,191852,87774,74164,215654,13467,1522,219964,28589,244104,16242,117821,67725,72570,156792,17186,15979,26990,44128,193014,35276,57125,16212,166451,68017,6905,77608,16364,53777,75921,76426,37975,26203,269296,64099,84122,12077,38533,830,4407,20139,963,43028,38902,42911,37503,83343,85045,16979,1165,60835,137387,58380,86990,110066,134540,56331,193845,81238,17922,163093,38744,110641,12502,56404,34862,26865,125964,12965,111648,25547,7771,27196,136980,9555,29551,107158,57885,18831,37705,35505,101742,13970,102109,62548,124657,23328,11124,89592,146376,248050,6241,22033,18337,80685,29898,11908,216623,67721,106162,146610,21377,15085,91552,42041,62560,122532,125336,102365,121537,142559,29693,223919,11515,110495,18776,22494,5895,185059,103592,229351,51220,100102,37027,257855,29359,54123,36066,106493,12244,79258,32002,432,56205,94836,90182,6726,14762,29391,48938,26864,38083,60364,3310,60192,14766,205567,57504,110760,22649,24666,46333,21517,3430,13135,28873,27052,158809,11597,20529,6695,23138,22960,37137,45574,6545,305877,43423,26153,24769,59844,14501,10430,134352,56169,13213,103432,49523,35181,13435,12408,129475,64620,230854,77390,51990,15653,83248,33466,44571,117828,51481,2187,10559,68019,18021,54895,48247,18354,33737,4554,108595,37288,39767,116707,9175,3726,108877,21616,83684,49862,1938,8543,276466,20134,108498,48770,102254,31914,131520,185291,100559,51890,209,19526,76471,50544,71814,99351,8172,198526,28816,20419,9109,98389,136777,76479,75596,30635,165417,48216,120220,25955,211071,39314,24308,32164,2559,146280,43403,9233,17947,90585,1786,86920,125662,2457,64741,32152,32918,122882,78538,44001,31723,56426,23375,103172,88177,145697,52506,49319,68016,31664,41488,18486,110400,7030,28241,986,109199,19900,42147,56864,65287,49183,7858,24e3,30453,840,16673,25907,68916,89927,6309,158335,36407,199737,130464,13137,59603,201778,195292,21015,42466,179062,172561,89492,11075,180407,31868,72493,20998,60217,9865,19530,39274,130266,54539,21623,12535,13505,40641,73375,4087,85633,2153,3117,70680,55788,92096,47509,98493,37490,271936,151475,3032,16171,96642,34106,78425,125761,19591,3366,19316,54508,24183,50786,194248,91528,33253,34622,108355,41741,705,3814,3883,108929,13203,67831,10142,59754,68208,29128,84820,56880,38794,24972,48571,40821,40476,18137,164254,24064,236309,79181,11282,395,39169,2013,51587,28551,9645,701,109513,115899,113566,12762,62045,58322,103726,41343,40866,244102,143816,2490,70346,40973,52618,15412,30720,104315,38917,42027,93676,17513,107418,20706,123890,13399,97727,24044,87962,65606,44250,98044,65276,74790,101473,19350,91570,1326,87790,172042,7577,100813,86896,85891,41512,108130,27794,14875,71431,12835,156250,58135,3759,22476,42176,115873,34686,56523,73643,108505,51491,20838,12721,32863,45700,29496,13700,34294,55360,29206,155942,123812,7706,163234,203,132720,49358,144431,8130,175788,35818,3270,76832,25710,54095,97274,28779,94621,74396,19092,128242,58067,20885,14670,93255,15107,63291,23654,126900,129421,59294,262659,9798,3251,67344,28600,44629,50672,29072,26999,31526,23183,49175,165843,175455,17282,175411,32022,45989,30298,90690,78118,83156,23749,35636,31317,7069,80381,94561,133756,14960,97404,6138,41065,78041,32843,16601,34123,9559,146529,123377,96395,54441,42012,84257,123541,10745,22139,106459,11720,150883,172651,154996,110538,4728,53447,25704,2009,71152,119354,21166,66604,1429,216162,8637,122250,63520,27180,29172,36124,276428,107787,77184,4680,14952,104903,24418,14793,51561,52931,8371,26342,48526,7118,92066,67280,40653,8847,34597,105438,14198,50163,61188,146286,50315,41205,170829,161496,585,197359,95056,1687,365794,91349,48507,5804,49263,5146,104902,96365,117343,132222,46084,96919,16875,8073,262381,79982,52663,13928,16056,153908,15145,109256,132308,18763,24904,167644,13618,40750,18686,147124,114709,150038,52849,2938,12568,48617,8778,5459,44202,44591,74914,17183,248689,13878,7822,80060,23116,194037,18487,2067,7798,43077,33678,244028,31320,74273,2794,19466,8218,36280,183997,48124,19416,29656,19280,98734,7715,18311,30701,133602,150307,126956,7378,2933,79903,13178,12593,86571,26604,92446,13574,44205,65699,427599,21118,8245,14407,27877,47936,33542,7916,26460,117762,21596,37818,2249,127359,209394,60044,47677,308089,36791,154971,31417,6998,150042,174360,12255,43009,29335,48739,3912,101398,53340,2580,146939,151295,45360,125275,15273,45383,27456,48761,23314,8750,60801,85823,104759,27894,123685,66968,39480,26917,55290,83305,2696,98390,57569,145853,340733,4919,20024,52268,30884,7413,203685,70989,112855,4129,50536,349518,68205,332641,159581,135361,236026,37563,176404,64899,6578,122033,63871,1850,85234,82089,66124,74145,121098,107351,12687,36881,117334,13136,14698,85933,93866,18047,32620,310,15094,46e3,88451,23632,36645,27940,87618,80520,58892,20976,27702,140090,96075,67841,103292,238964,87778,107338,17019,83427,67522,7302,8261,47570,116787,8730,80484,61772,174422,56005,131193,52875,14588,28471,59817,9586,15720,158155,51307,109734,15196,11025,59331,3884,52626,102602,84797,25158,27314,4437,20488,76214,189248,35023,114952,157376,2827,62439,102878,129749,36405,10329,109339,108633,36662,1254,13267,5470,87105,58004,15397,10434,159667,21864,52022,179464,3013,32147,31496,116832,18494,105502,129227,107267,50033,13481,9954,24267,22141,16257,116154,36185,950,115685,11305,176708,2048,178671,112573,287867,162328,497663,95170,50979,193861,50987,30368,136257,31830,46549,15119,169876,23788,17462,249887,57377,1949,35448,14791,43769,210091,3783,34612,282103,88380,245190,5457,20491,98908,11402,86899,117916,16028,162584,60644,320177,156096,31065,55876,22e3,77655,9992,23397,13757,317623,63978,215255,2443,17648,93231,27388,104529,93807,55505,140477,12046,112040,70887,40152,94365,112353,25063,114679,266061,71248,119555,15589,2244,617,14129,211431,70110,100652,7777,4383,85911,89221,21010,120615,58357,86405,37554,41647,18,15143,69662,60491,14714,186134,148344,42347,5410,168175,44535,42449,343894,129417,99682,20659,27272,140483,63455,222159,17536,13722,42637,62324,11976,114691,148109,2283,32057,182393,4295,147364,33705,2075,44303,30274,28331,63740,69740,29148,10346,44862,33716,73937,153333,12930,38784,247159,2515,41053,20256,83368,256189,54639,115240,5096,24661,175419,153552,26516,141,138176,63885,34115,47222,55709,2765,28479,38875,236608,12229,22921,77291,54426,45388,2860,57787,114579,295139,105782,17826,71066,19119,54364,69385,16568,12323,28057,33346,34919,124763,155533,101386,31644,8627,49001,303600,29868,63213,9103,77280,71333,9696,138789,37059,24823,5057,21352,32368,114208,56803,19424,10445,58514,8661,209508,26187,171838,10460,63454,14016,122504,41328,21329,46618,32493,38225,7855,31763,7945,29876,8734,6438,24205,97490,139977,130740,47323,33195,85390,57194,13813,60600,21313,96251,7699,27584,170521,139271,1363,4402,336738,129223,84983,69150,13147,3590,163929,207225,155260,55916,20288,4503,8398,98490,11773,27512,37113,84976,86558,28365,11756,116005,182148,13733,115313,47644,67208,85069,9347,14995,226141,14704,101835,41159,35314,13113,63526,214039,29978,50446,83339,17440,129441,72522,118641,97816,24907,73844,15717,118884,167255,96509,162793,30847,36849,51297,78974,77793,10427,1873,2972,9999,35074,28190,64297,146836,46298,60038,163007,108919,61219,2403,75022,127339,4233,110389,69022,9833,128097,88016,79390,222936,22570,94657,28462,56956,38803,81536,30474,152794,19566,16481,147408,74574,81895,20731,1918,1366,76367,187321,54494,24366,21690,61696,33283,107477,77499,31112,414383,74362,18463,218441,120929,59848,258629,201924,69269,454,19989,13054,59894,3623,58908,20681,35723,78523,102680,38988,184112,108087,50944,132704,52966,21699,18860,96349,201411,82697,85395,95658,5093,6427,177894,44191,32755,26961,155739,6249,31310,81030,26574,84311,120155,86730,113535,7424,48888,13516,45747,98098,20077,183995,81945,43210,26704,40420,75831,45648,11180,6855,57927,65528,124096,34851,2598,156633,107572,127352,38169,123845,60142,62722,105584,232364,23211,68120,1601,22169,89299,747,258039,80572,7258,152249,11862,101204,8834,121434,33761,19175,133142,46343,40178,48723,3589,41977,30210,38868,62257,10087,82658,87827,90646,16415,47552,351723,28298,72225,91146,272760,1701,11295,1652,109651,300747,51863,198800,29446,11794,32345,37538,22356,33102,37590,113544,37970,11478,179743,25454,103417,59905,221970,105196,145604,7817,164809,102360,16974,75840,255333,56902,6659,1954,645,59400,67769,7689,18675,5215,13793,20536,27852,3387,29523,259718,16860,94625,43143,29245,15848,233581,22685,63631,78557,22836,133302,84513,1348,51826,47129,98836,58284,1830,1749,94642,10933,6145,12506,10975,13879,103781,144434,10268,28409,32346,52968,121567,107374,77268,23686,35097,10501,155275,15303,47136,21102,168741,55332,90385,15996,84817,681,137803,25054,142275,6163,38175,8056,124296,240642,65621,4934,178205,16101,62803,60964,18230,100622,76465,44689,14545,9543,47514,16852,93380,28048,12047,107106,37575,101485,77047,57326,34819,96137,76916,6469,46264,115983,75768,87668,69942,13027,165,8373,114231,26434,52844,42799,182044,23580,146254,38081,43236,33883,146220,382894,14606,46035,36481,166621,35417,95382,2957,59384,60428,36358,66343,75378,22267,22950,83528,17577,56474,25285,4619,179691,75355,95836,53295,34588,171410,4487,14679,84208,44015,18562,109133,54101,11531,86052,174479,303157,28095,9953,35642,14564,39802,16145,77606,117406,53038,121117,53624,22062,1212,7632,127157,237292,189087,10478,127345,102515,181997,86752,87623,10966,121602,68783,68681,83042,114380,138349,191305,67176,50085,39016,1427,42384,1412,67118,122616,72389,25260,2237,13576,137346,19938,20304,2191,68759,5373,61364,238507,75814,23931,69565,38993,131741,38364,12528,87762,5679,129853,5310,186831,32653,90338,260176,389531,108118,26843,43985,50175,30563,25106,56965,18130,140428,4542,165503,117991,24219,229605,1819,129663,1240,3797,76093,18398,71339,51919,93043,27175,47060,216257,6483,35051,1217,16512,80798,129064,13225,69339,8548,237079,72298,2575,34280,51379,117910,55671,53345,247552,29486,39328,140821,34681,57045,60177,5004,90269,78522,2479,322607,48474,61296,13057,31558,4678,59271,6699,27044,31988,35944,12503,83480,4389,136508,3781,114121,70279,4488,155829,42214,2898,68191,75695,305850,45041,74344,106509,30087,17429,93292,12477,290,23080,114802,35714,18751,26554,105424,17775,2144,2412,100610,65192,113975,52975,180272,135050,129815,76238,106483,21440,63186,4260,46189,9711,28249,4169,23429,23390,8324,141585,63809,67668,38457,38063,39226,59972,1189,203916,62368,14403,16949,61767,85801,1739,40147,35049,76757,33124,62102,15780,103593,103009,53484,22952,67973,114645,6566,5245,50462,7601,8288,3513,194571,80276,1908,54592,5124,58571,2513,6800,273997,193904,1119,17991,117245,2508,129156,82366,26278,71465,63341,56943,39662,106116,94966,156875,9736,2204,122308,94418,27134,1280,24539,49022,45314,3764,50904,46424,30699,28087,293839,9400,33646,40165,822,147499,50263,116179,29085,11863,31314,5578,17797,5104,12454,1604,15342,219206,10232,67800,94261,25872,13565,90339,78971,75377,26649,41184,47695,11514,35369,20767,14227,41953,309396,148270,147938,33074,14453,27499,109019,39018,25738,240196,158931,52820,8612,95853,21524,137010,84901,70869,70021,116794,48404,38771,6732,1070,70990,187297,49140,5238,576,3564,253975,16027,16483,2811,37775,19034,25259,4053,2e3,70083,95774,19713,33431,92703,91314,42381,288770,48194,95985,3991,77418,13406,241328,245086,56533,35275,62725,9246,51924,70181,95331,16163,31410,79016,39312,120878,119371,275987,80124,27712,9186,220,23598,146167,85209,68238,282190,57048,31273,30555,80913,17594,75779,59160,135002,101219,189377,29225,96735,60126,62522,104e3,27620,86814,17240,147533,11001,5425,43682,410,49460,87270,69480,46315,59448,1816,76201,9431,11788,87960,29063,65539,47347,11678,33846,7008,196704,9895,6753,8633,120892,59970,572824,115934,6646,202559,892,48351,37611,251282,57823,67263,57750,26527,34485,90747,7685,88370,6144,64182,1709,41969,21458,62327,181657,49247,225330,122600,114574,107124,85361,111833,63243,71420,15655,191178,72430,18063,51425,54002,12364,53225,86557,18193,97580,41232,138398,67821,128724,8944,233212,101353,52099,42127,14006,120107,32789,32132,3498,18123,33758,56058,5779,128760,59888,98869,18445,84702,51911,13234,218379,20093,39031,8074,70195,20708,23462,24355,131384,60189,26390,10403,41060,7140,10781,49410,42261,87202,82566,41663,43105,60276,2768,5733,74176,28329,2297,145430,131632,83615,122915,105441,655,224102,5284,136426,67763,16294,188511,32538,61049,27893,3394,13951,159099,28542,17930,145360,9492,190122,32285,78855,26440,13570,58648,73908,4239,124561,2444,74172,53131,11468,10794,73566,11623,35343,64710,30481,4163,10328,38309,29901,10538,154377,76132,92405,24839,11679,3465,13449,11637,7824,2337,57754,1260,14458,41118,19878,38661,13416,159180,37074,163164,54137,28627,52134,184900,8520,40385,29546,30502,22386,66527,107458,6850,24022,47983,30603,35083,8934,304066,39500,9,28261,33026,77251,9374,44833,116312,34990,29236,63563,125639,135405,165398,159055,55690,88141,69643,236964,31983,25572,20436,36746,60896,31850,16179,11828,5888,3043,66368,9750,31167,7915,53111,36430,1333,64344,93659,20061,60596,180191,51630,6792,30244,43509,101058,22409,420,44210,109783,43223,27030,72477,72831,32679,29235,7675,47556,12258,39907,149412,84926,118247,24692,71717,105038,86009,45941,41189,89453,29856,52543,30627,226798,67303,59230,67415,34408,1367,99685,16867,128419,52147,4111,125381,117881,16173,44093,102224,31575,23234,24870,83790,127407,239098,3200,994,1255,100903,242275,117266,55116,38205,16140,29662,11307,40414,208793,123355,56470,4862,75600,30119,58218,70828,24075,26974,7802,192353,4851,5475,78720,66596,3409,28573,64396,30381,30690,59859,88256,5406,99945,103064,34463,37727,24238,86643,60088,4057,23741,5967,162904,38240,28356,93858,25510,122879,6897,3278,7057,11971,4400,35461,211413,21395,59615,39471,87233,55795,128426,3051,22470,41950,14705,3974,180108,80476,78442,204996,91987,15634,67610,139015,142373,35611,51134,10387,4353,153456,57749,181039,14183,68447,151532,21107,36452,20551,3186,46247,46383,129666,88736,140662,146243,2066,8360,7978,64818,106963,17896,47801,10723,114821,223295,74192,3293,3393,16987,74064,11277,91622,4270,29828,27951,387869,103235,1374,61988,120083,477,145892,128378,11779,211263,61354,18221,17869,46530,83061,108538,157981,90608,67199,95080,49064,195814,12302,66307,10348,231346,160732,112859,63633,146558,21271,31037,198802,47622,12862,95710,3910,77850,73961,85585,34752,61e3,4082,24595,103679,71107,8208,79568,150019,16615,24961,139857,32664,197366,4559,54735,32696,4126,162019,75698,13916,70108,159638,19834,9349,24675,175560,49643,18206,52459,27992,10809,88865,401975,133172,29e3,34558,30915,3658,25834,42430,36562,125265,18182,10155,40149,97082,208980,19575,60853,90529,66545,9600,789,46420,2317,88593,55595,98980,115302,5742,169155,1073,177901,3472,11189,63711,78643,65472,50459,127979,93,42202,67053,21720,157650,11145,141378,42033,22824,85705,79114,35584,15974,1510,54172,28562,12451,104226,19190,97151,73024,20948,5151,81741,21499,29006,84183,198074,54003,45120,170125,26240,35177,28389,64863,79974,60778,176915,232183,45342,2038,80253,41564,40703,32689,5430,100689,5366,23007,134279,14266,26712,73993,24934,64242,52113,102887,61801,46415,201049,54251,62133,122757,164883,30815,139966,2319,30842,766,13362,10287,134518,86111,81665,82440,28333,43019,18963,8804,161944,23439,102144,101145,80029,39052,248708,30350,117340,11878,128467,974,138625,63961,5237,74778,61834,67040,43814,13690,65947,33809,232476,115258,181745,28824,94013,9510,10246,93722,81976,7217,114383,3493,16014,69045,72692,12145,80981,9507,6692,1620,60820,330444,35474,33962,4797,7053,295463,46445,27026,12491,77988,49524,35675,90947,29114,166705,101385,133782,32704,6186,84595,176031,185623,45966,151302,63069,1699,107491,947,15458,74452,196212,6046,10498,12163,10239,35191,243951,9277,9090,29539,54460,22820,26514,112549,60372,51753,48756,21812,70861,260326,41,44222,10441,16961,48148,138771,216194,5914,52153,53400,212036,56519,26245,10117,45888,15294,138019,90913,26368,43842,42111,23348,6082,194845,161089,156206,51546,11647,30759,302912,262094,8635,78876,26535,35283,54183,31183,85484,147873,12989,5197,6356,72894,65347,20150,27370,73787,1493,45918,12366,190217,20724,13858,10981,67449,81213,7553,14115,72242,271517,11842,48310,88743,143726,22177,3290,243231,58452,62937,12592,1654,40066,33477,13751,9921,128442,15868,7106,75236,83773,10775,36938,10482,170465,17368,17469,161508,32752,98340,800,19824,264456,3901,87319,2867,26782,9630,113102,185815,24197,44584,86366,40224,3636,140916,31731,267731,9567,53678,72984,29389,27963,17106,50282,284911,60170,8322,12608,23374,89652,5268,39044,229766,8869,151350,31436,177342,12269,183212,120418,116270,2843,78888,69192,7865,184099,1086,129897,18383,70508,20242,18508,229924,124569,35749,50589,55626,9884,83115,40971,30671,18135,14452,38861,17844,201826,5549,26413,17189,13561,38539,10679,143331,3314,36785,171194,49685,187713,67506,4618,104039,17060,195080,50648,33159,19238,67559,134840,28599,157523,17130,38064,117398,94355,31918,13575,34538,40326,13997,3494,348283,62481,26862,3603,104426,244363,153709,112487,304612,199674,41239,35545,54869,293005,28223,26277,26899,4533,18518,15492,38587,80488,70485,160395,263,60162,11382,222152,4696,250751,51921,182609,10707,48463,46243,1227,49111,111564,46502,33342,56846,68541,63559,858,139927,16654,229375,76759,26478,33205,95828,23399,92945,2637,35630,28470,143992,50214,14174,21456,166191,65665,1711,21594,78019,97599,111701,36,147151,110246,189022,43021,30397,40757,131935,42065,73335,48039,26596,28984,15102,2361,7421,202167,69744,43766,52826,3642,83304,33873,75140,63169,192389,36551,92748,13039,123959,233220,21738,84447,77230,20228,187852,19095,25799,92136,108774,29237,53947,2299,118106,2687,8830,42331,202924,33667,2023,73763,30704,19363,19779,16737,35629,48081,24068,101013,162338,291912,13749,24745,328289,167679,70086,48299,23306,16732,17801,43322,54589,3586,63653,43624,53474,925,109177,251316,43805,13082,19511,86565,142182,92461,17117,101033,103319,64589,4022,4351,235897,5352,82705,107142,46391,156084,5860,61365,10558,13045,7717,18357,33922,12590,33065,6928,46993,783,46937,67846,8952,26295,6107,119656,18799,17458,50747,4229,179559,112727,118080,20683,41464,125468,51560,49749,44231,7359,35339,62988,136487,67015,5208,29150,24956,105186,48858,6143,18097,6972,16404,73489,58742,97196,36357,164616,5834,32267,13746,147733,15113,132091,34127,106298,39729,106426,22294,9780,15602,36213,71502,42808,66802,599,60755,5851,39120,67363,108623,126368,72770,91263,32486,30596,151717,7951,52002,43103,11768,68942,40901,39344,24037,127500,116890,48403,16926,86750,17745,48648,159545,34460,58419,5634,114317,67865,31462,23352,24010,98185,125708,69686,68337,13610,26271,70691,2980,4768,27225,102402,75453,28106,8104,6931,1176,6274,6475,112635,22498,6176,238686,26832,28893,90319,14441,15682,15087,39517,45270,109134,104440,45965,47645,81772,7876,52683,87720,12898,4505,185665,2769,113401,15664,57592,105229,137381,97059,119268,6876,43309,33886,128363,35476,144249,67013,143587,83367,25703,91436,59347,53236,2289,16519,19844,46309,58558,99834,23313,218816,231303,36388,51333,183535,109792,139277,54306,90139,18235,8275,32710,37677,82464,86025,92204,88842,117723,37570,128723,234242,76350,73795,34896,148247,58424,11105,11744,45746,63372,17118,49772,199520,81902,38004,22911,33752,3125,1995,53792,4689,26909,108150,146062,69674,41811,161444,84855,8999,28561,16731,93937,3189,21967,24890,22943,1356,145300,51569,28802,517,118679,31703,40607,48098,108854,25003,10233,73969,177495,5248,24516,215347,146192,48712,60626,69188,40735,5866,586,101541,6509,47590,52129,5969,222045,110933,25733,24223,65339,62812,2414,155418,35819,16022,78423,43138,20995,128255,240673,46745,236093,72176,57085,97841,61248,107,36068,193177,105427,55726,215229,20446,47228,100420,87091,14429,121708,23605,21157,187721,21880,2997,203976,99166,95068,25877,7724,98925,83401,4829,13182,18229,13718,239662,38653,116505,153497,30589,89029,38962,181302,43853,78872,180301,4786,248240,7401,106136,112590,77745,19731,60880,77789,125748,135487,5975,48627,34084,12419,215770,47557,254582,10364,106495,21856,67539,88981,38805,21428,48732,42316,12149,16078,52808,25327,51322,33850,51147,12253,122354,46077,56483,254553,115417,81834,150991,94662,86668,7381,12841,100650,18218,15741,22372,68294,50705,15535,84660,61887,22553,72299,31361,24824,17743,46820,64288,31582,77006,111674,116384,30760,80920,86149,77192,51979,79691,60342,122805,103800,240873,160744,233114,78962,54920,8608,3484,316104,72548,24337,5088,230040,21926,10172,36838,26,86221,83458,102176,12062,17571,41929,41170,28428,68239,41750,103930,2634,18313,53019,34825,97837,63115,24606,73157,152474,14715,91439,37033,109806,140259,30668,174760,380,135597,95673,136073,65073,134249,13829,17279,122305,4420,46444,10237,64848,203623,70728,10349,182885,65075,24519,25783,40318,34139,22222,63394,55266,102764,41422,20126,65100,90408,53640,35128,48932,11192,38935,96839,34782,39492,19396,41332,6250,5511,19492,51304,25936,104466,54099,73771,86115,5080,7669,30891,111700,13931,25276,72289,135447,14820,258641,25265,31005,281179,75286,393,95359,14623,13584,6680,101227,80173,44933,76666,54542,13244,39348,458,25379,109451,134348,81143,6959,65554,12027,51311,8716,57589,140731,28467,23316,17272,30458,25980,55229,77197,83798,28302,114784,7428,34548,26241,14712,39336,103304,18928,54080,12870,334,87722,15208,16895,142098,114262,39820,83913,57817,28682,7721,14900,108672,11250,62246,42849,415188,1724,26555,24549,25505,26443,107450,145899,61035,43528,6901,60726,65906,267741,21338,147590,42079,18924,73017,135236,15393,5206,4026,84185,1531,5988,113890,82647,303391,7386,69844,71611,189865,76523,31877,13315,19314,198575,32821,1928,67641,25913,104475,103489,3297,70391,18406,15446,113347,19295,93790,27856,1792,167471,116449,8541,4408,41757,63233,25765,86680,64501,27034,24816,34975,6079,4486,49693,36229,16917,21581,62426,27862,11612,54284,35702,194034,355,24277,48262,87411,70504,310164,118018,12516,47559,43502,57433,107139,9290,66533,80863,14634,34312,91725,28606,21342,67241,72355,43244,375789,37402,174015,105070,8342,44167,67494,1890,16365,11723,271002,1865,47918,8350,45564,27742,25110,125803,8553,49504,81925,62211,4534,15491,19011,80373,206920,667,102405,128623,245524,5553,113309,192739,65766,19567,22832,261958,29679,21293,71134,20962,105123,24721,860,21752,33448,18372,157167,94822,35770,173224,232737,75729,28937,46828,28062,25453,5207,140366,36665,30652,6169,67920,150458,92040,23186,184604,92330,20891,176492,49427,27828,38305,42495,143982,49560,25503,90043,29747,65328,47830,12932,11068,77721,9003,25213,94205,140426,46090,89945,138173,192691,33329,112232,129905,35709,27514,1841,19957,31411,127476,53572,17497,173549,55063,175135,19841,69314,5192,237921,117660,150697,4060,273045,50414,98940,65348,153665,164423,58804,156695,48994,213928,86036,28608,8355,39574,34540,16927,135680,18374,151587,10830,53805,16878,16623,4282,48030,8537,14986,46102,13062,72897,72,33050,108227,39451,45935,651,113320,40535,95176,57450,48843,5003,19019,10407,211163,3848,1068,4988,32091,30095,41692,15099,43602,107434,50744,7627,171349,16313,150832,352665,207750,33937,38256,51091,156e3,87889,90663,84175,24908,114900,50365,31494,83829,5398,169342,47521,54818,18935,8356,43094,41212,174536,10082,92550,6678,60614,23355,69721,14796,34149,128830,58187,3179,208,40325,28399,225029,401412,51150,31580,207268,6657,10993,69818,64282,289845,23308,12961,38447,6681,52944,31855,2572,47646,120728,179148,37240,45196,218274,4816,3695,21961,50084,35209,18073,51452,27004,6100,33941,1377,84831,171214,85,141510,9078,99227,32610,6417,11718,49868,65579,87902,73018,49062,46280,61742,21512,40862,107733,15941,29168,157765,144919,14487,5767,158014,140070,7241,573,71584,16921,223566,40331,179473,35081,47926,140885,41508,52104,59180,42310,32811,29048,123517,102413,80208,10104,14746,12649,153641,126022,37965,113017,4171,83,142592,2809,6362,50416,71323,116894,260776,16204,1524,5760,30351,12658,20703,54403,36083,45408,74772,4946,14485,50759,111222,10890,2195,167147,92962,130534,16283,177256,35016,15472,210156,151187,73922,117691,43250,52051,37392,24811,24358,30830,5775,818,21969,1476,127322,151783,58392,31021,106913,65215,89407,90802,28531,11690,20234,95249,44602,37256,18707,11928,5161,4410,26571,51903,49768,22008,25252,65780,209499,68769,203726,13249,137363,48845,86823,6658,5674,31881,1083,1823,108676,34518,166752,13791,14287,91576,91429,8665,11529,26401,16191,91972,30964,5254,28486,54697,79613,66520,18447,22870,45203,194466,22822,51703,12278,76716,44595,73455,33546,12235,144843,36154,51247,11116,33040,3180,225753,60864,1972,28469,12891,28879,10338,144157,56294,353058,38302,41447,87532,110616,27065,168438,6557,1213,50804,144643,24817,2390,136531,38174,247513,16190,4059,122791,131994,137430,39506,57650,16305,5188,54309,106128,20628,88071,67394,395446,250285,66176,91254,1399,114196,43915,60230,44853,27206,106353,43013,18733,345105,226453,51202,16607,57106,117175,35492,10476,89598,127439,15187,39624,13688,61570,10615,31111,59370,6238,175252,32143,224492,41388,95408,34384,148238,78307,38959,9340,160091,61443,15737,11216,41244,170,38299,102443,113097,26382,14027,33707,3957,76300,66160,19431,18900,6952,1717,108656,82206,188021,257335,27295,43999,41210,31777,46956,57457,12657,11489,15697,48060,204748,53583,82422,284790,30503,137341,8120,19615,220311,15991,10217,63424,9808,67431,70976,98221,4491,15177,28535,144789,751,13230,2394,1504,33977,132104,30316,22230,931,97193,185240,24826,22687,174322,15307,22988,1390,188745,180325,29580,59068,74903,18994,29195,79,15436,7622,38462,11566,138710,44828,45774,37768,99236,68137,84083,19282,22698,17134,74807,126662,173497,46248,16938,119735,3212,28292,213652,49013,9975,32180,45660,86250,4801,68788,95490,77482,113751,11994,44624,94452,46839,128497,100316,5798,58588,73184,202987,65417,37790,88524,1606,43156,97964,105717,34947,11203,100060,37742,130074,93653,107799,94311,196106,41347,8035,10780,16390,27883,118236,167395,1979,25006,19375,31628,18916,144723,78502,114047,103107,86492,107686,5844,20934,206963,23556,22591,16562,146333,20167,10471,117434,33085,2863,9740,36669,41849,37271,22790,18209,28979,8231,12952,54408,21731,25130,45208,55748,138120,75826,414,29593,9925,292865,25999,683,123149,7036,92159,86055,61827,103680,23176,54918,58466,57578,13305,5709,86479,16697,31064,17660,200919,10770,49793,33423,32370,52047,16488,62555,6459,8426,83493,7763,59725,82812,18628,67760,79405,68557,9612,7673,28102,56517,69620,171797,32458,29541,15870,81109,32080,207644,71495,21202,11039,91036,61230,2810,130800,32260,4613,60590,37112,75214,33979,126402,155062,30642,63875,12810,194463,82799,47664,16725,36685,43367,61099,449,172150,102867,21691,301838,36745,7130,18671,57316,34852,38034,54182,35578,65900,99486,19771,3456,2658,16914,99866,28390,28109,8262,21147,34353,20006,4228,137085,1675,203023,283196,198286,214375,163329,290603,152574,40471,83506,30068,14730,23177,131539,34759,27668,32178,71896,104799,116305,85430,119262,42860,25160,8911,23428,49437,105322,6519,16203,6349,74711,1230,38045,8540,75165,44736,25909,51026,317034,4984,32281,91312,27060,44431,17817,45363,155937,239085,35697,59784,91993,29531,126740,213757,76560,167776,285273,24262,8237,65030,41160,74437,48804,118916,13159,37842,1031,75349,1478,11655,108777,23435,277425,101734,67469,70231,124711,43532,28514,65526,54956,1e3,21882,17728,25302,40952,52214,149632,1999,2111,3259,63362,89961,220561,39777,26335,9063,10572,12416,34551,34623,38604,24723,5947,15588,69927,66252,119177,69173,46629,28714,70715,212408,20521,406913,74380,11716,50659,50862,37009,88460,130101,7210,53853,538,65120,151950,55806,163748,52837,13153,21100,16674,64536,6091,138201,44837,58547,3723,163,2177,32288,85454,34033,8497,14282,25742,10535,10741,79559,117493,243787,49337,100718,79495,40139,42956,7551,55433,15421,31509,23034,45081,547,61176,53434,328001,8470,36263,30145,4519,74173,53935,11845,73774,60211,78025,3,4102,73782,109293,315332,48412,26683,13714,6865,20128,18490,104141,325,39470,171970,115860,15707,7268,73301,74336,31370,2368,111827,107757,136231,142844,97138,96638,84053,38691,23801,1588,10573,122098,77039,240,186135,146101,11996,18143,112963,46171,155836,348769,47795,121213,116266,132515,3344,144804,31286,99187,255838,129694,35894,48779,55235,148582,71967,65282,15174,13920,47080,6147,108242,157593,125025,7136,1286,28957,127956,28402,98813,20805,7532,109417,40610,5041,32958,15142,18408,108596,33543,50517,27748,80114,233434,91447,487,37094,100048,30541,43477,10639,89862,155868,37667,8726,60684,237903,73408,99589,12190,38739,97348,3914,13594,2680,149016,13907,30171,28343,23530,115225,61104,35821,147679,14337,4297,244282,24085,326976,56428,7851,21303,131620,71446,83253,68692,111870,5224,15813,38197,49026,45057,13660,3306,76345,40671,27905,91072,996,68527,62085,91351,122634,55109,168209,2024,27560,112707,17352,8306,167115,169921,166958,5031,46020,11844,67284,19130,76185,6920,32849,5450,14610,22451,21002,17392,31872,66682,84796,13709,40210,59898,12029,8719,53564,21462,91884,21647,88379,194428,12754,37797,132826,160016,22567,54383,53186,77611,31107,8339,4694,19185,90355,23597,17222,140675,28442,23668,55977,9128,61555,28774,155229,17658,9390,24379,69357,15752,127381,239631,62460,93181,55913,45133,140155,18676,25249,33164,29581,82837,67223,22362,29975,7317,52813,1943,29613,20012,207130,49617,49651,5636,15334,36313,29226,28084,95247,72072,19e3,224932,15811,114,32127,38097,37508,88507,37225,27359,91626,12193,69279,20608,11055,88156,92808,2152,57259,55275,72789,24475,104414,1708,9882,3818,48661,66897,1631,34806,227930,85815,87753,18321,250664,72733,25107,206797,50891,8082,196411,92596,96764,152823,65514,22819,387277,62176,51225,40329,15563,189,3659,73670,64357,51793,275136,33482,86653,74615,67058,11318,125720,15388,22388,8267,1730,102663,170910,40784,7144,85373,13040,7088,94309,583,44224,140424,77439,18496,164026,36578,4722,9151,5824,63365,26510,35199,40500,79277,32495,44614,35233,9566,203293,152144,7097,2330,183480,98629,13423,330887,44130,68600,30939,97829,31012,345465,56747,94879,4939,160027,149761,99423,46099,32251,15332,8761,96094,128555,5763,235318,222223,55729,30241,55420,201746,3987,81382,8259,49325,23287,7719,24633,251100,92311,18591,110533,64759,170260,393860,7175,21144,132887,3593,75346,101277,91109,16387,259187,11627,57459,173829,44694,55780,49797,89192,120443,62622,3904,14814,23887,1027,112258,64955,99800,11132,66353,36202,48624,18158,88481,96882,43059,11040,2455,7077,21651,181159,99126,100434,61388,68186,19161,110468,120052,8819,55324,41494,7014,37689,3618,87729,92615,207943,9823,128657,12587,15857,6379,67628,51216,71775,157617,63244,1503,3864,218754,110864,5769,21492,7243,1192,87921,85529,31512,18537,42698,35350,73510,84474,34301,8991,21013,35034,566,38832,19838,35586,37216,39413,55006,12178,59742,856,84563,6900,25632,17437,49786,30723,13847,70845,4044,7843,23944,235976,55530,48942,6518,20939,73769,192653,52936,95207,23895,132542,142982,22632,87452,48042,54018,178468,10728,26230,23559,363,81269,142012,5718,346258,31456,84333,246476,51018,66692,101804,120570,39962,30373,70593,2864,60541,19425,54209,104092,7201,31545,48018,25865,15442,46257,40443,8328,6451,111782,47527,97754,33046,470,245116,31095,39,91934,87208,73470,36708,36521,12801,70624,36272,8892,79768,12427,55454,103756,5908,52390,62962,22720,141138,94634,41689,128402,126390,6628,106394,35527,134394,82727,254651,194502,148064,89549,3202,28359,957,21954,27906,49840,142747,8307,24206,48978,1186,71728,133038,71474,91306,6333,110959,74600,70387,18983,62609,56057,22970,1147,135850,1321,28834,3578,59715,102227,32827,81415,99952,55636,257598,390,22702,35701,85872,402916,39216,189795,14929,19467,10112,144422,61514,5279,63421,134686,41436,8424,51925,10598,132295,124416,4604,194739,210929,57866,31829,51626,50007,9976,91878,61906,56168,81906,60918,61859,40017,23059,16887,40927,62064,12785,32893,32913,21782,93965,20169,44387,79084,38463,11457,93950,27127,157050,2697,337088,5116,54128,48255,33279,8821,27352,25515,124022,65710,28906,38557,33390,1722,104435,72215,38551,12094,30978,25113,6671,37355,175109,42862,98024,65406,221276,59624,118012,64637,78760,86697,21426,1639,40350,12584,67193,84144,31396,7863,143011,69629,63112,9454,28666,65798,46372,134721,6314,51402,30837,151922,2847,38676,38008,92823,136245,17540,5504,109295,205242,37606,5211,214892,1586,20670,208711,137743,19328,40652,16995,20023,14657,154919,34422,12996,13918,38221,47690,16398,2959,37680,89122,6721,198469,91876,172043,83898,101992,26084,94570,3635,76958,22853,76497,38266,176590,168403,44464,142840,79180,184594,1984,41806,83147,11985,6546,366068,59732,24533,271505,8736,39084,222992,93429,28962,58985,86665,8432,30028,14548,32439,54424,165029,55175,27458,69046,121277,46168,33732,20661,24581,135574,123110,37556,79260,72611,16957,12939,46162,58238,44907,72936,253758,41324,32518,96480,11949,124438,65280,43256,34107,53533,43531,37037,28366,45970,32741,173438,6121,194202,62969,26355,30314,58370,28455,1848,50519,82830,90393,21761,295490,10936,256940,133568,44050,20269,4089,27457,21610,219460,36743,14821,101388,52005,13124,30979,140816,167362,26054,18458,60789,34917,40447,26606,33422,9066,3452,83614,5761,20263,137238,25038,91310,101,52322,74548,42572,38084,214054,186568,31802,17665,30620,141936,37730,14420,4265,187218,49640,188208,51441,55388,96452,66659,40869,42039,60967,221027,19234,178581,29105,96050,9165,196118,157335,3738,40354,117436,2965,34136,59659,15570,50843,230035,31444,71260,43886,18316,5387,38500,168508,17406,32174,8828,103373,143806,90367,3560,18719,122310,16508,26719,2541,105429,6645,37998,73190,10591,235916,49737,87112,233941,53188,32193,79154,4544,52905,126477,7580,63501,57314,3216,31337,6541,103083,60846,49,9756,15481,1355,43840,14319,13743,27486,10222,73114,230718,418644,16706,6674,279748,23058,45273,295831,86306,2743,5535,88773,21829,35253,120938,31153,3169,16839,42847,8751,80974,33942,36867,35514,16485,26474,77775,56877,5391,48346,3882,108713,31403,27804,55248,26235,43821,136104,40118,175507,28034,203908,18732,1788,34030,106427,36958,54359,7251,44936,15356,69139,455,157915,22173,140291,50348,43275,82066,49621,54952,15216,36226,96695,66855,6936,1987,8227,196087,4631,68827,99004,47541,110265,17953,147605,110242,58520,31312,38724,329975,642,3155,34497,75937,6207,73843,6120,17249,51429,117746,3218,910,68961,319671,14938,29555,34700,1649,66673,72268,9655,76800,153087,6941,210168,27130,35398,1780,73242,3135,56689,19556,165307,8765,35967,121458,13333,70453,17350,117253,22265,13340,44265,39869,441,3742,135025,23581,33309,16543,17731,13291,157637,283005,21408,101360,63887,52312,83873,5338,233779,23759,186949,34531,177320,38069,156465,91004,19353,59852,68160,14891,1338,1072,29823,1950,28901,81407,313445,73038,84807,162348,240257,37162,138934,16111,58013,41253,102951,16457,96056,19541,56402,67217,41638,94381,89674,29481,37456,80815,151579,13937,13683,132537,19699,134545,67020,29816,222341,141235,427578,48868,129557,233342,23077,87871,16213,18728,16184,9469,37913,19680,2798,171356,178328,13216,50049,72690,71904,124644,55455,7504,29052,41036,266546,19899,30391,188755,8659,59469,16,104298,112943,53865,76203,138226,68857,139953,14125,107625,119795,173133,4398,50273,48808,54390,16466,122086,31835,67035,50971,48859,7508,46427,66477,73021,84615,39985,83076,46779,201569,53336,36443,60865,168164,143810,51393,25548,169307,32896,24485,38424,21837,29087,275813,51674,6714,64883,46169,187369,55186,76192,12852,12018,62134,31067,118303,16542,12125,10579,4928,26291,43854,7091,10946,253716,109062,39283,17261,113012,258512,47764,125126,32646,55892,80279,201623,149872,3192,385,1208,48750,5376,58738,22335,5427,82416,47811,32435,143086,38930,94128,59975,156037,37977,38224,62485,7698,50405,71027,16462,21559,136153,34131,107506,162069,63703,3101,215029,40407,4178,3774,9187,80019,17880,97926,67579,2600,18405,8351,47924,86638,70820,92206,86453,29610,42241,119200,3198,15466,67813,57863,35454,4779,99518,4649,104641,144269,33730,38073,65864,6838,109456,193298,154007,5623,45741,30846,182578,25573,157224,1543,58575,138703,146140,44971,49356,18275,59064,20300,13122,11848,24453,11973,9797,86843,2919,25530,49210,1130,161220,76788,75373,85604,34926,36014,17777,17255,51533,11676,92226,51845,119859,21525,5936,18507,28050,1140,31418,14857,34207,47859,10750,36382,32079,106909,59426,87757,38393,110042,15965,97104,33757,35344,97993,53979,33651,45407,41884,82515,173089,7177,58371,35365,47543,51927,35587,10670,23544,29306,84233,39976,76076,62097,9007,8668,28119,78281,120790,19835,143020,54968,18670,64959,20649,34469,42570,33001,136570,87796,120044,1106,58700,63951,127623,12805,83057,40212,31773,49850,7361,54336,347524,101314,23751,19569,48791,29174,49369,20467,7465,75842,38281,623,112457,60210,28849,51003,94720,6426,90047,85560,43761,3579,85105,34607,90410,118528,7224,42907,111163,18168,6960,161135,191298,5247,100584,127552,171568,20121,91173,12636,54615,20199,63730,98105,2396,40387,14438,125012,4765,33235,12865,45299,37728,82098,77872,114037,59253,19675,24838,398016,102561,11446,17069,57508,178277,65836,99941,26114,2585,271882,136866,50126,11027,155648,118367,14585,8910,123015,335383,40434,41016,53021,14439,87098,176860,201543,121888,2358,9286,5739,22666,54270,37884,169381,33984,93859,16124,89364,72207,51639,76366,99029,65812,2198,12147,174891,194289,6986,30252,88822,21284,11445,288337,160821,33034,100869,43852,25761,52882,1144,103809,1924,84458,86079,43411,13542,139276,18141,34978,41298,7276,26481,173800,33210,17951,142652,33616,33677,2210,19941,98568,2486,192414,80136,12058,235883,50963,249638,29572,27221,47034,6124,72107,63346,97620,158513,299699,40388,23235,37176,224244,198386,121323,67992,23827,63170,17838,106622,158590,26807,5345,23489,91891,55474,74834,37981,13058,5977,72552,34706,26828,145172,19904,21367,34043,960,77092,91381,4733,47446,7680,41697,5170,16960,14741,46101,13656,473,51842,37433,11103,11551,121951,13191,97536,165932,50397,51628,129028,9069,44885,6590,59195,47045,32940,225472,90345,21833,13303,29407,96615,141951,5198,6028,18395,7181,3861,14966,156358,167182,36529,55253,25942,173153,30959,27261,50691,150176,162201,38467,48462,80602,42163,118482,168,108756,26011,17166,54149,456538,22512,91374,13816,90358,131615,18132,226707,1824,28139,26860,42253,93877,77351,65575,8980,80574,22020,27948,40422,91324,76376,13528,39281,91685,82215,122541,144066,1983,193851,17283,26320,2739,194978,4790,26845,42627,61300,65815,174612,55133,4200,191130,79771,158321,52280,166796,221620,62461,11278,4067,88152,83409,31717,121367,13522,47325,37945,10406,174348,249321,154101,64912,29938,51775,17220,15776,166138,78890,84425,54121,42861,16368,24572,291647,10197,32073,22651,11677,97509,26952,35787,18424,41910,71614,94977,72318,41594,70024,275419,37702,60199,7335,39107,61315,18271,18394,33768,87884,104277,123724,7277,56288,71981,189803,49320,3352,6798,14240,8954,69220,94433,57372,28620,68863,193727,85575,42309,41667,67689,42081,22543,44824,12719,28540,114236,101553,27638,27296,4300,5353,4663,19379,94098,3758,95888,95144,80344,87320,28447,259518,12718,71391,152731,37063,24132,31911,104896,15672,103782,1521,4945,72541,23717,122632,15619,87175,206120,29428,189780,61416,28350,44457,972,1175,47233,198738,95789,41907,21953,97034,59341,22864,53713,16873,32971,20693,20954,31336,21477,16169,38370,16412,9019,3841,24599,21938,17085,6484,81198,76413,5849,72514,12320,65247,276175,37234,59796,52642,16312,57349,198507,94148,46134,18958,125552,1747,18725,151873,14901,5490,68287,29470,3689,64794,40814,26018,25692,54450,2703,88278,124886,173087,174e3,24159,179477,24276,46004,201876,209202,445,52876,31948,30206,157610,39180,18439,44124,50469,5774,96278,222758,200216,50290,45486,20435,46986,46276,140133,142326,15569,13363,47522,92583,2182,7135,16853,22998,30272,4952,63263,35623,39096,53789,44864,20053,110392,124213,4630,16087,28221,127787,25839,77481,44693,13464,113146,6983,27069,55717,50102,4760,7107,26186,66507,59145,36032,104182,71328,29425,64317,50781,47465,94298,69706,74899,22754,120756,25108,93077,56834,73286,39928,16218,41699,176763,7555,70819,50083,26895,23315,26014,16773,123079,41712,5719,31516,90427,158540,85051,183128,40864,27505,55392,9058,45224,96857,30901,136622,96557,56304,120061,11501,151448,5773,89743,7769,86069,2935,18471,41628,10114,33660,110170,49479,26745,92846,33221,26731,18795,87076,8550,2100,29972,120289,3077,72490,33784,2630,208722,50861,63483,79029,6419,39467,14302,45286,64207,9686,67513,44170,1050,77246,59266,17055,53801,7150,11111,42432,4278,94579,362117,36175,42902,41933,39002,98489,22913,74161,84773,57036,17556,162288,74485,178760,93867,73635,128860,50362,261,67455,80001,46080,35662,4368,25247,19230,74393,22588,1822,27682,235324,13798,85998,13194,235067,23514,71669,147632,23191,134748,214683,105101,1518,25489,247114,7380,54842,26922,3971,26361,20844,68642,170517,77339,123255,8963,77818,150998,48466,36806,2732,23261,11741,236162,18243,126216,28690,50546,16385,92760,197383,246558,201295,88255,67588,71687,176076,172653,169058,33906,63747,24835,157621,43338,30050,46152,132741,2770,51371,94835,6614,15112,11749,56936,1250,19027,399017,58036,100215,23388,55815,308768,124152,94803,9521,64186,8971,28,30427,62163,7616,103838,35079,29203,131235,7743,17389,10882,37420,61460,228512,85363,41581,131077,62822,119647,10130,54445,26925,19968,29016,24446,74028,24176,61448,67185,9254,8563,119129,9771,99184,37716,39514,10532,221512,258753,218630,55980,23394,32141,61924,66749,32411,3741,36475,26678,77010,44946,91203,128749,116953,20476,49625,53116,13735,102335,29376,51946,83407,67892,59212,34685,21083,1546,112982,32972,74397,1078,190545,16082,86140,58591,89611,101531,10061,105104,76319,20035,17551,52611,169061,190842,100780,23907,90413,115619,9675,34710,193435,49443,129734,11183,258877,16318,136182,126808,44635,27304,192375,2599,125648,47051,12091,23814,721,58800,40137,66726,97930,60877,74487,7942,54326,9841,41428,13762,8211,85383,6950,99177,79806,201786,296464,124087,13144,29741,41721,47634,55088,254286,106408,17041,99064,12942,64086,45233,14005,2612,55827,255,7984,13980,38574,12776,46654,73499,249951,2101,26676,25996,132326,116415,119062,50449,31033,23038,11589,179252,20007,14860,129270,21143,17796,144715,60106,70758,69842,34674,282133,44014,16774,57268,38528,24053,46373,201667,28327,471023,51889,102667,21193,114909,84132,69317,96723,67969,16134,68145,15058,28765,32035,2524,101089,98664,25045,76571,14957,86040,118506,262428,154764,81573,39681,283900,73287,127825,544,80448,52347,38512,175971,15180,45467,33086,46552,48894,81107,43213,36672,54025,76703,8053,7608,13299,56619,20752,238099,54164,105133,1444,32942,953,37564,8e3,66316,119463,106817,404,13667,149108,128597,31267,10269,49836,106150,1484,52330,76965,160486,171648,38456,31263,22424,37738,66245,67467,143369,60471,75610,20895,115528,86070,60854,40796,49347,18989,15030,11371,37578,15779,79867,10187,86462,46402,155626,93200,40229,7090,57547,108053,99598,11088,47505,41218,206017,2173,20988,30219,22919,80563,57566,42369,93141,41675,2407,182519,120495,27154,16702,29456,14349,7958,16688,117177,140375,42467,261919,74916,153569,10836,34742,49526,7621,105997,12212,2270,392377,7755,17959,25086,232152,138791,33847,13860,35316,5811,1344,71259,50452,207539,92635,50359,5821,33674,30255,2086,2587,96264,17543,42,6029,9580,43007,139248,82831,12917,29607,25786,51467,42137,85161,100698,31561,88989,121990,278500,3602,109344,37982,15279,116442,28936,30880,87894,58079,128661,126731,67392,28051,146885,4861,16216,97344,42827,147561,153948,22684,21335,47685,1853,43349,15185,59642,10229,25520,187921,108972,5579,98037,24945,6697,19193,63734,137934,75056,89740,19767,224268,56138,63643,151661,39313,70618,84031,89723,84074,13703,85626,35460,8867,64845,3439,57906,99776,63968,49270,81130,34356,16210,23547,36446,34090,140028,72439,2221,22163,57058,363492,113754,18913,95451,48663,54464,54037,176097,68425,3023,34906,29482,117389,341780,80431,58330,16753,92616,60907,94846,147486,4498,48646,7773,46801,7778,18946,464978,47558,33223,177444,7328,15626,63337,94700,11743,9351,255024,39098,16447,42647,96230,39769,58840,10068,63439,35800,65843,58823,413844,9156,51258,7434,61791,85018,6872,3692,28096,7121,33024,6009,75532,31997,192535,9661,3304,9547,14753,31987,25314,55689,15896,20430,39472,31340,99744,25398,115569,54883,28719,205423,23071,57855,64638,149867,25671,82403,37616,20668,39989,77996,74948,140555,175248,64810,36515,46595,4958,248773,24045,28728,136673,168704,20804,114833,100325,27135,21205,96151,153134,45992,7093,13992,76047,1980,19432,145001,75159,87462,17710,1013,45556,34297,144882,20648,26061,11319,129567,108555,18872,464580,33386,22717,65948,167189,5603,135042,79542,8801,202632,18114,91882,5973,5239,67315,4431,60916,47819,71693,32597,32606,18183,45072,80329,76385,24749,51305,40314,156514,14693,130345,13168,66214,18029,12858,34801,27628,14544,10823,40522,40185,33739,148694,23548,9923,61012,28859,17933,19442,34364,99849,164107,141167,30629,21054,6744,36491,8096,42474,41706,155060,30650,10600,163442,1143,96655,61390,52359,7559,51568,64256,203854,4467,22453,14504,436398,7878,6980,8293,63610,293747,16167,35763,19627,147603,15419,18032,110744,51346,33681,54571,40472,48615,39073,21604,13754,173027,92560,11083,47299,63062,11813,52007,29883,9734,139722,15953,1550,20651,13616,49306,16113,90089,92326,7584,30712,72424,164858,6831,152871,55746,197721,34167,196442,6022,112107,55215,7538,123381,4920,43539,77165,8939,50392,34192,20225,79762,22505,58667,40770,29788,97180,82835,4568,8579,13273,363569,35898,49983,436,36598,3237,131691,62418,35591,8101,4073,379438,65218,76072,33887,2968,27573,212619,288680,68278,72851,150504,217896,6913,121339,22017,35340,51072,43616,75043,31437,10833,81487,4364,22968,41454,106687,85446,19863,109625,149241,524,141850,214404,54376,657,237023,9401,108137,53800,32474,49712,53334,126876,27337,45552,177696,8269,15036,12097,42240,2328,125374,119295,99715,2500,19624,39441,27220,102691,60957,94543,39101,18566,67362,13975,78230,25017,34017,239007,90027,39351,41681,35354,43822,1043,916,58587,141983,94818,38799,75459,41114,67432,16195,36606,59568,22272,126769,31424,68659,12287,134302,257977,5756,207285,95637,47248,117689,19583,77451,22373,12200,54993,117118,34244,29386,34562,53819,71267,64172,77665,49368,7716,59301,25749,45426,194789,17297,2650,1766,32501,45198,20403,20984,6600,14171,94604,19037,5402,29896,9938,59935,109708,88081,145182,44844,39167,352626,164173,35374,45982,6122,154,73419,220487,53834,53601,17992,8609,229321,5610,68098,66815,71012,95069,140968,27396,8957,134489,24656,86659,56598,134852,17316,123838,255436,6613,41610,138033,81452,32023,32396,123687,63398,8693,29712,30407,19296,121188,3551,36099,20032,111948,56624,16547,27453,35916,15378,52039,56849,13489,22214,73177,53097,277349,2157,14029,187886,10260,141743,246460,91880,50869,3788,49486,133566,54950,33120,129337,53768,18333,9525,26902,312251,10297,9020,70759,16647,112432,59260,84609,9818,82766,73569,468,46001,75780,55028,52106,11498,43645,108069,17150,17753,29417,16705,31799,9606,289,122254,115975,8620,6133,255357,56908,14456,133464,43554,79224,11247,29630,160,12756,25464,65960,350428,62521,321796,100359,67358,35169,46172,113128,48988,88868,31094,33266,6847,60887,98188,49659,69117,92977,220228,13947,80181,35103,62170,97351,13475,2440,199768,19498,36597,46971,25234,67806,62881,84717,73648,181966,10488,94149,21550,26655,63436,48375,14405,165650,9621,24439,28043,42735,4490,29963,56674,45373,1934,262446,50855,67098,26898,5261,52696,40644,33900,9440,180286,87162,22940,19704,26936,69769,10254,101759,27406,12243,48e3,73926,113215,54935,5726,192787,4312,106216,9366,11550,52949,23457,212271,277152,133895,108374,6191,96477,29980,218916,58024,54696,40853,91124,65894,91170,65908,252552,6793,29212,15389,44516,122515,52617,35058,9017,103536,39510,49136,19242,130652,662077,74699,47024,31422,8517,73351,24399,13867,128360,4810,4434,61779,111983,61036,17798,110240,59722,102960,39688,10001,23803,23039,176498,56659,44814,134295,17188,77577,74466,226175,102472,154333,63900,111747,18062,41171,79669,32773,408933,42562,28931,30907,107388,43487,2946,240310,23938,24354,319,184983,7927,6488,1422,10790,68809,68209,64775,4361,202,17123,59634,51200,44391,18188,17843,2619,74278,3230,9540,47187,21702,36274,56894,43907,16310,34790,16866,6150,5561,13587,107545,108873,126867,86986,28640,33427,19017,5762,80637,17430,46903,2047,131055,25958,13558,5444,47152,13900,44563,122857,45348,70863,39593,54332,38068,33637,318,40310,143467,18502,24520,11377,62013,28942,27246,28269,83545,17999,59015,90707,30065,15161,34720,1263,37008,2012,6060,98575,92933,5721,299,199555,24578,29223,2985,743,115825,109523,136657,47454,26378,53586,3733,174945,93340,244456,5693,37386,28782,89767,27545,23573,18798,136425,34320,84778,20041,48453,38215,7477,71958,40621,8773,5874,187927,105965,51100,43533,18083,8443,10180,43597,2003,183999,69689,12216,129696,146188,62389,34044,68410,12765,43273,26949,266807,3345,34477,79197,5688,47539,213110,21634,22257,50092,32222,42346,39530,63668,98,134978,74022,5152,59088,174145,37220,9934,9545,118937,5724,87240,19875,15784,40143,23263,87513,181654,285152,37881,263241,4966,43934,10433,186657,6470,74416,225854,25908,142677,246262,32280,6192,75890,45546,143264,135305,29742,47013,77787,11732,126658,8763,37950,21806,57557,113464,89465,108995,164574,23894,22996,23169,15369,23117,17642,130607,40503,36239,280990,44666,9981,40427,147487,26869,168452,32886,32991,46798,240839,15111,70502,65697,88548,44145,28701,48767,31139,206777,35659,181164,166262,14554,171445,31786,66523,76607,17956,6507,31279,90476,116611,167918,6560,1243,115324,80128,41867,55897,187323,37069,32596,189444,145931,13390,105530,65709,26805,6999,55714,41300,22915,68951,22138,21120,22264,10058,19945,33635,56123,99085,10032,5818,6016,46649,57476,35264,94413,112522,262288,93686,83038,14341,23204,28807,66084,77987,6101,126673,7133,38126,5923,122091,170240,97772,46874,215746,43948,41622,3272,55596,8332,146411,251315,13533,8561,81521,115449,48616,175175,2063,186556,3036,134537,75772,29728,82360,22973,186559,86348,89100,38388,82297,45610,2613,87082,9986,177812,57884,23591,47485,42543,33582,44713,74439,257444,252451,31825,35631,38540,33066,5147,13973,4343,51830,70378,22827,26448,95560,36896,241741,48067,203953,298860,61620,20450,3220,67272,6586,107662,100160,108684,6929,57226,4762,7457,1320,40404,77204,99309,62750,208653,59977,44e3,74315,34332,5819,172217,64904,114077,18147,84012,1791,98456,90930,21446,116669,103938,7422,85140,59713,5768,326211,16239,75411,13229,29398,10758,236107,1539,112472,95979,152154,151294,306,21196,38146,10700,6891,84282,109646,56492,40539,6589,119491,51354,30685,140209,136906,29622,73617,49553,70525,51671,166869,139616,74395,37439,49595,45678,11959,33211,86560,52434,9282,62690,112155,130810,5243,108261,99970,265613,72551,80049,6391,33365,90721,66737,69872,87011,1860,9032,112544,60905,37371,89015,140351,19076,850,373531,2802,36725,218795,72062,28990,16550,24614,7815,6187,26336,33373,32162,42791,73555,32062,23386,10244,56392,49442,27076,136262,12412,14883,1134,33675,97153,199281,15608,100152,74072,47942,254301,36451,16026,10687,65067,56708,254030,30290,50490,13864,57941,259331,35588,23485,43486,24869,21620,92971,22072,88645,1048,182050,13343,32452,14825,19509,3325,216938,45740,99716,189082,53740,78245,25609,24311,176777,47340,308354,40669,66085,14102,125339,9225,128709,97207,1271,200933,78439,113451,88975,18324,46521,11819,18570,141756,72512,170020,52754,63550,118515,103073,93330,32736,50499,14722,31600,68452,398867,29316,172786,18417,104924,2606,5670,84818,16288,67106,59580,82929,607401,291,85829,359,15897,35830,50696,65630,52672,22115,356968,29895,40837,231192,34024,38957,26722,406,23335,124952,72068,68804,13268,147101,164740,276569,162596,66943,11569,26654,66358,4777,23229,102127,5848,978,2921,59666,5371,28212,90108,42938,39320,2499,4271,108792,33510,125072,71653,65239,38250,66357,38577,13964,86251,35708,50755,36010,29448,12209,3844,38222,206337,100876,67827,137088,14167,252225,84163,195270,1306,5703,54198,779,46802,22028,51124,86759,70560,113164,35685,162145,45471,34561,422,2611,6464,47486,19223,38246,9191,18331,89942,243642,212364,15893,17518,22617,6409,30046,126182,59716,36560,104428,18846,26592,19458,50793,147333,30826,1388,27647,10922,14495,33545,19269,135828,39727,41601,46931,233379,49169,131130,182112,16276,82381,118209,142445,128310,19672,28740,82907,33436,3118,102206,28723,24819,41937,38854,5157,3881,111491,1142,9776,421673,152241,29309,14961,87854,6054,15424,3796,82656,54996,2108,55367,239450,154525,9643,118103,106041,64601,68549,48707,30266,25772,18740,9462,229669,91798,112152,191327,14493,72828,8175,66636,236474,25817,87351,129027,76653,20422,22983,71240,27846,44661,12399,46158,77704,53101,35032,11072,17300,109294,33638,24408,1895,11241,760,17584,82479,125877,63150,141075,34259,23274,81698,15732,43577,48340,91584,14688,16379,24481,150280,96420,262050,48635,43727,61819,56268,72003,88178,17281,79912,13218,122519,125295,166396,11811,2171,118930,67746,17636,178278,174656,95661,173039,83845,79689,17473,98555,127696,203415,54730,22925,232239,9309,12136,175026,20740,180188,10747,39816,314017,266131,10040,175732,112550,220651,31974,37393,888,23008,86799,4303,64905,148467,75337,251,3284,370102,50264,9835,5438,23655,4481,29851,329,12855,7162,64931,78141,12804,42372,296771,83547,18624,34874,86271,3360,48665,77735,88767,11463,63527,28889,22258,29140,194315,113924,25499,6406,31334,1845,4802,49184,43455,35469,127594,92970,61038,115005,38840,87761,106838,8811,20572,55637,11162,96721,132425,108925,2948,125457,36356,3502,75270,27622,127192,2561,123095,49394,61155,16897,110064,9699,89448,53356,19628,220310,21622,83036,9885,112214,6087,26713,17901,161912,91492,3440,68594,9266,92238,8087,6866,150194,72175,80701,13459,31836,43243,239700,95846,44749,50647,21945,230538,120612,132371,244604,5193,105637,34661,41341,68775,85393,1874,8771,33718,49672,77403,595452,99507,6490,58895,128742,7704,39239,73217,43816,62824,37804,199976,22361,80005,87514,94832,14089,4574,139975,59142,75523,100268,43906,53442,15152,2547,186002,17011,19513,204282,3343,60568,128318,119250,4298,51871,41336,71759,21921,45074,98169,145889,99427,11350,1237,5520,28799,7803,53702,21026,136352,38293,128690,12158,90132,44600,10184,26957,39459,126025,78904,82999,59373,39301,150198,120529,153042,20177,50089,14764,271571,30530,123161,38975,101562,22941,5648,124654,109243,69817,71675,49162,106884,21241,107795,30258,16572,188262,141456,7688,60718,8271,11044,32440,104608,103419,236109,93156,43293,128929,42107,67180,25201,115254,185488,130954,72813,167547,20537,39969,38432,22582,184022,1139,27199,5655,17767,97412,122606,209377,27070,35871,326617,188954,42680,73512,80911,22629,3011,95021,315242,157737,383,41821,41808,19335,27950,15674,25677,110950,35375,76835,59108,57370,35262,16569,160415,37706,78086,32041,49691,137143,9782,172080,50148,77917,6323,10110,69172,17711,21795,59511,76184,135114,31046,132319,59105,157578,20549,80778,57649,158421,65143,4575,72235,21899,10797,92745,34035,106079,80159,4508,78304,25350,75457,46458,32937,25623,47,8531,104751,84953,8138,36508,187199,66310,115274,13253,32461,38536,1916,42007,187160,35055,26325,84394,35963,94216,45590,97782],Qc=15;class nR{constructor(t,e){u(this,"log");u(this,"peerRouting");u(this,"routingTable");u(this,"refreshInterval");u(this,"refreshQueryTimeout");u(this,"commonPrefixLengthRefreshedAt");u(this,"refreshTimeoutId");const{peerRouting:r,routingTable:s,refreshInterval:i,refreshQueryTimeout:o,logPrefix:a}=e;this.log=t.logger.forComponent(`${a}:routing-table:refresh`),this.peerRouting=r,this.routingTable=s,this.refreshInterval=i??YP,this.refreshQueryTimeout=o??XP,this.commonPrefixLengthRefreshedAt=[],this.refreshTable=this.refreshTable.bind(this)}async afterStart(){this.log(`refreshing routing table every ${this.refreshInterval}ms`),this.refreshTable(!0)}async stop(){this.refreshTimeoutId!=null&&clearTimeout(this.refreshTimeoutId)}refreshTable(t=!1){this.log("refreshing routing table");const e=this._maxCommonPrefix(),r=this._getTrackedCommonPrefixLengthsForRefresh(e);this.log(`max common prefix length ${e}`),this.log(`tracked CPLs [ ${r.map(s=>s.toISOString()).join(", ")} ]`),Promise.all(r.map(async(s,i)=>{try{if(await this._refreshCommonPrefixLength(i,s,t),this._numPeersForCpl(e)===0){const o=Math.min(2*(i+1),r.length-1);for(let a=i+1;a<o+1;a++)try{await this._refreshCommonPrefixLength(a,s,t)}catch(c){this.log.error(c)}}}catch(o){this.log.error(o)}})).catch(s=>{this.log.error(s)}).then(()=>{this.refreshTimeoutId=setTimeout(this.refreshTable,this.refreshInterval),this.refreshTimeoutId.unref!=null&&this.refreshTimeoutId.unref()}).catch(s=>{this.log.error(s)})}async _refreshCommonPrefixLength(t,e,r){if(!r&&e.getTime()>Date.now()-this.refreshInterval){this.log("not running refresh for cpl %s as time since last refresh not above interval",t);return}const s=await this._generateRandomPeerId(t);this.log("starting refreshing cpl %s with key %p (routing table size was %s)",t,s,this.routingTable.size);const i=AbortSignal.timeout(this.refreshQueryTimeout),o=await _m(this.peerRouting.getClosestPeers(s.toMultihash().bytes,{signal:i}));this.log(`found ${o} peers that were close to imaginary peer %p`,s),this.log("finished refreshing cpl %s with key %p (routing table size is now %s)",t,s,this.routingTable.size)}_getTrackedCommonPrefixLengthsForRefresh(t){t>Qc&&(t=Qc);const e=[];for(let r=0;r<=t;r++)e[r]=this.commonPrefixLengthRefreshedAt[r]??new Date;return e}async _generateRandomPeerId(t){if(this.routingTable.kb==null)throw new Error("Routing table not started");if(this.routingTable.kb.localPeer==null)throw new Error("Local peer not set");const e=Es(2),r=(e[1]<<8)+e[0],s=await this._makePeerId(this.routingTable.kb.localPeer.kadId,r,t),i=bt(s);return pr(i)}async _makePeerId(t,e,r){if(r>Qc)throw new Error(`Cannot generate peer ID for common prefix length greater than ${Qc}`);const o=new DataView(t.buffer,t.byteOffset,t.byteLength).getUint16(0,!1)^32768>>r,a=65535<<16-(r+1),c=o&a|e&~a,l=rR[c],h=new ArrayBuffer(34),d=new DataView(h,0,h.byteLength);return d.setUint8(0,gt.code),d.setUint8(1,32),d.setUint32(2,l,!1),new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}_maxCommonPrefix(){let t=0;for(const e of this._prefixLengths())e>t&&(t=e);return t}_numPeersForCpl(t){let e=0;for(const r of this._prefixLengths())r===t&&e++;return e}*_prefixLengths(){var t;if(((t=this.routingTable.kb)==null?void 0:t.localPeer)!=null)for(const{kadId:e}of this.routingTable.kb.toIterable()){const r=ks(this.routingTable.kb.localPeer.kadId,e);let s=0;for(const i of r)if(i===0)s++;else break;yield s}}}class sR{constructor(t,e){u(this,"peerId");u(this,"providers");u(this,"peerStore");u(this,"log");this.log=t.logger.forComponent(`${e.logPrefix}:rpc:handlers:add-provider`),this.peerId=t.peerId,this.providers=e.providers,this.peerStore=t.peerStore}async handle(t,e){if(e.key==null||e.key.length===0)throw new We("Missing key");let r;try{r=te.decode(e.key)}catch{throw new We("Invalid CID")}(e.providers==null||e.providers.length===0)&&this.log.error("no providers found in message"),this.log("%p asked us, %p to store provider record for for %c",t,this.peerId,r),await Promise.all(e.providers.map(async s=>{const i=bt(s.id),o=pr(i),a=s.multiaddrs.map(c=>fe(c));if(!t.equals(o)){this.log("invalid provider peer %p from %p",s.id,t);return}if(s.multiaddrs.length<1){this.log("no valid addresses for provider %p. Ignore",t);return}this.log.trace("received provider %p for %s (addrs %s)",t,r,a),await this.providers.addProvider(r,o),await this.peerStore.merge(o,{multiaddrs:a})}))}}class iR{constructor(t,e){u(this,"peerRouting");u(this,"peerInfoMapper");u(this,"peerId");u(this,"addressManager");u(this,"log");const{peerRouting:r,logPrefix:s}=e;this.log=t.logger.forComponent(`${s}:rpc:handlers:find-node`),this.peerId=t.peerId,this.addressManager=t.addressManager,this.peerRouting=r,this.peerInfoMapper=e.peerInfoMapper}async handle(t,e){if(this.log("incoming request from %p for peers closer to %b",t,e.key),e.key==null)throw new We("Invalid FIND_NODE message received - key was missing");const r=await this.peerRouting.getCloserPeersOffline(e.key,t);_e(this.peerId.toMultihash().bytes,e.key)&&r.push({id:this.peerId,multiaddrs:this.addressManager.getAddresses().map(i=>i.decapsulateCode(ge("p2p").code))});const s={type:Ke.FIND_NODE,clusterLevel:e.clusterLevel,closer:r.map(this.peerInfoMapper).filter(({multiaddrs:i})=>i.length).map(i=>({id:i.id.toMultihash().bytes,multiaddrs:i.multiaddrs.map(o=>o.bytes)})),providers:[]};return s.closer.length===0&&this.log("could not find any peers closer to %b than %p",e.key,t),s}}class oR{constructor(t,e){u(this,"peerId");u(this,"peerRouting");u(this,"providers");u(this,"peerStore");u(this,"peerInfoMapper");u(this,"log");const{peerRouting:r,providers:s,logPrefix:i}=e;this.log=t.logger.forComponent(`${i}:rpc:handlers:get-providers`),this.peerId=t.peerId,this.peerStore=t.peerStore,this.peerRouting=r,this.providers=s,this.peerInfoMapper=e.peerInfoMapper}async handle(t,e){if(e.key==null)throw new We("Invalid GET_PROVIDERS message received - key was missing");let r;try{r=te.decode(e.key)}catch{throw new We("Invalid CID")}this.log("%p asking for providers for %s",t,r);const[s,i]=await Promise.all([Wa(Un(await this.providers.getProviders(r),async a=>{const c=await this.peerStore.get(a);return{id:c.id,multiaddrs:c.addresses.map(({multiaddr:h})=>h)}})),this.peerRouting.getCloserPeersOffline(e.key,this.peerId)]),o={type:Ke.GET_PROVIDERS,key:e.key,clusterLevel:e.clusterLevel,closer:i.map(this.peerInfoMapper).filter(({id:a,multiaddrs:c})=>c.length>0).map(a=>({id:a.id.toMultihash().bytes,multiaddrs:a.multiaddrs.map(c=>c.bytes)})),providers:s.map(this.peerInfoMapper).filter(({id:a,multiaddrs:c})=>c.length>0).map(a=>({id:a.id.toMultihash().bytes,multiaddrs:a.multiaddrs.map(c=>c.bytes)}))};return this.log("got %s providers %s closerPeers",o.providers.length,o.closer.length),o}async _getAddresses(t){return[]}}class aR{constructor(t,e){u(this,"peerStore");u(this,"datastore");u(this,"peerRouting");u(this,"log");u(this,"datastorePrefix");this.log=t.logger.forComponent(`${e.logPrefix}:rpc:handlers:get-value`),this.datastorePrefix=`${e.datastorePrefix}/record`,this.peerStore=t.peerStore,this.datastore=t.datastore,this.peerRouting=e.peerRouting}async handle(t,e){const r=e.key;if(this.log("%p asked for key %b",t,r),r==null||r.length===0)throw new We("Invalid key");const s={type:Ke.GET_VALUE,key:r,clusterLevel:e.clusterLevel,closer:[],providers:[]};if(hD(r)){this.log("is public key");const a=dD(r);let c;try{const l=await this.peerStore.get(a);if(l.id.publicKey==null)throw new Nt("No public key found in key book");c=Ur(l.id.publicKey)}catch(l){if(l.name!=="NotFoundError")throw l}if(c!=null)return this.log("returning found public key"),s.record=new Ir(r,c,new Date).serialize(),s}const[i,o]=await Promise.all([this._checkLocalDatastore(r),this.peerRouting.getCloserPeersOffline(r,t)]);return i!=null&&(this.log("had record for %b in local datastore",r),s.record=i.serialize()),o.length>0&&(this.log("had %s closer peers in routing table",o.length),s.closer=o.map(a=>({id:a.id.toMultihash().bytes,multiaddrs:a.multiaddrs.map(c=>c.bytes)}))),s}async _checkLocalDatastore(t){this.log("checkLocalDatastore looking for %b",t);const e=_a(this.datastorePrefix,t);let r;try{r=await this.datastore.get(e)}catch(i){if(i.name==="NotFoundError")return;throw i}const s=Ir.deserialize(r);if(s.timeReceived==null||Date.now()-s.timeReceived.getTime()>UP){await this.datastore.delete(e);return}return s}}class cR{constructor(t,e){u(this,"log");this.log=t.logger.forComponent(`${e.logPrefix}:rpc:handlers:ping`)}async handle(t,e){return this.log("ping from %p",t),e}}class lR{constructor(t,e){u(this,"components");u(this,"validators");u(this,"log");u(this,"datastorePrefix");const{validators:r}=e;this.components=t,this.log=t.logger.forComponent(`${e.logPrefix}:rpc:handlers:put-value`),this.datastorePrefix=`${e.datastorePrefix}/record`,this.validators=r}async handle(t,e){const r=e.key;if(this.log("%p asked us to store value for key %b",t,r),e.record==null){const s=`Empty record from: ${t.toString()}`;throw this.log.error(s),new We(s)}try{const s=Ir.deserialize(e.record);await x0(this.validators,s),s.timeReceived=new Date;const i=_a(this.datastorePrefix,s.key);await this.components.datastore.put(i,s.serialize().subarray()),this.log("put record for %b into datastore under key %k",r,i)}catch(s){this.log("did not put record for key %b into datastore %o",r,s)}return e}}let uR=class{constructor(t,e){u(this,"handlers");u(this,"routingTable");u(this,"log");u(this,"metrics");var r,s;this.metrics={operations:(r=t.metrics)==null?void 0:r.registerCounterGroup(`${e.metricsPrefix}_inbound_rpc_requests_total`),errors:(s=t.metrics)==null?void 0:s.registerCounterGroup(`${e.metricsPrefix}_inbound_rpc_errors_total`)},this.log=t.logger.forComponent(`${e.logPrefix}:rpc`),this.routingTable=e.routingTable,this.handlers={[Ke.GET_VALUE.toString()]:new aR(t,e),[Ke.PUT_VALUE.toString()]:new lR(t,e),[Ke.FIND_NODE.toString()]:new iR(t,e),[Ke.ADD_PROVIDER.toString()]:new sR(t,e),[Ke.GET_PROVIDERS.toString()]:new oR(t,e),[Ke.PING.toString()]:new cR(t,e)}}async handleMessage(t,e){var s,i;const r=this.handlers[e.type];if(r==null){this.log.error(`no handler found for message type: ${e.type}`);return}try{return(s=this.metrics.operations)==null||s.increment({[e.type]:!0}),await r.handle(t,e)}catch{(i=this.metrics.errors)==null||i.increment({[e.type]:!0})}}onIncomingStream(t){let e="unknown";Promise.resolve().then(async()=>{const{stream:r,connection:s}=t,i=s.remotePeer,o=this;await It(r,a=>Eo(a),async function*(a){for await(const c of a){const l=ni.decode(c);e=l.type,o.log("incoming %s from %p",l.type,i);const h=await o.handleMessage(i,l);h!=null&&(yield ni.encode(h))}},a=>vo(a),r)}).catch(r=>{this.log.error("error handling %s RPC message from %p - %e",e,t.connection.remotePeer,r)})}};class hR extends Et{constructor(e,r){super();u(this,"log");u(this,"components");u(this,"protocol");u(this,"running");u(this,"registrarId");const{protocol:s,logPrefix:i}=r;this.components=e,this.log=e.logger.forComponent(`${i}:topology-listener`),this.running=!1,this.protocol=s}isStarted(){return this.running}async start(){this.running||(this.running=!0,this.registrarId=await this.components.registrar.register(this.protocol,{onConnect:e=>{this.log("observed peer %p with protocol %s",e,this.protocol),this.dispatchEvent(new CustomEvent("peer",{detail:e}))}}))}async stop(){this.running=!1,this.registrarId!=null&&(this.components.registrar.unregister(this.registrarId),this.registrarId=void 0)}}class dR{constructor(t){u(this,"dht");this.dht=t}async provide(t,e={}){await ws(this.dht.provide(t,e))}async cancelReprovide(t){await this.dht.cancelReprovide(t)}async*findProviders(t,e={}){for await(const r of this.dht.findProviders(t,e))r.name==="PROVIDER"&&(yield*r.providers)}async put(t,e,r){await ws(this.dht.put(t,e,r))}async get(t,e){for await(const r of this.dht.get(t,e))if(r.name==="VALUE")return r.value;throw new Nt("Could not find value for key")}}class fR{constructor(t){u(this,"dht");this.dht=t}async findPeer(t,e={}){for await(const r of this.dht.findPeer(t,e))if(r.name==="FINAL_PEER")return r.peer;throw new Nt("Peer not found")}async*getClosestPeers(t,e={}){for await(const r of this.dht.getClosestPeers(t,e))r.name==="FINAL_PEER"&&(yield r.peer)}}const gR=32,pR=64;var n4,s4,i4;class mR extends Et{constructor(e,r={}){var h,d,f,g;super();u(this,"protocol");u(this,"routingTable");u(this,"providers");u(this,"network");u(this,"peerRouting");u(this,"components");u(this,"log");u(this,"running");u(this,"kBucketSize");u(this,"clientMode");u(this,"validators");u(this,"selectors");u(this,"queryManager");u(this,"contentFetching");u(this,"contentRouting");u(this,"routingTableRefresh");u(this,"rpc");u(this,"topologyListener");u(this,"querySelf");u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"dhtContentRouting");u(this,"dhtPeerRouting");u(this,"peerInfoMapper");u(this,"reprovider");u(this,i4,"@libp2p/kad-dht");u(this,s4,["@libp2p/content-routing","@libp2p/peer-routing","@libp2p/peer-discovery"]);u(this,n4,["@libp2p/identify"]);const s=r.logPrefix??"libp2p:kad-dht",i=r.datastorePrefix??"/dht",o=r.metricsPrefix??"libp2p_kad_dht",a={queries:(h=e.metrics)==null?void 0:h.registerMetricGroup(`${o}_operations_total`,{label:"operation"}),errors:(d=e.metrics)==null?void 0:d.registerCounterGroup(`${o}_operation_errors_total`,{label:"operation"}),queryTime:(f=e.metrics)==null?void 0:f.registerMetricGroup(`${o}_operation_time_seconds`,{label:"operation"}),errorTime:(g=e.metrics)==null?void 0:g.registerMetricGroup(`${o}_operation_error_time_seconds`,{label:"operation"})};this.running=!1,this.components=e,this.log=e.logger.forComponent(s),this.protocol=r.protocol??$P,this.kBucketSize=r.kBucketSize??20,this.clientMode=r.clientMode??!0,this.maxInboundStreams=r.maxInboundStreams??gR,this.maxOutboundStreams=r.maxOutboundStreams??pR,this.peerInfoMapper=r.peerInfoMapper??lD;const c=Xf();this.providers=new TD(e,{...r.providers,logPrefix:s,datastorePrefix:i,lock:c}),this.validators={...aD,...r.validators},this.selectors={...iD,...r.selectors},this.network=new ID(e,{protocol:this.protocol,logPrefix:s,metricsPrefix:o}),this.routingTable=new tR(e,{kBucketSize:r.kBucketSize,pingOldContactTimeout:r.pingOldContactTimeout,pingOldContactConcurrency:r.pingOldContactConcurrency,pingOldContactMaxQueueSize:r.pingOldContactMaxQueueSize,pingNewContactTimeout:r.pingNewContactTimeout,pingNewContactConcurrency:r.pingNewContactConcurrency,pingNewContactMaxQueueSize:r.pingNewContactMaxQueueSize,protocol:this.protocol,logPrefix:s,metricsPrefix:o,prefixLength:r.prefixLength,splitThreshold:r.kBucketSplitThreshold,network:this.network});const l=me();r.allowQueryWithZeroPeers===!0&&l.resolve(),this.queryManager=new PD(e,{disjointPaths:Math.ceil(this.kBucketSize/2),logPrefix:s,metricsPrefix:o,initialQuerySelfHasRun:l,routingTable:this.routingTable}),this.peerRouting=new AD(e,{routingTable:this.routingTable,network:this.network,validators:this.validators,queryManager:this.queryManager,logPrefix:s}),this.contentFetching=new vD(e,{validators:this.validators,selectors:this.selectors,peerRouting:this.peerRouting,queryManager:this.queryManager,network:this.network,logPrefix:s,datastorePrefix:i}),this.contentRouting=new SD(e,{network:this.network,peerRouting:this.peerRouting,queryManager:this.queryManager,routingTable:this.routingTable,providers:this.providers,logPrefix:s}),this.routingTableRefresh=new nR(e,{peerRouting:this.peerRouting,routingTable:this.routingTable,logPrefix:s}),this.rpc=new uR(e,{routingTable:this.routingTable,providers:this.providers,peerRouting:this.peerRouting,validators:this.validators,logPrefix:s,metricsPrefix:o,datastorePrefix:i,peerInfoMapper:this.peerInfoMapper}),this.topologyListener=new hR(e,{protocol:this.protocol,logPrefix:s}),this.querySelf=new ND(e,{peerRouting:this.peerRouting,interval:r.querySelfInterval,initialInterval:r.initialQuerySelfInterval,logPrefix:s,initialQuerySelfHasRun:l,routingTable:this.routingTable,operationMetrics:a}),this.reprovider=new LD(e,{...r.reprovide,logPrefix:s,metricsPrefix:o,datastorePrefix:i,contentRouting:this.contentRouting,lock:c,operationMetrics:a}),this.network.addEventListener("peer",y=>{const p=y.detail;this.onPeerConnect(p).catch(w=>{this.log.error("could not add %p to routing table",p.id,w)}),this.dispatchEvent(new CustomEvent("peer",{detail:p}))}),this.topologyListener.addEventListener("peer",y=>{const p=y.detail;Promise.resolve().then(async()=>{const w=await this.components.peerStore.get(p),v={id:p,multiaddrs:w.addresses.map(({multiaddr:x})=>x),protocols:w.protocols};await this.onPeerConnect(v)}).catch(w=>{this.log.error("could not add %p to routing table - %e",p,w)})}),this.dhtPeerRouting=new fR(this),this.dhtContentRouting=new dR(this),r.clientMode==null&&e.events.addEventListener("self:peer:update",y=>{this.log("received update of self-peer info"),Promise.resolve().then(async()=>{const p=y.detail.peer.addresses.some(({multiaddr:v})=>bD(v)),w=this.getMode();p&&w==="client"?await this.setMode("server"):w==="server"&&!p&&await this.setMode("client")}).catch(p=>{this.log.error("error setting dht server mode",p)})}),this.get=Bi(this.get.bind(this),a,"GET_VALUE"),this.findProviders=Bi(this.findProviders.bind(this),a,"FIND_PROVIDERS"),this.findPeer=Bi(this.findPeer.bind(this),a,"FIND_PEER"),this.getClosestPeers=Bi(this.getClosestPeers.bind(this),a,"GET_CLOSEST_PEERS"),this.provide=Bi(this.provide.bind(this),a,"PROVIDE"),this.put=Bi(this.put.bind(this),a,"PUT_VALUE")}get[(i4=Symbol.toStringTag,s4=Pt,n4=ms,yo)](){return this.dhtContentRouting}get[wo](){return this.dhtPeerRouting}get[El](){return this}async onPeerConnect(e){if(this.log.trace("peer %p connected",e.id),e=this.peerInfoMapper(e),e.multiaddrs.length===0){this.log.trace("ignoring %p as there were no valid addresses in %s after filtering",e.id,e.multiaddrs.map(r=>r.toString()));return}try{await this.routingTable.add(e.id)}catch(r){this.log.error("could not add %p to routing table",e.id,r)}}isStarted(){return this.running}getMode(){return this.clientMode?"client":"server"}async setMode(e,r=!1){if(e===this.getMode()&&!r){this.log("already in %s mode",e);return}if(await this.components.registrar.unhandle(this.protocol),e===this.getMode()&&!r){this.log("already in %s mode",e);return}e==="client"?(this.log("enabling client mode while in %s mode",this.getMode()),this.clientMode=!0):(this.log("enabling server mode while in %s mode",this.getMode()),this.clientMode=!1,await this.components.registrar.handle(this.protocol,this.rpc.onIncomingStream.bind(this.rpc),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}))}async start(){this.running||(this.running=!0,await this.setMode(this.clientMode?"client":"server",!0),await Ln(this.routingTable,this.queryManager,this.network,this.topologyListener,this.routingTableRefresh,this.reprovider),await Ln(this.querySelf))}async stop(){this.running=!1,await Cs(this.querySelf,this.queryManager,this.network,this.routingTable,this.routingTableRefresh,this.topologyListener,this.reprovider)}async*put(e,r,s={}){yield*this.contentFetching.put(e,r,s)}async*get(e,r={}){yield*this.contentFetching.get(e,r)}async*provide(e,r={}){yield*this.contentRouting.provide(e,this.components.addressManager.getAddresses(),r)}async cancelReprovide(e){await this.providers.removeProvider(e,this.components.peerId)}async*findProviders(e,r={}){yield*this.contentRouting.findProviders(e,r)}async*findPeer(e,r={}){yield*this.peerRouting.findPeer(e,r)}async*getClosestPeers(e,r={}){yield*this.peerRouting.getClosestPeers(e,r)}async refreshRoutingTable(){this.routingTableRefresh.refreshTable(!0)}}var C1;(function(n){n[n.SEND_QUERY=0]="SEND_QUERY",n[n.PEER_RESPONSE=1]="PEER_RESPONSE",n[n.FINAL_PEER=2]="FINAL_PEER",n[n.QUERY_ERROR=3]="QUERY_ERROR",n[n.PROVIDER=4]="PROVIDER",n[n.VALUE=5]="VALUE",n[n.ADD_PEER=6]="ADD_PEER",n[n.DIAL_PEER=7]="DIAL_PEER"})(C1||(C1={}));function yR(n={}){return t=>new mR(t,n)}var Jh,hp;function wR(){return hp||(hp=1,Jh=n=>{if(Object.prototype.toString.call(n)!=="[object Object]")return!1;const t=Object.getPrototypeOf(n);return t===null||t===Object.prototype}),Jh}var Yc,dp;function bR(){if(dp)return Yc;dp=1;const n=wR(),{hasOwnProperty:t}=Object.prototype,{propertyIsEnumerable:e}=Object,r=(g,y,p)=>Object.defineProperty(g,y,{value:p,writable:!0,enumerable:!0,configurable:!0}),s=Yc,i={concatArrays:!1,ignoreUndefined:!1},o=g=>{const y=[];for(const p in g)t.call(g,p)&&y.push(p);if(Object.getOwnPropertySymbols){const p=Object.getOwnPropertySymbols(g);for(const w of p)e.call(g,w)&&y.push(w)}return y};function a(g){return Array.isArray(g)?c(g):n(g)?l(g):g}function c(g){const y=g.slice(0,0);return o(g).forEach(p=>{r(y,p,a(g[p]))}),y}function l(g){const y=Object.getPrototypeOf(g)===null?Object.create(null):{};return o(g).forEach(p=>{r(y,p,a(g[p]))}),y}const h=(g,y,p,w)=>(p.forEach(v=>{typeof y[v]>"u"&&w.ignoreUndefined||(v in g&&g[v]!==Object.getPrototypeOf(g)?r(g,v,f(g[v],y[v],w)):r(g,v,a(y[v])))}),g),d=(g,y,p)=>{let w=g.slice(0,0),v=0;return[g,y].forEach(x=>{const S=[];for(let I=0;I<x.length;I++)t.call(x,I)&&(S.push(String(I)),x===g?r(w,v++,x[I]):r(w,v++,a(x[I])));w=h(w,x,o(x).filter(I=>!S.includes(I)),p)}),w};function f(g,y,p){return p.concatArrays&&Array.isArray(g)&&Array.isArray(y)?d(g,y,p):!n(y)||!n(g)?a(y):h(g,y,o(y),p)}return Yc=function(...g){const y=f(a(i),this!==s&&this||{},i);let p={_:{}};for(const w of g)if(w!==void 0){if(!n(w))throw new TypeError("`"+w+"` is not an Option Object");p=f(p,{_:w},y)}return p._},Yc}var vR=bR();const Gr=Fn(vR);var jh,fp;function ER(){if(fp)return jh;fp=1;function n(e){return e>=55296&&e<=56319}function t(e){return e>=56320&&e<=57343}return jh=function(r,s,i){if(typeof s!="string")throw new Error("Input must be string");for(var o=s.length,a=0,c,l,h=0;h<o;h+=1){if(c=s.charCodeAt(h),l=s[h],n(c)&&t(s.charCodeAt(h+1))&&(h+=1,l+=s[h]),a+=r(l),a===i)return s.slice(0,h+1);if(a>i)return s.slice(0,h-l.length+1)}return s},jh}var ed,gp;function SR(){if(gp)return ed;gp=1;function n(e){return e>=55296&&e<=56319}function t(e){return e>=56320&&e<=57343}return ed=function(r){if(typeof r!="string")throw new Error("Input must be string");for(var s=r.length,i=0,o=null,a=null,c=0;c<s;c++)o=r.charCodeAt(c),t(o)?a!=null&&n(a)?i+=1:i+=3:o<=127?i+=1:o>=128&&o<=2047?i+=2:o>=2048&&o<=65535&&(i+=3),a=o;return i},ed}var td,pp;function xR(){if(pp)return td;pp=1;var n=ER(),t=SR();return td=n.bind(null,t),td}var rd,mp;function _R(){if(mp)return rd;mp=1;var n=xR(),t=/[\/\?<>\\:\*\|"]/g,e=/[\x00-\x1f\x80-\x9f]/g,r=/^\.+$/,s=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,i=/[\. ]+$/;function o(a,c){if(typeof a!="string")throw new Error("Input must be string");var l=a.replace(t,c).replace(e,c).replace(r,c).replace(s,c).replace(i,c);return n(l,255)}return rd=function(a,c){var l=c&&c.replacement||"",h=o(a,l);return l===""?h:o(h,"")},rd}var kR=_R();const IR=Fn(kR),nd={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function Im(n){const t="AES-GCM";let e=16;const r=12,s="SHA-256",i=16,o=32767,a=pn.get();e*=8;async function c(d,f){const g=a.getRandomValues(new Uint8Array(i)),y=a.getRandomValues(new Uint8Array(r)),p={name:t,iv:y};typeof f=="string"&&(f=Y(f));let w;if(f.length===0){w=await a.subtle.importKey("jwk",nd,{name:"AES-GCM"},!0,["encrypt"]);try{const x={name:"PBKDF2",salt:g,iterations:o,hash:{name:s}},S=await a.subtle.importKey("raw",f,{name:"PBKDF2"},!1,["deriveKey"]);w=await a.subtle.deriveKey(x,S,{name:t,length:e},!0,["encrypt"])}catch{w=await a.subtle.importKey("jwk",nd,{name:"AES-GCM"},!0,["encrypt"])}}else{const x={name:"PBKDF2",salt:g,iterations:o,hash:{name:s}},S=await a.subtle.importKey("raw",f,{name:"PBKDF2"},!1,["deriveKey"]);w=await a.subtle.deriveKey(x,S,{name:t,length:e},!0,["encrypt"])}const v=await a.subtle.encrypt(p,w,d);return ft([g,p.iv,new Uint8Array(v)])}async function l(d,f){const g=d.subarray(0,i),y=d.subarray(i,i+r),p=d.subarray(i+r),w={name:t,iv:y};typeof f=="string"&&(f=Y(f));let v;if(f.length===0)try{const S={name:"PBKDF2",salt:g,iterations:o,hash:{name:s}},I=await a.subtle.importKey("raw",f,{name:"PBKDF2"},!1,["deriveKey"]);v=await a.subtle.deriveKey(S,I,{name:t,length:e},!0,["decrypt"])}catch{v=await a.subtle.importKey("jwk",nd,{name:"AES-GCM"},!0,["decrypt"])}else{const S={name:"PBKDF2",salt:g,iterations:o,hash:{name:s}},I=await a.subtle.importKey("raw",f,{name:"PBKDF2"},!1,["deriveKey"]);v=await a.subtle.deriveKey(S,I,{name:t,length:e},!0,["decrypt"])}const x=await a.subtle.decrypt(w,v,p);return new Uint8Array(x)}return{encrypt:c,decrypt:l}}var Am={},ah={};ah.byteLength=CR;ah.toByteArray=DR;ah.fromByteArray=MR;var ln=[],wr=[],AR=typeof Uint8Array<"u"?Uint8Array:Array,sd="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var Mi=0,TR=sd.length;Mi<TR;++Mi)ln[Mi]=sd[Mi],wr[sd.charCodeAt(Mi)]=Mi;wr[45]=62;wr[95]=63;function Tm(n){var t=n.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var e=n.indexOf("=");e===-1&&(e=t);var r=e===t?0:4-e%4;return[e,r]}function CR(n){var t=Tm(n),e=t[0],r=t[1];return(e+r)*3/4-r}function PR(n,t,e){return(t+e)*3/4-e}function DR(n){var t,e=Tm(n),r=e[0],s=e[1],i=new AR(PR(n,r,s)),o=0,a=s>0?r-4:r,c;for(c=0;c<a;c+=4)t=wr[n.charCodeAt(c)]<<18|wr[n.charCodeAt(c+1)]<<12|wr[n.charCodeAt(c+2)]<<6|wr[n.charCodeAt(c+3)],i[o++]=t>>16&255,i[o++]=t>>8&255,i[o++]=t&255;return s===2&&(t=wr[n.charCodeAt(c)]<<2|wr[n.charCodeAt(c+1)]>>4,i[o++]=t&255),s===1&&(t=wr[n.charCodeAt(c)]<<10|wr[n.charCodeAt(c+1)]<<4|wr[n.charCodeAt(c+2)]>>2,i[o++]=t>>8&255,i[o++]=t&255),i}function RR(n){return ln[n>>18&63]+ln[n>>12&63]+ln[n>>6&63]+ln[n&63]}function BR(n,t,e){for(var r,s=[],i=t;i<e;i+=3)r=(n[i]<<16&16711680)+(n[i+1]<<8&65280)+(n[i+2]&255),s.push(RR(r));return s.join("")}function MR(n){for(var t,e=n.length,r=e%3,s=[],i=16383,o=0,a=e-r;o<a;o+=i)s.push(BR(n,o,o+i>a?a:o+i));return r===1?(t=n[e-1],s.push(ln[t>>2]+ln[t<<4&63]+"==")):r===2&&(t=(n[e-2]<<8)+n[e-1],s.push(ln[t>>10]+ln[t>>4&63]+ln[t<<2&63]+"=")),s.join("")}var k0={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */k0.read=function(n,t,e,r,s){var i,o,a=s*8-r-1,c=(1<<a)-1,l=c>>1,h=-7,d=e?s-1:0,f=e?-1:1,g=n[t+d];for(d+=f,i=g&(1<<-h)-1,g>>=-h,h+=a;h>0;i=i*256+n[t+d],d+=f,h-=8);for(o=i&(1<<-h)-1,i>>=-h,h+=r;h>0;o=o*256+n[t+d],d+=f,h-=8);if(i===0)i=1-l;else{if(i===c)return o?NaN:(g?-1:1)*(1/0);o=o+Math.pow(2,r),i=i-l}return(g?-1:1)*o*Math.pow(2,i-r)};k0.write=function(n,t,e,r,s,i){var o,a,c,l=i*8-s-1,h=(1<<l)-1,d=h>>1,f=s===23?Math.pow(2,-24)-Math.pow(2,-77):0,g=r?0:i-1,y=r?1:-1,p=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,o=h):(o=Math.floor(Math.log(t)/Math.LN2),t*(c=Math.pow(2,-o))<1&&(o--,c*=2),o+d>=1?t+=f/c:t+=f*Math.pow(2,1-d),t*c>=2&&(o++,c/=2),o+d>=h?(a=0,o=h):o+d>=1?(a=(t*c-1)*Math.pow(2,s),o=o+d):(a=t*Math.pow(2,d-1)*Math.pow(2,s),o=0));s>=8;n[e+g]=a&255,g+=y,a/=256,s-=8);for(o=o<<s|a,l+=s;l>0;n[e+g]=o&255,g+=y,o/=256,l-=8);n[e+g-y]|=p*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(n){const t=ah,e=k0,r=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=h,n.SlowBuffer=P,n.INSPECT_MAX_BYTES=50;const s=2147483647;n.kMaxLength=s;const{Uint8Array:i,ArrayBuffer:o,SharedArrayBuffer:a}=globalThis;h.TYPED_ARRAY_SUPPORT=c(),!h.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function c(){try{const E=new i(1),m={foo:function(){return 42}};return Object.setPrototypeOf(m,i.prototype),Object.setPrototypeOf(E,m),E.foo()===42}catch{return!1}}Object.defineProperty(h.prototype,"parent",{enumerable:!0,get:function(){if(h.isBuffer(this))return this.buffer}}),Object.defineProperty(h.prototype,"offset",{enumerable:!0,get:function(){if(h.isBuffer(this))return this.byteOffset}});function l(E){if(E>s)throw new RangeError('The value "'+E+'" is invalid for option "size"');const m=new i(E);return Object.setPrototypeOf(m,h.prototype),m}function h(E,m,b){if(typeof E=="number"){if(typeof m=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return y(E)}return d(E,m,b)}h.poolSize=8192;function d(E,m,b){if(typeof E=="string")return p(E,m);if(o.isView(E))return v(E);if(E==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof E);if(ar(E,o)||E&&ar(E.buffer,o)||typeof a<"u"&&(ar(E,a)||E&&ar(E.buffer,a)))return x(E,m,b);if(typeof E=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const _=E.valueOf&&E.valueOf();if(_!=null&&_!==E)return h.from(_,m,b);const D=S(E);if(D)return D;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof E[Symbol.toPrimitive]=="function")return h.from(E[Symbol.toPrimitive]("string"),m,b);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof E)}h.from=function(E,m,b){return d(E,m,b)},Object.setPrototypeOf(h.prototype,i.prototype),Object.setPrototypeOf(h,i);function f(E){if(typeof E!="number")throw new TypeError('"size" argument must be of type number');if(E<0)throw new RangeError('The value "'+E+'" is invalid for option "size"')}function g(E,m,b){return f(E),E<=0?l(E):m!==void 0?typeof b=="string"?l(E).fill(m,b):l(E).fill(m):l(E)}h.alloc=function(E,m,b){return g(E,m,b)};function y(E){return f(E),l(E<0?0:I(E)|0)}h.allocUnsafe=function(E){return y(E)},h.allocUnsafeSlow=function(E){return y(E)};function p(E,m){if((typeof m!="string"||m==="")&&(m="utf8"),!h.isEncoding(m))throw new TypeError("Unknown encoding: "+m);const b=A(E,m)|0;let _=l(b);const D=_.write(E,m);return D!==b&&(_=_.slice(0,D)),_}function w(E){const m=E.length<0?0:I(E.length)|0,b=l(m);for(let _=0;_<m;_+=1)b[_]=E[_]&255;return b}function v(E){if(ar(E,i)){const m=new i(E);return x(m.buffer,m.byteOffset,m.byteLength)}return w(E)}function x(E,m,b){if(m<0||E.byteLength<m)throw new RangeError('"offset" is outside of buffer bounds');if(E.byteLength<m+(b||0))throw new RangeError('"length" is outside of buffer bounds');let _;return m===void 0&&b===void 0?_=new i(E):b===void 0?_=new i(E,m):_=new i(E,m,b),Object.setPrototypeOf(_,h.prototype),_}function S(E){if(h.isBuffer(E)){const m=I(E.length)|0,b=l(m);return b.length===0||E.copy(b,0,0,m),b}if(E.length!==void 0)return typeof E.length!="number"||Ci(E.length)?l(0):w(E);if(E.type==="Buffer"&&Array.isArray(E.data))return w(E.data)}function I(E){if(E>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return E|0}function P(E){return+E!=E&&(E=0),h.alloc(+E)}h.isBuffer=function(m){return m!=null&&m._isBuffer===!0&&m!==h.prototype},h.compare=function(m,b){if(ar(m,i)&&(m=h.from(m,m.offset,m.byteLength)),ar(b,i)&&(b=h.from(b,b.offset,b.byteLength)),!h.isBuffer(m)||!h.isBuffer(b))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(m===b)return 0;let _=m.length,D=b.length;for(let O=0,H=Math.min(_,D);O<H;++O)if(m[O]!==b[O]){_=m[O],D=b[O];break}return _<D?-1:D<_?1:0},h.isEncoding=function(m){switch(String(m).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},h.concat=function(m,b){if(!Array.isArray(m))throw new TypeError('"list" argument must be an Array of Buffers');if(m.length===0)return h.alloc(0);let _;if(b===void 0)for(b=0,_=0;_<m.length;++_)b+=m[_].length;const D=h.allocUnsafe(b);let O=0;for(_=0;_<m.length;++_){let H=m[_];if(ar(H,i))O+H.length>D.length?(h.isBuffer(H)||(H=h.from(H)),H.copy(D,O)):i.prototype.set.call(D,H,O);else if(h.isBuffer(H))H.copy(D,O);else throw new TypeError('"list" argument must be an Array of Buffers');O+=H.length}return D};function A(E,m){if(h.isBuffer(E))return E.length;if(o.isView(E)||ar(E,o))return E.byteLength;if(typeof E!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof E);const b=E.length,_=arguments.length>2&&arguments[2]===!0;if(!_&&b===0)return 0;let D=!1;for(;;)switch(m){case"ascii":case"latin1":case"binary":return b;case"utf8":case"utf-8":return Ti(E).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return b*2;case"hex":return b>>>1;case"base64":return ra(E).length;default:if(D)return _?-1:Ti(E).length;m=(""+m).toLowerCase(),D=!0}}h.byteLength=A;function C(E,m,b){let _=!1;if((m===void 0||m<0)&&(m=0),m>this.length||((b===void 0||b>this.length)&&(b=this.length),b<=0)||(b>>>=0,m>>>=0,b<=m))return"";for(E||(E="utf8");;)switch(E){case"hex":return re(this,m,b);case"utf8":case"utf-8":return R(this,m,b);case"ascii":return K(this,m,b);case"latin1":case"binary":return J(this,m,b);case"base64":return M(this,m,b);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ae(this,m,b);default:if(_)throw new TypeError("Unknown encoding: "+E);E=(E+"").toLowerCase(),_=!0}}h.prototype._isBuffer=!0;function T(E,m,b){const _=E[m];E[m]=E[b],E[b]=_}h.prototype.swap16=function(){const m=this.length;if(m%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let b=0;b<m;b+=2)T(this,b,b+1);return this},h.prototype.swap32=function(){const m=this.length;if(m%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let b=0;b<m;b+=4)T(this,b,b+3),T(this,b+1,b+2);return this},h.prototype.swap64=function(){const m=this.length;if(m%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let b=0;b<m;b+=8)T(this,b,b+7),T(this,b+1,b+6),T(this,b+2,b+5),T(this,b+3,b+4);return this},h.prototype.toString=function(){const m=this.length;return m===0?"":arguments.length===0?R(this,0,m):C.apply(this,arguments)},h.prototype.toLocaleString=h.prototype.toString,h.prototype.equals=function(m){if(!h.isBuffer(m))throw new TypeError("Argument must be a Buffer");return this===m?!0:h.compare(this,m)===0},h.prototype.inspect=function(){let m="";const b=n.INSPECT_MAX_BYTES;return m=this.toString("hex",0,b).replace(/(.{2})/g,"$1 ").trim(),this.length>b&&(m+=" ... "),"<Buffer "+m+">"},r&&(h.prototype[r]=h.prototype.inspect),h.prototype.compare=function(m,b,_,D,O){if(ar(m,i)&&(m=h.from(m,m.offset,m.byteLength)),!h.isBuffer(m))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof m);if(b===void 0&&(b=0),_===void 0&&(_=m?m.length:0),D===void 0&&(D=0),O===void 0&&(O=this.length),b<0||_>m.length||D<0||O>this.length)throw new RangeError("out of range index");if(D>=O&&b>=_)return 0;if(D>=O)return-1;if(b>=_)return 1;if(b>>>=0,_>>>=0,D>>>=0,O>>>=0,this===m)return 0;let H=O-D,be=_-b;const tt=Math.min(H,be),Ye=this.slice(D,O),rt=m.slice(b,_);for(let Ue=0;Ue<tt;++Ue)if(Ye[Ue]!==rt[Ue]){H=Ye[Ue],be=rt[Ue];break}return H<be?-1:be<H?1:0};function k(E,m,b,_,D){if(E.length===0)return-1;if(typeof b=="string"?(_=b,b=0):b>2147483647?b=2147483647:b<-2147483648&&(b=-2147483648),b=+b,Ci(b)&&(b=D?0:E.length-1),b<0&&(b=E.length+b),b>=E.length){if(D)return-1;b=E.length-1}else if(b<0)if(D)b=0;else return-1;if(typeof m=="string"&&(m=h.from(m,_)),h.isBuffer(m))return m.length===0?-1:N(E,m,b,_,D);if(typeof m=="number")return m=m&255,typeof i.prototype.indexOf=="function"?D?i.prototype.indexOf.call(E,m,b):i.prototype.lastIndexOf.call(E,m,b):N(E,[m],b,_,D);throw new TypeError("val must be string, number or Buffer")}function N(E,m,b,_,D){let O=1,H=E.length,be=m.length;if(_!==void 0&&(_=String(_).toLowerCase(),_==="ucs2"||_==="ucs-2"||_==="utf16le"||_==="utf-16le")){if(E.length<2||m.length<2)return-1;O=2,H/=2,be/=2,b/=2}function tt(rt,Ue){return O===1?rt[Ue]:rt.readUInt16BE(Ue*O)}let Ye;if(D){let rt=-1;for(Ye=b;Ye<H;Ye++)if(tt(E,Ye)===tt(m,rt===-1?0:Ye-rt)){if(rt===-1&&(rt=Ye),Ye-rt+1===be)return rt*O}else rt!==-1&&(Ye-=Ye-rt),rt=-1}else for(b+be>H&&(b=H-be),Ye=b;Ye>=0;Ye--){let rt=!0;for(let Ue=0;Ue<be;Ue++)if(tt(E,Ye+Ue)!==tt(m,Ue)){rt=!1;break}if(rt)return Ye}return-1}h.prototype.includes=function(m,b,_){return this.indexOf(m,b,_)!==-1},h.prototype.indexOf=function(m,b,_){return k(this,m,b,_,!0)},h.prototype.lastIndexOf=function(m,b,_){return k(this,m,b,_,!1)};function $(E,m,b,_){b=Number(b)||0;const D=E.length-b;_?(_=Number(_),_>D&&(_=D)):_=D;const O=m.length;_>O/2&&(_=O/2);let H;for(H=0;H<_;++H){const be=parseInt(m.substr(H*2,2),16);if(Ci(be))return H;E[b+H]=be}return H}function z(E,m,b,_){return Ns(Ti(m,E.length-b),E,b,_)}function q(E,m,b,_){return Ns(xc(m),E,b,_)}function U(E,m,b,_){return Ns(ra(m),E,b,_)}function L(E,m,b,_){return Ns(ta(m,E.length-b),E,b,_)}h.prototype.write=function(m,b,_,D){if(b===void 0)D="utf8",_=this.length,b=0;else if(_===void 0&&typeof b=="string")D=b,_=this.length,b=0;else if(isFinite(b))b=b>>>0,isFinite(_)?(_=_>>>0,D===void 0&&(D="utf8")):(D=_,_=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const O=this.length-b;if((_===void 0||_>O)&&(_=O),m.length>0&&(_<0||b<0)||b>this.length)throw new RangeError("Attempt to write outside buffer bounds");D||(D="utf8");let H=!1;for(;;)switch(D){case"hex":return $(this,m,b,_);case"utf8":case"utf-8":return z(this,m,b,_);case"ascii":case"latin1":case"binary":return q(this,m,b,_);case"base64":return U(this,m,b,_);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return L(this,m,b,_);default:if(H)throw new TypeError("Unknown encoding: "+D);D=(""+D).toLowerCase(),H=!0}},h.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function M(E,m,b){return m===0&&b===E.length?t.fromByteArray(E):t.fromByteArray(E.slice(m,b))}function R(E,m,b){b=Math.min(E.length,b);const _=[];let D=m;for(;D<b;){const O=E[D];let H=null,be=O>239?4:O>223?3:O>191?2:1;if(D+be<=b){let tt,Ye,rt,Ue;switch(be){case 1:O<128&&(H=O);break;case 2:tt=E[D+1],(tt&192)===128&&(Ue=(O&31)<<6|tt&63,Ue>127&&(H=Ue));break;case 3:tt=E[D+1],Ye=E[D+2],(tt&192)===128&&(Ye&192)===128&&(Ue=(O&15)<<12|(tt&63)<<6|Ye&63,Ue>2047&&(Ue<55296||Ue>57343)&&(H=Ue));break;case 4:tt=E[D+1],Ye=E[D+2],rt=E[D+3],(tt&192)===128&&(Ye&192)===128&&(rt&192)===128&&(Ue=(O&15)<<18|(tt&63)<<12|(Ye&63)<<6|rt&63,Ue>65535&&Ue<1114112&&(H=Ue))}}H===null?(H=65533,be=1):H>65535&&(H-=65536,_.push(H>>>10&1023|55296),H=56320|H&1023),_.push(H),D+=be}return F(_)}const V=4096;function F(E){const m=E.length;if(m<=V)return String.fromCharCode.apply(String,E);let b="",_=0;for(;_<m;)b+=String.fromCharCode.apply(String,E.slice(_,_+=V));return b}function K(E,m,b){let _="";b=Math.min(E.length,b);for(let D=m;D<b;++D)_+=String.fromCharCode(E[D]&127);return _}function J(E,m,b){let _="";b=Math.min(E.length,b);for(let D=m;D<b;++D)_+=String.fromCharCode(E[D]);return _}function re(E,m,b){const _=E.length;(!m||m<0)&&(m=0),(!b||b<0||b>_)&&(b=_);let D="";for(let O=m;O<b;++O)D+=_c[E[O]];return D}function ae(E,m,b){const _=E.slice(m,b);let D="";for(let O=0;O<_.length-1;O+=2)D+=String.fromCharCode(_[O]+_[O+1]*256);return D}h.prototype.slice=function(m,b){const _=this.length;m=~~m,b=b===void 0?_:~~b,m<0?(m+=_,m<0&&(m=0)):m>_&&(m=_),b<0?(b+=_,b<0&&(b=0)):b>_&&(b=_),b<m&&(b=m);const D=this.subarray(m,b);return Object.setPrototypeOf(D,h.prototype),D};function j(E,m,b){if(E%1!==0||E<0)throw new RangeError("offset is not uint");if(E+m>b)throw new RangeError("Trying to access beyond buffer length")}h.prototype.readUintLE=h.prototype.readUIntLE=function(m,b,_){m=m>>>0,b=b>>>0,_||j(m,b,this.length);let D=this[m],O=1,H=0;for(;++H<b&&(O*=256);)D+=this[m+H]*O;return D},h.prototype.readUintBE=h.prototype.readUIntBE=function(m,b,_){m=m>>>0,b=b>>>0,_||j(m,b,this.length);let D=this[m+--b],O=1;for(;b>0&&(O*=256);)D+=this[m+--b]*O;return D},h.prototype.readUint8=h.prototype.readUInt8=function(m,b){return m=m>>>0,b||j(m,1,this.length),this[m]},h.prototype.readUint16LE=h.prototype.readUInt16LE=function(m,b){return m=m>>>0,b||j(m,2,this.length),this[m]|this[m+1]<<8},h.prototype.readUint16BE=h.prototype.readUInt16BE=function(m,b){return m=m>>>0,b||j(m,2,this.length),this[m]<<8|this[m+1]},h.prototype.readUint32LE=h.prototype.readUInt32LE=function(m,b){return m=m>>>0,b||j(m,4,this.length),(this[m]|this[m+1]<<8|this[m+2]<<16)+this[m+3]*16777216},h.prototype.readUint32BE=h.prototype.readUInt32BE=function(m,b){return m=m>>>0,b||j(m,4,this.length),this[m]*16777216+(this[m+1]<<16|this[m+2]<<8|this[m+3])},h.prototype.readBigUInt64LE=Yr(function(m){m=m>>>0,qn(m,"offset");const b=this[m],_=this[m+7];(b===void 0||_===void 0)&&Ms(m,this.length-8);const D=b+this[++m]*2**8+this[++m]*2**16+this[++m]*2**24,O=this[++m]+this[++m]*2**8+this[++m]*2**16+_*2**24;return BigInt(D)+(BigInt(O)<<BigInt(32))}),h.prototype.readBigUInt64BE=Yr(function(m){m=m>>>0,qn(m,"offset");const b=this[m],_=this[m+7];(b===void 0||_===void 0)&&Ms(m,this.length-8);const D=b*2**24+this[++m]*2**16+this[++m]*2**8+this[++m],O=this[++m]*2**24+this[++m]*2**16+this[++m]*2**8+_;return(BigInt(D)<<BigInt(32))+BigInt(O)}),h.prototype.readIntLE=function(m,b,_){m=m>>>0,b=b>>>0,_||j(m,b,this.length);let D=this[m],O=1,H=0;for(;++H<b&&(O*=256);)D+=this[m+H]*O;return O*=128,D>=O&&(D-=Math.pow(2,8*b)),D},h.prototype.readIntBE=function(m,b,_){m=m>>>0,b=b>>>0,_||j(m,b,this.length);let D=b,O=1,H=this[m+--D];for(;D>0&&(O*=256);)H+=this[m+--D]*O;return O*=128,H>=O&&(H-=Math.pow(2,8*b)),H},h.prototype.readInt8=function(m,b){return m=m>>>0,b||j(m,1,this.length),this[m]&128?(255-this[m]+1)*-1:this[m]},h.prototype.readInt16LE=function(m,b){m=m>>>0,b||j(m,2,this.length);const _=this[m]|this[m+1]<<8;return _&32768?_|4294901760:_},h.prototype.readInt16BE=function(m,b){m=m>>>0,b||j(m,2,this.length);const _=this[m+1]|this[m]<<8;return _&32768?_|4294901760:_},h.prototype.readInt32LE=function(m,b){return m=m>>>0,b||j(m,4,this.length),this[m]|this[m+1]<<8|this[m+2]<<16|this[m+3]<<24},h.prototype.readInt32BE=function(m,b){return m=m>>>0,b||j(m,4,this.length),this[m]<<24|this[m+1]<<16|this[m+2]<<8|this[m+3]},h.prototype.readBigInt64LE=Yr(function(m){m=m>>>0,qn(m,"offset");const b=this[m],_=this[m+7];(b===void 0||_===void 0)&&Ms(m,this.length-8);const D=this[m+4]+this[m+5]*2**8+this[m+6]*2**16+(_<<24);return(BigInt(D)<<BigInt(32))+BigInt(b+this[++m]*2**8+this[++m]*2**16+this[++m]*2**24)}),h.prototype.readBigInt64BE=Yr(function(m){m=m>>>0,qn(m,"offset");const b=this[m],_=this[m+7];(b===void 0||_===void 0)&&Ms(m,this.length-8);const D=(b<<24)+this[++m]*2**16+this[++m]*2**8+this[++m];return(BigInt(D)<<BigInt(32))+BigInt(this[++m]*2**24+this[++m]*2**16+this[++m]*2**8+_)}),h.prototype.readFloatLE=function(m,b){return m=m>>>0,b||j(m,4,this.length),e.read(this,m,!0,23,4)},h.prototype.readFloatBE=function(m,b){return m=m>>>0,b||j(m,4,this.length),e.read(this,m,!1,23,4)},h.prototype.readDoubleLE=function(m,b){return m=m>>>0,b||j(m,8,this.length),e.read(this,m,!0,52,8)},h.prototype.readDoubleBE=function(m,b){return m=m>>>0,b||j(m,8,this.length),e.read(this,m,!1,52,8)};function oe(E,m,b,_,D,O){if(!h.isBuffer(E))throw new TypeError('"buffer" argument must be a Buffer instance');if(m>D||m<O)throw new RangeError('"value" argument is out of bounds');if(b+_>E.length)throw new RangeError("Index out of range")}h.prototype.writeUintLE=h.prototype.writeUIntLE=function(m,b,_,D){if(m=+m,b=b>>>0,_=_>>>0,!D){const be=Math.pow(2,8*_)-1;oe(this,m,b,_,be,0)}let O=1,H=0;for(this[b]=m&255;++H<_&&(O*=256);)this[b+H]=m/O&255;return b+_},h.prototype.writeUintBE=h.prototype.writeUIntBE=function(m,b,_,D){if(m=+m,b=b>>>0,_=_>>>0,!D){const be=Math.pow(2,8*_)-1;oe(this,m,b,_,be,0)}let O=_-1,H=1;for(this[b+O]=m&255;--O>=0&&(H*=256);)this[b+O]=m/H&255;return b+_},h.prototype.writeUint8=h.prototype.writeUInt8=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,1,255,0),this[b]=m&255,b+1},h.prototype.writeUint16LE=h.prototype.writeUInt16LE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,2,65535,0),this[b]=m&255,this[b+1]=m>>>8,b+2},h.prototype.writeUint16BE=h.prototype.writeUInt16BE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,2,65535,0),this[b]=m>>>8,this[b+1]=m&255,b+2},h.prototype.writeUint32LE=h.prototype.writeUInt32LE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,4,4294967295,0),this[b+3]=m>>>24,this[b+2]=m>>>16,this[b+1]=m>>>8,this[b]=m&255,b+4},h.prototype.writeUint32BE=h.prototype.writeUInt32BE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,4,4294967295,0),this[b]=m>>>24,this[b+1]=m>>>16,this[b+2]=m>>>8,this[b+3]=m&255,b+4};function we(E,m,b,_,D){lt(m,_,D,E,b,7);let O=Number(m&BigInt(4294967295));E[b++]=O,O=O>>8,E[b++]=O,O=O>>8,E[b++]=O,O=O>>8,E[b++]=O;let H=Number(m>>BigInt(32)&BigInt(4294967295));return E[b++]=H,H=H>>8,E[b++]=H,H=H>>8,E[b++]=H,H=H>>8,E[b++]=H,b}function Pe(E,m,b,_,D){lt(m,_,D,E,b,7);let O=Number(m&BigInt(4294967295));E[b+7]=O,O=O>>8,E[b+6]=O,O=O>>8,E[b+5]=O,O=O>>8,E[b+4]=O;let H=Number(m>>BigInt(32)&BigInt(4294967295));return E[b+3]=H,H=H>>8,E[b+2]=H,H=H>>8,E[b+1]=H,H=H>>8,E[b]=H,b+8}h.prototype.writeBigUInt64LE=Yr(function(m,b=0){return we(this,m,b,BigInt(0),BigInt("0xffffffffffffffff"))}),h.prototype.writeBigUInt64BE=Yr(function(m,b=0){return Pe(this,m,b,BigInt(0),BigInt("0xffffffffffffffff"))}),h.prototype.writeIntLE=function(m,b,_,D){if(m=+m,b=b>>>0,!D){const tt=Math.pow(2,8*_-1);oe(this,m,b,_,tt-1,-tt)}let O=0,H=1,be=0;for(this[b]=m&255;++O<_&&(H*=256);)m<0&&be===0&&this[b+O-1]!==0&&(be=1),this[b+O]=(m/H>>0)-be&255;return b+_},h.prototype.writeIntBE=function(m,b,_,D){if(m=+m,b=b>>>0,!D){const tt=Math.pow(2,8*_-1);oe(this,m,b,_,tt-1,-tt)}let O=_-1,H=1,be=0;for(this[b+O]=m&255;--O>=0&&(H*=256);)m<0&&be===0&&this[b+O+1]!==0&&(be=1),this[b+O]=(m/H>>0)-be&255;return b+_},h.prototype.writeInt8=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,1,127,-128),m<0&&(m=255+m+1),this[b]=m&255,b+1},h.prototype.writeInt16LE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,2,32767,-32768),this[b]=m&255,this[b+1]=m>>>8,b+2},h.prototype.writeInt16BE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,2,32767,-32768),this[b]=m>>>8,this[b+1]=m&255,b+2},h.prototype.writeInt32LE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,4,2147483647,-2147483648),this[b]=m&255,this[b+1]=m>>>8,this[b+2]=m>>>16,this[b+3]=m>>>24,b+4},h.prototype.writeInt32BE=function(m,b,_){return m=+m,b=b>>>0,_||oe(this,m,b,4,2147483647,-2147483648),m<0&&(m=4294967295+m+1),this[b]=m>>>24,this[b+1]=m>>>16,this[b+2]=m>>>8,this[b+3]=m&255,b+4},h.prototype.writeBigInt64LE=Yr(function(m,b=0){return we(this,m,b,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),h.prototype.writeBigInt64BE=Yr(function(m,b=0){return Pe(this,m,b,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function De(E,m,b,_,D,O){if(b+_>E.length)throw new RangeError("Index out of range");if(b<0)throw new RangeError("Index out of range")}function Me(E,m,b,_,D){return m=+m,b=b>>>0,D||De(E,m,b,4),e.write(E,m,b,_,23,4),b+4}h.prototype.writeFloatLE=function(m,b,_){return Me(this,m,b,!0,_)},h.prototype.writeFloatBE=function(m,b,_){return Me(this,m,b,!1,_)};function ot(E,m,b,_,D){return m=+m,b=b>>>0,D||De(E,m,b,8),e.write(E,m,b,_,52,8),b+8}h.prototype.writeDoubleLE=function(m,b,_){return ot(this,m,b,!0,_)},h.prototype.writeDoubleBE=function(m,b,_){return ot(this,m,b,!1,_)},h.prototype.copy=function(m,b,_,D){if(!h.isBuffer(m))throw new TypeError("argument should be a Buffer");if(_||(_=0),!D&&D!==0&&(D=this.length),b>=m.length&&(b=m.length),b||(b=0),D>0&&D<_&&(D=_),D===_||m.length===0||this.length===0)return 0;if(b<0)throw new RangeError("targetStart out of bounds");if(_<0||_>=this.length)throw new RangeError("Index out of range");if(D<0)throw new RangeError("sourceEnd out of bounds");D>this.length&&(D=this.length),m.length-b<D-_&&(D=m.length-b+_);const O=D-_;return this===m&&typeof i.prototype.copyWithin=="function"?this.copyWithin(b,_,D):i.prototype.set.call(m,this.subarray(_,D),b),O},h.prototype.fill=function(m,b,_,D){if(typeof m=="string"){if(typeof b=="string"?(D=b,b=0,_=this.length):typeof _=="string"&&(D=_,_=this.length),D!==void 0&&typeof D!="string")throw new TypeError("encoding must be a string");if(typeof D=="string"&&!h.isEncoding(D))throw new TypeError("Unknown encoding: "+D);if(m.length===1){const H=m.charCodeAt(0);(D==="utf8"&&H<128||D==="latin1")&&(m=H)}}else typeof m=="number"?m=m&255:typeof m=="boolean"&&(m=Number(m));if(b<0||this.length<b||this.length<_)throw new RangeError("Out of range index");if(_<=b)return this;b=b>>>0,_=_===void 0?this.length:_>>>0,m||(m=0);let O;if(typeof m=="number")for(O=b;O<_;++O)this[O]=m;else{const H=h.isBuffer(m)?m:h.from(m,D),be=H.length;if(be===0)throw new TypeError('The value "'+m+'" is invalid for argument "value"');for(O=0;O<_-b;++O)this[O+b]=H[O%be]}return this};const Je={};function at(E,m,b){Je[E]=class extends b{constructor(){super(),Object.defineProperty(this,"message",{value:m.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${E}]`,this.stack,delete this.name}get code(){return E}set code(D){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:D,writable:!0})}toString(){return`${this.name} [${E}]: ${this.message}`}}}at("ERR_BUFFER_OUT_OF_BOUNDS",function(E){return E?`${E} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),at("ERR_INVALID_ARG_TYPE",function(E,m){return`The "${E}" argument must be of type number. Received type ${typeof m}`},TypeError),at("ERR_OUT_OF_RANGE",function(E,m,b){let _=`The value of "${E}" is out of range.`,D=b;return Number.isInteger(b)&&Math.abs(b)>2**32?D=Le(String(b)):typeof b=="bigint"&&(D=String(b),(b>BigInt(2)**BigInt(32)||b<-(BigInt(2)**BigInt(32)))&&(D=Le(D)),D+="n"),_+=` It must be ${m}. Received ${D}`,_},RangeError);function Le(E){let m="",b=E.length;const _=E[0]==="-"?1:0;for(;b>=_+4;b-=3)m=`_${E.slice(b-3,b)}${m}`;return`${E.slice(0,b)}${m}`}function ct(E,m,b){qn(m,"offset"),(E[m]===void 0||E[m+b]===void 0)&&Ms(m,E.length-(b+1))}function lt(E,m,b,_,D,O){if(E>b||E<m){const H=typeof m=="bigint"?"n":"";let be;throw m===0||m===BigInt(0)?be=`>= 0${H} and < 2${H} ** ${(O+1)*8}${H}`:be=`>= -(2${H} ** ${(O+1)*8-1}${H}) and < 2 ** ${(O+1)*8-1}${H}`,new Je.ERR_OUT_OF_RANGE("value",be,E)}ct(_,D,O)}function qn(E,m){if(typeof E!="number")throw new Je.ERR_INVALID_ARG_TYPE(m,"number",E)}function Ms(E,m,b){throw Math.floor(E)!==E?(qn(E,b),new Je.ERR_OUT_OF_RANGE("offset","an integer",E)):m<0?new Je.ERR_BUFFER_OUT_OF_BOUNDS:new Je.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${m}`,E)}const mh=/[^+/0-9A-Za-z-_]/g;function yh(E){if(E=E.split("=")[0],E=E.trim().replace(mh,""),E.length<2)return"";for(;E.length%4!==0;)E=E+"=";return E}function Ti(E,m){m=m||1/0;let b;const _=E.length;let D=null;const O=[];for(let H=0;H<_;++H){if(b=E.charCodeAt(H),b>55295&&b<57344){if(!D){if(b>56319){(m-=3)>-1&&O.push(239,191,189);continue}else if(H+1===_){(m-=3)>-1&&O.push(239,191,189);continue}D=b;continue}if(b<56320){(m-=3)>-1&&O.push(239,191,189),D=b;continue}b=(D-55296<<10|b-56320)+65536}else D&&(m-=3)>-1&&O.push(239,191,189);if(D=null,b<128){if((m-=1)<0)break;O.push(b)}else if(b<2048){if((m-=2)<0)break;O.push(b>>6|192,b&63|128)}else if(b<65536){if((m-=3)<0)break;O.push(b>>12|224,b>>6&63|128,b&63|128)}else if(b<1114112){if((m-=4)<0)break;O.push(b>>18|240,b>>12&63|128,b>>6&63|128,b&63|128)}else throw new Error("Invalid code point")}return O}function xc(E){const m=[];for(let b=0;b<E.length;++b)m.push(E.charCodeAt(b)&255);return m}function ta(E,m){let b,_,D;const O=[];for(let H=0;H<E.length&&!((m-=2)<0);++H)b=E.charCodeAt(H),_=b>>8,D=b%256,O.push(D),O.push(_);return O}function ra(E){return t.toByteArray(yh(E))}function Ns(E,m,b,_){let D;for(D=0;D<_&&!(D+b>=m.length||D>=E.length);++D)m[D+b]=E[D];return D}function ar(E,m){return E instanceof m||E!=null&&E.constructor!=null&&E.constructor.name!=null&&E.constructor.name===m.name}function Ci(E){return E!==E}const _c=function(){const E="0123456789abcdef",m=new Array(256);for(let b=0;b<16;++b){const _=b*16;for(let D=0;D<16;++D)m[_+D]=E[b]+E[D]}return m}();function Yr(E){return typeof BigInt>"u"?wh:E}function wh(){throw new Error("BigInt not supported")}})(Am);const yp=Am.Buffer;/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const NR="[object ArrayBuffer]";class Ve{static isArrayBuffer(t){return Object.prototype.toString.call(t)===NR}static toArrayBuffer(t){return this.isArrayBuffer(t)?t:t.byteLength===t.buffer.byteLength||t.byteOffset===0&&t.byteLength===t.buffer.byteLength?t.buffer:this.toUint8Array(t.buffer).slice(t.byteOffset,t.byteOffset+t.byteLength).buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if(t.constructor===e)return t;if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}static isEqual(t,e){const r=Ve.toUint8Array(t),s=Ve.toUint8Array(e);if(r.length!==s.byteLength)return!1;for(let i=0;i<r.length;i++)if(r[i]!==s[i])return!1;return!0}static concat(...t){let e;Array.isArray(t[0])&&!(t[1]instanceof Function)||Array.isArray(t[0])&&t[1]instanceof Function?e=t[0]:t[t.length-1]instanceof Function?e=t.slice(0,t.length-1):e=t;let r=0;for(const o of e)r+=o.byteLength;const s=new Uint8Array(r);let i=0;for(const o of e){const a=this.toUint8Array(o);s.set(a,i),i+=a.length}return t[t.length-1]instanceof Function?this.toView(s,t[t.length-1]):s.buffer}}const id="string",LR=/^[0-9a-f\s]+$/i,OR=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,FR=/^[a-zA-Z0-9-_]+$/;class wp{static fromString(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let s=0;s<e.length;s++)r[s]=e.charCodeAt(s);return r.buffer}static toString(t){const e=Ve.toUint8Array(t);let r="";for(let i=0;i<e.length;i++)r+=String.fromCharCode(e[i]);return decodeURIComponent(escape(r))}}class Jr{static toString(t,e=!1){const r=Ve.toArrayBuffer(t),s=new DataView(r);let i="";for(let o=0;o<r.byteLength;o+=2){const a=s.getUint16(o,e);i+=String.fromCharCode(a)}return i}static fromString(t,e=!1){const r=new ArrayBuffer(t.length*2),s=new DataView(r);for(let i=0;i<t.length;i++)s.setUint16(i*2,t.charCodeAt(i),e);return r}}class it{static isHex(t){return typeof t===id&&LR.test(t)}static isBase64(t){return typeof t===id&&OR.test(t)}static isBase64Url(t){return typeof t===id&&FR.test(t)}static ToString(t,e="utf8"){const r=Ve.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return Jr.toString(r,!0);case"utf16":case"utf16be":return Jr.toString(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return Jr.fromString(t,!0);case"utf16":case"utf16be":return Jr.fromString(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=Ve.toUint8Array(t);if(typeof btoa<"u"){const r=this.ToString(e,"binary");return btoa(r)}else return yp.from(e).toString("base64")}static FromBase64(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!it.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(e)):new Uint8Array(yp.from(e,"base64")).buffer}static FromBase64Url(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!it.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,e=it.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.FromBinary(t);case"utf8":return wp.fromString(t);case"utf16":case"utf16be":return Jr.fromString(t);case"utf16le":case"usc2":return Jr.fromString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToUtf8String(t,e=it.DEFAULT_UTF8_ENCODING){switch(e){case"ascii":return this.ToBinary(t);case"utf8":return wp.toString(t);case"utf16":case"utf16be":return Jr.toString(t);case"utf16le":case"usc2":return Jr.toString(t,!0);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let s=0;s<e;s++)r[s]=t.charCodeAt(s);return r.buffer}static ToBinary(t){const e=Ve.toUint8Array(t);let r="";for(let s=0;s<e.length;s++)r+=String.fromCharCode(e[s]);return r}static ToHex(t){const e=Ve.toUint8Array(t);let r="";const s=e.length;for(let i=0;i<s;i++){const o=e[i];o<16&&(r+="0"),r+=o.toString(16)}return r}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!it.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e=`0${e}`);const r=new Uint8Array(e.length/2);for(let s=0;s<e.length;s=s+2){const i=e.slice(s,s+2);r[s/2]=parseInt(i,16)}return r.buffer}static ToUtf16String(t,e=!1){return Jr.toString(t,e)}static FromUtf16String(t,e=!1){return Jr.fromString(t,e)}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}static formatString(t){return(t==null?void 0:t.replace(/[\n\r\t ]/g,""))||""}}it.DEFAULT_UTF8_ENCODING="utf8";/*!
 Copyright (c) Peculiar Ventures, LLC
*/function Uo(n,t){let e=0;if(n.length===1)return n[0];for(let r=n.length-1;r>=0;r--)e+=n[n.length-1-r]*Math.pow(2,t*r);return e}function yi(n,t,e=-1){const r=e;let s=n,i=0,o=Math.pow(2,t);for(let a=1;a<8;a++){if(n<o){let c;if(r<0)c=new ArrayBuffer(a),i=a;else{if(r<a)return new ArrayBuffer(0);c=new ArrayBuffer(r),i=r}const l=new Uint8Array(c);for(let h=a-1;h>=0;h--){const d=Math.pow(2,h*t);l[i-h-1]=Math.floor(s/d),s-=l[i-h-1]*d}return c}o*=Math.pow(2,t)}return new ArrayBuffer(0)}function P1(...n){let t=0,e=0;for(const i of n)t+=i.length;const r=new ArrayBuffer(t),s=new Uint8Array(r);for(const i of n)s.set(i,e),e+=i.length;return s}function Cm(){const n=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=n[0]===255&&n[1]&128,c=n[0]===0&&(n[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),e=new Uint8Array(t);for(let a=0;a<this.valueHex.byteLength;a++)e[a]=0;e[0]=n[0]&128;const r=Uo(e,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)i[a]=n[a];return i[0]&=127,Uo(i,8)-r}function UR(n){const t=n<0?n*-1:n;let e=128;for(let r=1;r<8;r++){if(t<=e){if(n<0){const o=e-t,a=yi(o,8,r),c=new Uint8Array(a);return c[0]|=128,a}let s=yi(t,8,r),i=new Uint8Array(s);if(i[0]&128){const o=s.slice(0),a=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let c=0;c<o.byteLength;c++)i[c+1]=a[c];i[0]=0}return s}e*=Math.pow(2,8)}return new ArrayBuffer(0)}function $R(n,t){if(n.byteLength!==t.byteLength)return!1;const e=new Uint8Array(n),r=new Uint8Array(t);for(let s=0;s<e.length;s++)if(e[s]!==r[s])return!1;return!0}function hr(n,t){const e=n.toString(10);if(t<e.length)return"";const r=t-e.length,s=new Array(r);for(let o=0;o<r;o++)s[o]="0";return s.join("").concat(e)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function hu(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function I0(n){let t=0,e=0;for(let s=0;s<n.length;s++){const i=n[s];t+=i.byteLength}const r=new Uint8Array(t);for(let s=0;s<n.length;s++){const i=n[s];r.set(new Uint8Array(i),e),e+=i.byteLength}return r.buffer}function $n(n,t,e,r){return t instanceof Uint8Array?t.byteLength?e<0?(n.error="Wrong parameter: inputOffset less than zero",!1):r<0?(n.error="Wrong parameter: inputLength less than zero",!1):t.byteLength-e-r<0?(n.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(n.error="Wrong parameter: inputBuffer has zero length",!1):(n.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class A0{constructor(){this.items=[]}write(t){this.items.push(t)}final(){return I0(this.items)}}const oa=[new Uint8Array([1])],bp="0123456789",Xo="",Qr=new ArrayBuffer(0),T0=new Uint8Array(0),Xa="EndOfContent",Pm="OCTET STRING",Dm="BIT STRING";function zn(n){var t;return t=class extends n{constructor(...r){var s;super(...r);const i=r[0]||{};this.isHexOnly=(s=i.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=i.valueHex?Ve.toUint8Array(i.valueHex):T0}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(r){this.valueHexView=new Uint8Array(r)}fromBER(r,s,i){const o=r instanceof ArrayBuffer?new Uint8Array(r):r;if(!$n(this,o,s,i))return-1;const a=s+i;return this.valueHexView=o.subarray(s,a),this.valueHexView.length?(this.blockLength=i,a):(this.warnings.push("Zero buffer length"),s)}toBER(r=!1){return this.isHexOnly?r?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Qr)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:it.ToHex(this.valueHexView)}}},t.NAME="hexBlock",t}class Ii{constructor({blockLength:t=0,error:e=Xo,warnings:r=[],valueBeforeDecode:s=T0}={}){this.blockLength=t,this.error=e,this.warnings=r,this.valueBeforeDecodeView=Ve.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(t){this.valueBeforeDecodeView=new Uint8Array(t)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:it.ToHex(this.valueBeforeDecodeView)}}}Ii.NAME="baseBlock";class or extends Ii{fromBER(t,e,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(t,e){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}or.NAME="valueBlock";class Rm extends zn(Ii){constructor({idBlock:t={}}={}){var e,r,s,i;super(),t?(this.isHexOnly=(e=t.isHexOnly)!==null&&e!==void 0?e:!1,this.valueHexView=t.valueHex?Ve.toUint8Array(t.valueHex):T0,this.tagClass=(r=t.tagClass)!==null&&r!==void 0?r:-1,this.tagNumber=(s=t.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(i=t.isConstructed)!==null&&i!==void 0?i:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(t=!1){let e=0;switch(this.tagClass){case 1:e|=0;break;case 2:e|=64;break;case 3:e|=128;break;case 4:e|=192;break;default:return this.error="Unknown tag class",Qr}if(this.isConstructed&&(e|=32),this.tagNumber<31&&!this.isHexOnly){const s=new Uint8Array(1);if(!t){let i=this.tagNumber;i&=31,e|=i,s[0]=e}return s.buffer}if(!this.isHexOnly){const s=yi(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength,a=new Uint8Array(o+1);if(a[0]=e|31,!t){for(let c=0;c<o-1;c++)a[c+1]=i[c]|128;a[o]=i[o-1]}return a.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=e|31,!t){const s=this.valueHexView;for(let i=0;i<s.length-1;i++)r[i+1]=s[i]|128;r[this.valueHexView.byteLength]=s[s.length-1]}return r.buffer}fromBER(t,e,r){const s=Ve.toUint8Array(t);if(!$n(this,s,e,r))return-1;const i=s.subarray(e,e+r);if(i.length===0)return this.error="Zero buffer length",-1;switch(i[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(i[0]&32)===32,this.isHexOnly=!1;const a=i[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),h=255;for(;i[c]&128;){if(l[c-1]=i[c]&127,c++,c>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(c===h){h+=255;const f=new Uint8Array(h);for(let g=0;g<l.length;g++)f[g]=l[g];l=this.valueHexView=new Uint8Array(h)}}this.blockLength=c+1,l[c-1]=i[c]&127;const d=new Uint8Array(c);for(let f=0;f<c;f++)d[f]=l[f];l=this.valueHexView=new Uint8Array(c),l.set(d),this.blockLength<=9?this.tagNumber=Uo(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}Rm.NAME="identificationBlock";class Bm extends Ii{constructor({lenBlock:t={}}={}){var e,r,s;super(),this.isIndefiniteForm=(e=t.isIndefiniteForm)!==null&&e!==void 0?e:!1,this.longFormUsed=(r=t.longFormUsed)!==null&&r!==void 0?r:!1,this.length=(s=t.length)!==null&&s!==void 0?s:0}fromBER(t,e,r){const s=Ve.toUint8Array(t);if(!$n(this,s,e,r))return-1;const i=s.subarray(e,e+r);if(i.length===0)return this.error="Zero buffer length",-1;if(i[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=i[0]===128,this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(i[0]&128),this.longFormUsed===!1)return this.length=i[0],this.blockLength=1,e+this.blockLength;const o=i[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const a=e+1,c=s.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Uo(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),t===!1&&(r=new Uint8Array(e),r[0]=128),e;if(this.longFormUsed){const s=yi(this.length,8);if(s.byteLength>127)return this.error="Too big length",Qr;if(e=new ArrayBuffer(s.byteLength+1),t)return e;const i=new Uint8Array(s);r=new Uint8Array(e),r[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)r[o+1]=i[o];return e}return e=new ArrayBuffer(1),t===!1&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}Bm.NAME="lengthBlock";const ne={};class Kt extends Ii{constructor({name:t=Xo,optional:e=!1,primitiveSchema:r,...s}={},i){super(s),this.name=t,this.optional=e,r&&(this.primitiveSchema=r),this.idBlock=new Rm(s),this.lenBlock=new Bm(s),this.valueBlock=i?new i(s):new or(s)}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(t,e){const r=e||new A0;e||Mm(this);const s=this.idBlock.toBER(t);if(r.write(s),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(t,r),r.write(new ArrayBuffer(2));else{const i=this.valueBlock.toBER(t);this.lenBlock.length=i.byteLength;const o=this.lenBlock.toBER(t);r.write(o),r.write(i)}return e?Qr:r.final()}toJSON(){const t={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(t="ascii"){return t==="ascii"?this.onAsciiEncoding():it.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${it.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(t){if(this===t)return!0;if(!(t instanceof this.constructor))return!1;const e=this.toBER(),r=t.toBER();return $R(e,r)}}Kt.NAME="BaseBlock";function Mm(n){if(n instanceof ne.Constructed)for(const t of n.valueBlock.value)Mm(t)&&(n.lenBlock.isIndefiniteForm=!0);return!!n.lenBlock.isIndefiniteForm}class Nm extends Kt{constructor({value:t=Xo,...e}={},r){super(e,r),t&&this.fromString(t)}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}fromBER(t,e,r){const s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Nm.NAME="BaseStringBlock";class Lm extends zn(or){constructor({isHexOnly:t=!0,...e}={}){super(e),this.isHexOnly=t}}Lm.NAME="PrimitiveValueBlock";var Om;class Fm extends Kt{constructor(t={}){super(t,Lm),this.idBlock.isConstructed=!1}}Om=Fm;ne.Primitive=Om;Fm.NAME="PRIMITIVE";function zR(n,t){if(n instanceof t)return n;const e=new t;return e.idBlock=n.idBlock,e.lenBlock=n.lenBlock,e.warnings=n.warnings,e.valueBeforeDecodeView=n.valueBeforeDecodeView,e}function ch(n,t=0,e=n.length){const r=t;let s=new Kt({},or);const i=new Ii;if(!$n(i,n,t,e))return s.error=i.error,{offset:-1,result:s};if(!n.subarray(t,t+e).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(n,t,e);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(t=a,e-=s.idBlock.blockLength,a=s.lenBlock.fromBER(n,t,e),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(t=a,e-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=Kt;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=ne.EndOfContent;break;case 1:c=ne.Boolean;break;case 2:c=ne.Integer;break;case 3:c=ne.BitString;break;case 4:c=ne.OctetString;break;case 5:c=ne.Null;break;case 6:c=ne.ObjectIdentifier;break;case 10:c=ne.Enumerated;break;case 12:c=ne.Utf8String;break;case 13:c=ne.RelativeObjectIdentifier;break;case 14:c=ne.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=ne.Sequence;break;case 17:c=ne.Set;break;case 18:c=ne.NumericString;break;case 19:c=ne.PrintableString;break;case 20:c=ne.TeletexString;break;case 21:c=ne.VideotexString;break;case 22:c=ne.IA5String;break;case 23:c=ne.UTCTime;break;case 24:c=ne.GeneralizedTime;break;case 25:c=ne.GraphicString;break;case 26:c=ne.VisibleString;break;case 27:c=ne.GeneralString;break;case 28:c=ne.UniversalString;break;case 29:c=ne.CharacterString;break;case 30:c=ne.BmpString;break;case 31:c=ne.DATE;break;case 32:c=ne.TimeOfDay;break;case 33:c=ne.DateTime;break;case 34:c=ne.Duration;break;default:{const l=s.idBlock.isConstructed?new ne.Constructed:new ne.Primitive;l.idBlock=s.idBlock,l.lenBlock=s.lenBlock,l.warnings=s.warnings,s=l}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?ne.Constructed:ne.Primitive}return s=zR(s,c),a=s.fromBER(n,t,s.lenBlock.isIndefiniteForm?e:s.lenBlock.length),s.valueBeforeDecodeView=n.subarray(r,r+s.blockLength),{offset:a,result:s}}function od(n){if(!n.byteLength){const t=new Kt({},or);return t.error="Input buffer has zero length",{offset:-1,result:t}}return ch(Ve.toUint8Array(n).slice(),0,n.byteLength)}function VR(n,t){return n?1:t}class ps extends or{constructor({value:t=[],isIndefiniteForm:e=!1,...r}={}){super(r),this.value=t,this.isIndefiniteForm=e}fromBER(t,e,r){const s=Ve.toUint8Array(t);if(!$n(this,s,e,r))return-1;if(this.valueBeforeDecodeView=s.subarray(e,e+r),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),e;let i=e;for(;VR(this.isIndefiniteForm,r)>0;){const o=ch(s,i,r);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(i=o.offset,this.blockLength+=o.result.blockLength,r-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===Xa)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===Xa?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(t,e){const r=e||new A0;for(let s=0;s<this.value.length;s++)this.value[s].toBER(t,r);return e?Qr:r.final()}toJSON(){const t={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const e of this.value)t.value.push(e.toJSON());return t}}ps.NAME="ConstructedValueBlock";var Um;class Zo extends Kt{constructor(t={}){super(t,ps),this.idBlock.isConstructed=!0}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(t,e,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){const t=[];for(const r of this.valueBlock.value)t.push(r.toString("ascii").split(`
`).map(s=>`  ${s}`).join(`
`));const e=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return t.length?`${e} :
${t.join(`
`)}`:`${e} :`}}Um=Zo;ne.Constructed=Um;Zo.NAME="CONSTRUCTED";class $m extends or{fromBER(t,e,r){return e}toBER(t){return Qr}}$m.override="EndOfContentValueBlock";var zm;class Vm extends Kt{constructor(t={}){super(t,$m),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}zm=Vm;ne.EndOfContent=zm;Vm.NAME=Xa;var Hm;class du extends Kt{constructor(t={}){super(t,or),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t,e){const r=new ArrayBuffer(2);if(!t){const s=new Uint8Array(r);s[0]=5,s[1]=0}return e&&e.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}Hm=du;ne.Null=Hm;du.NAME="NULL";class qm extends zn(or){constructor({value:t,...e}={}){super(e),e.valueHex?this.valueHexView=Ve.toUint8Array(e.valueHex):this.valueHexView=new Uint8Array(1),t&&(this.value=t)}get value(){for(const t of this.valueHexView)if(t>0)return!0;return!1}set value(t){this.valueHexView[0]=t?255:0}fromBER(t,e,r){const s=Ve.toUint8Array(t);return $n(this,s,e,r)?(this.valueHexView=s.subarray(e,e+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,Cm.call(this),this.blockLength=r,e+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}qm.NAME="BooleanValueBlock";var Wm;let Km=class extends Kt{constructor(t={}){super(t,qm),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(t){this.valueBlock.value=t}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};Wm=Km;ne.Boolean=Wm;Km.NAME="BOOLEAN";class Gm extends zn(ps){constructor({isConstructed:t=!1,...e}={}){super(e),this.isConstructed=t}fromBER(t,e,r){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=ps.prototype.fromBER.call(this,t,e,r),s===-1)return s;for(let i=0;i<this.value.length;i++){const o=this.value[i].constructor.NAME;if(o===Xa){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==Pm)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(t,e,r),this.blockLength=r;return s}toBER(t,e){return this.isConstructed?ps.prototype.toBER.call(this,t,e):t?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}Gm.NAME="OctetStringValueBlock";var Qm;class cs extends Kt{constructor({idBlock:t={},lenBlock:e={},...r}={}){var s,i;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((i=r.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:r.isConstructed,...t},lenBlock:{...e,isIndefiniteForm:!!r.isIndefiniteForm},...r},Gm),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,r===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),e;if(!this.valueBlock.isConstructed){const i=(t instanceof ArrayBuffer?new Uint8Array(t):t).subarray(e,e+r);try{if(i.byteLength){const o=ch(i,0,i.byteLength);o.offset!==-1&&o.offset===r&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(t,e,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?Zo.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${it.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const t=[];for(const e of this.valueBlock.value)e instanceof cs&&t.push(e.valueBlock.valueHexView);return Ve.concat(t)}}Qm=cs;ne.OctetString=Qm;cs.NAME=Pm;class Ym extends zn(ps){constructor({unusedBits:t=0,isConstructed:e=!1,...r}={}){super(r),this.unusedBits=t,this.isConstructed=e,this.blockLength=this.valueHexView.byteLength}fromBER(t,e,r){if(!r)return e;let s=-1;if(this.isConstructed){if(s=ps.prototype.fromBER.call(this,t,e,r),s===-1)return s;for(const a of this.value){const c=a.constructor.NAME;if(c===Xa){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==Dm)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const l=a.valueBlock;if(this.unusedBits>0&&l.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=l.unusedBits}return s}const i=Ve.toUint8Array(t);if(!$n(this,i,e,r))return-1;const o=i.subarray(e,e+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=ch(a,0,a.byteLength);c.offset!==-1&&c.offset===r-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,e+r}toBER(t,e){if(this.isConstructed)return ps.prototype.toBER.call(this,t,e);if(t)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return Qr;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}Ym.NAME="BitStringValueBlock";var Xm;class Zm extends Kt{constructor({idBlock:t={},lenBlock:e={},...r}={}){var s,i;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((i=r.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:r.isConstructed,...t},lenBlock:{...e,isIndefiniteForm:!!r.isIndefiniteForm},...r},Ym),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Zo.prototype.onAsciiEncoding.call(this);{const t=[],e=this.valueBlock.valueHexView;for(const s of e)t.push(s.toString(2).padStart(8,"0"));const r=t.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}Xm=Zm;ne.BitString=Xm;Zm.NAME=Dm;var Jm;function HR(n,t){const e=new Uint8Array([0]),r=new Uint8Array(n),s=new Uint8Array(t);let i=r.slice(0);const o=i.length-1,a=s.slice(0),c=a.length-1;let l=0;const h=c<o?o:c;let d=0;for(let f=h;f>=0;f--,d++){switch(!0){case d<a.length:l=i[o-d]+a[c-d]+e[0];break;default:l=i[o-d]+e[0]}switch(e[0]=l/10,!0){case d>=i.length:i=P1(new Uint8Array([l%10]),i);break;default:i[o-d]=l%10}}return e[0]>0&&(i=P1(e,i)),i}function vp(n){if(n>=oa.length)for(let t=oa.length;t<=n;t++){const e=new Uint8Array([0]);let r=oa[t-1].slice(0);for(let s=r.length-1;s>=0;s--){const i=new Uint8Array([(r[s]<<1)+e[0]]);e[0]=i[0]/10,r[s]=i[0]%10}e[0]>0&&(r=P1(e,r)),oa.push(r)}return oa[n]}function qR(n,t){let e=0;const r=new Uint8Array(n),s=new Uint8Array(t),i=r.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1;let l,h=0;for(let d=c;d>=0;d--,h++)switch(l=i[o-h]-a[c-h]-e,!0){case l<0:e=1,i[o-h]=l+10;break;default:e=0,i[o-h]=l}if(e>0)for(let d=o-c+1;d>=0;d--,h++)if(l=i[o-h]-e,l<0)e=1,i[o-h]=l+10;else{e=0,i[o-h]=l;break}return i.slice()}class C0 extends zn(or){constructor({value:t,...e}={}){super(e),this._valueDec=0,e.valueHex&&this.setValueHex(),t!==void 0&&(this.valueDec=t)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=Cm.call(this)))}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this.valueHexView=new Uint8Array(UR(t))}get valueDec(){return this._valueDec}fromDER(t,e,r,s=0){const i=this.fromBER(t,e,r);if(i===-1)return i;const o=this.valueHexView;return o[0]===0&&(o[1]&128)!==0?this.valueHexView=o.subarray(1):s!==0&&o.length<s&&(s-o.length>1&&(s=o.length+1),this.valueHexView=o.subarray(s-o.length)),i}toDER(t=!1){const e=this.valueHexView;switch(!0){case(e[0]&128)!==0:{const r=new Uint8Array(this.valueHexView.length+1);r[0]=0,r.set(e,1),this.valueHexView=r}break;case(e[0]===0&&(e[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(t)}fromBER(t,e,r){const s=super.fromBER(t,e,r);return s===-1||this.setValueHex(),s}toBER(t){return t?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const t=this.valueHexView.length*8-1;let e=new Uint8Array(this.valueHexView.length*8/3),r=0,s;const i=this.valueHexView;let o="",a=!1;for(let c=i.byteLength-1;c>=0;c--){s=i[c];for(let l=0;l<8;l++){if((s&1)===1)switch(r){case t:e=qR(vp(r),e),o="-";break;default:e=HR(e,vp(r))}r++,s>>=1}}for(let c=0;c<e.length;c++)e[c]&&(a=!0),a&&(o+=bp.charAt(e[c]));return a===!1&&(o+=bp.charAt(0)),o}}Jm=C0;C0.NAME="IntegerValueBlock";Object.defineProperty(Jm.prototype,"valueHex",{set:function(n){this.valueHexView=new Uint8Array(n),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var jm;class fn extends Kt{constructor(t={}){super(t,C0),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return hu(),BigInt(this.valueBlock.toString())}static fromBigInt(t){hu();const e=BigInt(t),r=new A0,s=e.toString(16).replace(/^-/,""),i=new Uint8Array(it.FromHex(s));if(e<0){const a=new Uint8Array(i.length+(i[0]&128?1:0));a[0]|=128;const l=BigInt(`0x${it.ToHex(a)}`)+e,h=Ve.toUint8Array(it.FromHex(l.toString(16)));h[0]|=128,r.write(h)}else i[0]&128&&r.write(new Uint8Array([0])),r.write(i);return new fn({valueHex:r.final()})}convertToDER(){const t=new fn({valueHex:this.valueBlock.valueHexView});return t.valueBlock.toDER(),t}convertFromDER(){return new fn({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}jm=fn;ne.Integer=jm;fn.NAME="INTEGER";var e7;class t7 extends fn{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}e7=t7;ne.Enumerated=e7;t7.NAME="ENUMERATED";class D1 extends zn(or){constructor({valueDec:t=-1,isFirstSid:e=!1,...r}={}){super(r),this.valueDec=t,this.isFirstSid=e}fromBER(t,e,r){if(!r)return e;const s=Ve.toUint8Array(t);if(!$n(this,s,e,r))return-1;const i=s.subarray(e,e+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=i[a]&127,this.blockLength++,(i[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(i[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Uo(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}set valueBigInt(t){hu();let e=BigInt(t).toString(2);for(;e.length%7;)e="0"+e;const r=new Uint8Array(e.length/7);for(let s=0;s<r.length;s++)r[s]=parseInt(e.slice(s*7,s*7+7),2)+(s+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(t){if(this.isHexOnly){if(t)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}const e=yi(this.valueDec,7);if(e.byteLength===0)return this.error="Error during encoding SID value",Qr;const r=new Uint8Array(e.byteLength);if(!t){const s=new Uint8Array(e),i=e.byteLength-1;for(let o=0;o<i;o++)r[o]=s[o]|128;r[i]=s[i]}return r}toString(){let t="";if(this.isHexOnly)t=it.ToHex(this.valueHexView);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}D1.NAME="sidBlock";class r7 extends or{constructor({value:t=Xo,...e}={}){super(e),this.value=[],t&&this.fromString(t)}fromBER(t,e,r){let s=e;for(;r>0;){const i=new D1;if(s=i.fromBER(t,s,r),s===-1)return this.blockLength=0,this.error=i.error,s;this.value.length===0&&(i.isFirstSid=!0),this.blockLength+=i.blockLength,r-=i.blockLength,this.value.push(i)}return s}toBER(t){const e=[];for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(t);if(s.byteLength===0)return this.error=this.value[r].error,Qr;e.push(s)}return I0(e)}fromString(t){this.value=[];let e=0,r=0,s="",i=!1;do if(r=t.indexOf(".",e),r===-1?s=t.substring(e):s=t.substring(e,r),e=r+1,i){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(s,10);if(isNaN(c))return;o.valueDec=c+a,i=!1}else{const o=new D1;if(s>Number.MAX_SAFE_INTEGER){hu();const a=BigInt(s);o.valueBigInt=a}else if(o.valueDec=parseInt(s,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,i=!0),this.value.push(o)}while(r!==-1)}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(t=`${t}.`),e?(s=`{${s}}`,this.value[r].isFirstSid?t=`2.{${s} - 80}`:t+=s):t+=s}return t}toJSON(){const t={...super.toJSON(),value:this.toString(),sidArray:[]};for(let e=0;e<this.value.length;e++)t.sidArray.push(this.value[e].toJSON());return t}}r7.NAME="ObjectIdentifierValueBlock";var n7;class qs extends Kt{constructor(t={}){super(t,r7),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(t){this.valueBlock.fromString(t)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}n7=qs;ne.ObjectIdentifier=n7;qs.NAME="OBJECT IDENTIFIER";class R1 extends zn(Ii){constructor({valueDec:t=0,...e}={}){super(e),this.valueDec=t}fromBER(t,e,r){if(r===0)return e;const s=Ve.toUint8Array(t);if(!$n(this,s,e,r))return-1;const i=s.subarray(e,e+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=i[a]&127,this.blockLength++,(i[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(i[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Uo(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t){if(this.isHexOnly){if(t)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}const e=yi(this.valueDec,7);if(e.byteLength===0)return this.error="Error during encoding SID value",Qr;const r=new Uint8Array(e.byteLength);if(!t){const s=new Uint8Array(e),i=e.byteLength-1;for(let o=0;o<i;o++)r[o]=s[o]|128;r[i]=s[i]}return r.buffer}toString(){let t="";return this.isHexOnly?t=it.ToHex(this.valueHexView):t=this.valueDec.toString(),t}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}R1.NAME="relativeSidBlock";class s7 extends or{constructor({value:t=Xo,...e}={}){super(e),this.value=[],t&&this.fromString(t)}fromBER(t,e,r){let s=e;for(;r>0;){const i=new R1;if(s=i.fromBER(t,s,r),s===-1)return this.blockLength=0,this.error=i.error,s;this.blockLength+=i.blockLength,r-=i.blockLength,this.value.push(i)}return s}toBER(t,e){const r=[];for(let s=0;s<this.value.length;s++){const i=this.value[s].toBER(t);if(i.byteLength===0)return this.error=this.value[s].error,Qr;r.push(i)}return I0(r)}fromString(t){this.value=[];let e=0,r=0,s="";do{r=t.indexOf(".",e),r===-1?s=t.substring(e):s=t.substring(e,r),e=r+1;const i=new R1;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(r!==-1);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(t=`${t}.`),e&&(s=`{${s}}`),t+=s}return t}toJSON(){const t={...super.toJSON(),value:this.toString(),sidArray:[]};for(let e=0;e<this.value.length;e++)t.sidArray.push(this.value[e].toJSON());return t}}s7.NAME="RelativeObjectIdentifierValueBlock";var i7;class o7 extends Kt{constructor(t={}){super(t,s7),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(t){this.valueBlock.fromString(t)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}i7=o7;ne.RelativeObjectIdentifier=i7;o7.NAME="RelativeObjectIdentifier";var a7;class Mr extends Zo{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}a7=Mr;ne.Sequence=a7;Mr.NAME="SEQUENCE";var c7;let l7=class extends Zo{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};c7=l7;ne.Set=c7;l7.NAME="SET";class u7 extends zn(or){constructor({...t}={}){super(t),this.isHexOnly=!0,this.value=Xo}toJSON(){return{...super.toJSON(),value:this.value}}}u7.NAME="StringValueBlock";class h7 extends u7{}h7.NAME="SimpleStringValueBlock";class mr extends Nm{constructor({...t}={}){super(t,h7)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,Ve.toUint8Array(t))}fromString(t){const e=t.length,r=this.valueBlock.valueHexView=new Uint8Array(e);for(let s=0;s<e;s++)r[s]=t.charCodeAt(s);this.valueBlock.value=t}}mr.NAME="SIMPLE STRING";class d7 extends mr{fromBuffer(t){this.valueBlock.valueHexView=Ve.toUint8Array(t);try{this.valueBlock.value=it.ToUtf8String(t)}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`),this.valueBlock.value=it.ToBinary(t)}}fromString(t){this.valueBlock.valueHexView=new Uint8Array(it.FromUtf8String(t)),this.valueBlock.value=t}}d7.NAME="Utf8StringValueBlock";var f7;class Ai extends d7{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}f7=Ai;ne.Utf8String=f7;Ai.NAME="UTF8String";class g7 extends mr{fromBuffer(t){this.valueBlock.value=it.ToUtf16String(t),this.valueBlock.valueHexView=Ve.toUint8Array(t)}fromString(t){this.valueBlock.value=t,this.valueBlock.valueHexView=new Uint8Array(it.FromUtf16String(t))}}g7.NAME="BmpStringValueBlock";var p7;class m7 extends g7{constructor({...t}={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}p7=m7;ne.BmpString=p7;m7.NAME="BMPString";class y7 extends mr{fromBuffer(t){const e=ArrayBuffer.isView(t)?t.slice().buffer:t.slice(0),r=new Uint8Array(e);for(let s=0;s<r.length;s+=4)r[s]=r[s+3],r[s+1]=r[s+2],r[s+2]=0,r[s+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length,r=this.valueBlock.valueHexView=new Uint8Array(e*4);for(let s=0;s<e;s++){const i=yi(t.charCodeAt(s),8),o=new Uint8Array(i);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)r[s*4+c+a]=o[c]}this.valueBlock.value=t}}y7.NAME="UniversalStringValueBlock";var w7;class b7 extends y7{constructor({...t}={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}w7=b7;ne.UniversalString=w7;b7.NAME="UniversalString";var v7;class E7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}v7=E7;ne.NumericString=v7;E7.NAME="NumericString";var S7;class x7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}S7=x7;ne.PrintableString=S7;x7.NAME="PrintableString";var _7;class k7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}_7=k7;ne.TeletexString=_7;k7.NAME="TeletexString";var I7;class A7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}I7=A7;ne.VideotexString=I7;A7.NAME="VideotexString";var T7;class C7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}T7=C7;ne.IA5String=T7;C7.NAME="IA5String";var P7;class D7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}P7=D7;ne.GraphicString=P7;D7.NAME="GraphicString";var R7;class P0 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}R7=P0;ne.VisibleString=R7;P0.NAME="VisibleString";var B7;class M7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}B7=M7;ne.GeneralString=B7;M7.NAME="GeneralString";var N7;class L7 extends mr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}N7=L7;ne.CharacterString=N7;L7.NAME="CharacterString";var O7;class D0 extends P0{constructor({value:t,valueDate:e,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,t){this.fromString(t),this.valueBlock.valueHexView=new Uint8Array(t.length);for(let s=0;s<t.length;s++)this.valueBlock.valueHexView[s]=t.charCodeAt(s)}e&&(this.fromDate(e),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,Ve.toUint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(t);if(r===null){this.error="Wrong input string for conversion";return}const s=parseInt(r[1],10);s>=50?this.year=1900+s:this.year=2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(t="iso"){if(t==="iso"){const e=new Array(7);return e[0]=hr(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=hr(this.month,2),e[2]=hr(this.day,2),e[3]=hr(this.hour,2),e[4]=hr(this.minute,2),e[5]=hr(this.second,2),e[6]="Z",e.join("")}return super.toString(t)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}O7=D0;ne.UTCTime=O7;D0.NAME="UTCTime";var F7;class U7 extends D0{constructor(t={}){var e;super(t),(e=this.millisecond)!==null&&e!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(t){super.fromDate(t),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e=!1,r="",s="",i=0,o,a=0,c=0;if(t[t.length-1]==="Z")r=t.substring(0,t.length-1),e=!0;else{const d=new Number(t[t.length-1]);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");r=t}if(e){if(r.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(r.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let d=1,f=r.indexOf("+"),g="";if(f===-1&&(f=r.indexOf("-"),d=-1),f!==-1){if(g=r.substring(f+1),r=r.substring(0,f),g.length!==2&&g.length!==4)throw new Error("Wrong input string for conversion");let y=parseInt(g.substring(0,2),10);if(isNaN(y.valueOf()))throw new Error("Wrong input string for conversion");if(a=d*y,g.length===4){if(y=parseInt(g.substring(2,4),10),isNaN(y.valueOf()))throw new Error("Wrong input string for conversion");c=d*y}}}let l=r.indexOf(".");if(l===-1&&(l=r.indexOf(",")),l!==-1){const d=new Number(`0${r.substring(l)}`);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");i=d.valueOf(),s=r.substring(0,l)}else s=r;switch(!0){case s.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,l!==-1)throw new Error("Wrong input string for conversion");break;case s.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let d=60*i;this.minute=Math.floor(d),d=60*(d-this.minute),this.second=Math.floor(d),d=1e3*(d-this.second),this.millisecond=Math.floor(d)}break;case s.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let d=60*i;this.second=Math.floor(d),d=1e3*(d-this.second),this.millisecond=Math.floor(d)}break;case s.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){const d=1e3*i;this.millisecond=Math.floor(d)}break;default:throw new Error("Wrong input string for conversion")}const h=o.exec(s);if(h===null)throw new Error("Wrong input string for conversion");for(let d=1;d<h.length;d++)switch(d){case 1:this.year=parseInt(h[d],10);break;case 2:this.month=parseInt(h[d],10);break;case 3:this.day=parseInt(h[d],10);break;case 4:this.hour=parseInt(h[d],10)+a;break;case 5:this.minute=parseInt(h[d],10)+c;break;case 6:this.second=parseInt(h[d],10);break;default:throw new Error("Wrong input string for conversion")}if(e===!1){const d=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=d.getUTCFullYear(),this.month=d.getUTCMonth(),this.day=d.getUTCDay(),this.hour=d.getUTCHours(),this.minute=d.getUTCMinutes(),this.second=d.getUTCSeconds(),this.millisecond=d.getUTCMilliseconds()}}toString(t="iso"){if(t==="iso"){const e=[];return e.push(hr(this.year,4)),e.push(hr(this.month,2)),e.push(hr(this.day,2)),e.push(hr(this.hour,2)),e.push(hr(this.minute,2)),e.push(hr(this.second,2)),this.millisecond!==0&&(e.push("."),e.push(hr(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(t)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}F7=U7;ne.GeneralizedTime=F7;U7.NAME="GeneralizedTime";var $7;class z7 extends Ai{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}$7=z7;ne.DATE=$7;z7.NAME="DATE";var V7;class H7 extends Ai{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}V7=H7;ne.TimeOfDay=V7;H7.NAME="TimeOfDay";var q7;class W7 extends Ai{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}q7=W7;ne.DateTime=q7;W7.NAME="DateTime";var K7;class G7 extends Ai{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}K7=G7;ne.Duration=K7;G7.NAME="Duration";var Q7;class Y7 extends Ai{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}Q7=Y7;ne.TIME=Q7;Y7.NAME="TIME";const WR=16,B1=32,M1=1e4;async function R0(n,t){const r=await Im().encrypt(n,t);return kr.encode(r)}async function Ep(n,t,e){if(n.type==="RSA")return QR(n,t,e);if(n.type==="Ed25519")return KR(n,t,e);if(n.type==="secp256k1")return GR(n,t,e);throw new bi}async function KR(n,t,e="libp2p-key"){if(e==="libp2p-key")return R0(Wu(n),t);throw new W(`export format '${e}' is not supported`)}async function GR(n,t,e="libp2p-key"){if(e==="libp2p-key")return R0(Wu(n),t);throw new W("Export format is not supported")}async function QR(n,t,e="pkcs-8"){if(e==="pkcs-8")return YR(n,t);if(e==="libp2p-key")return R0(Wu(n),t);throw new W("Export format is not supported")}async function YR(n,t){const e=pn.get(),s=new Mr({value:[new fn({value:0}),new Mr({value:[new qs({value:"1.2.840.113549.1.1.1"}),new du]}),new cs({valueHex:n.raw})]}).toBER(),i=new Uint8Array(s,0,s.byteLength),o=Es(WR),a=await r5(Fu,t,o,{c:M1,dkLen:B1}),c=Es(16),l=await e.subtle.importKey("raw",a,"AES-CBC",!1,["encrypt"]),h=await e.subtle.encrypt({name:"AES-CBC",iv:c},l,i),d=new Mr({value:[new cs({valueHex:o}),new fn({value:M1}),new fn({value:B1}),new Mr({value:[new qs({value:"1.2.840.113549.2.11"}),new du]})]}),f=new Mr({value:[new qs({value:"1.2.840.113549.1.5.13"}),new Mr({value:[new Mr({value:[new qs({value:"1.2.840.113549.1.5.12"}),d]}),new Mr({value:[new qs({value:"2.16.840.1.101.3.4.1.42"}),new cs({valueHex:c})]})]})]}),y=new Mr({value:[f,new cs({valueHex:h})]}).toBER(),p=new Uint8Array(y,0,y.byteLength);return["-----BEGIN ENCRYPTED PRIVATE KEY-----",...Z(p,"base64pad").split(/(.{64})/).filter(Boolean),"-----END ENCRYPTED PRIVATE KEY-----"].join(`
`)}async function Sp(n,t){try{const e=await XR(n,t);return _S(e)}catch{}if(!n.includes("BEGIN"))throw new W("Encrypted key was not a libp2p-key or a PEM file");return ZR(n,t)}async function XR(n,t){const e=kr.decode(n);return Im().decrypt(e,t)}async function ZR(n,t){const e=pn.get();let r;if(n.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")){const i=Y(n.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","").replace("-----END ENCRYPTED PRIVATE KEY-----","").replace(/\n/g,"").trim(),"base64pad"),{result:o}=od(i),{iv:a,salt:c,iterations:l,keySize:h,cipherText:d}=JR(o),f=await r5(Fu,t,c,{c:l,dkLen:h}),g=await e.subtle.importKey("raw",f,"AES-CBC",!1,["decrypt"]),y=ka(await e.subtle.decrypt({name:"AES-CBC",iv:a},g,d)),{result:p}=od(y);r=xp(p)}else if(n.includes("-----BEGIN PRIVATE KEY-----")){const i=Y(n.replace("-----BEGIN PRIVATE KEY-----","").replace("-----END PRIVATE KEY-----","").replace(/\n/g,"").trim(),"base64pad"),{result:o}=od(i);r=xp(o)}else throw new W("Could not parse private key from PEM data");const s=kS(r);if(s.type!=="RSA")throw new W("Could not parse RSA private key from PEM data");return s}function JR(n){const t=n.valueBlock.value[0];if(t.valueBlock.value[0].toString()!=="OBJECT IDENTIFIER : 1.2.840.113549.1.5.13")throw new W("Only pkcs5PBES2 encrypted private keys are supported");const r=t.valueBlock.value[1].valueBlock.value[0];if(r.valueBlock.value[0].toString()!=="OBJECT IDENTIFIER : 1.2.840.113549.1.5.12")throw new W("Only pkcs5PBKDF2 key derivation functions are supported");const i=r.valueBlock.value[1],o=ka(i.valueBlock.value[0].getValue());let a=M1,c=B1;if(i.valueBlock.value.length===3)a=Number(i.valueBlock.value[1].toBigInt()),c=Number(i.valueBlock.value[2].toBigInt());else if(i.valueBlock.value.length===2)throw new W("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");const l=t.valueBlock.value[1].valueBlock.value[1],h=l.valueBlock.value[0].toString();if(h!=="OBJECT IDENTIFIER : 1.2.840.113549.3.7"){if(h!=="OBJECT IDENTIFIER : 1.3.14.3.2.7"){if(h!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2"){if(h!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22"){if(h!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42")throw new W("Only AES-CBC encryption schemes are supported")}}}}const d=ka(l.valueBlock.value[1].getValue());return{cipherText:ka(n.valueBlock.value[1].getValue()),salt:o,iterations:a,keySize:c,iv:d}}function xp(n){return ka(n.valueBlock.value[2].getValue())}function ka(n){return new Uint8Array(n,0,n.byteLength)}const jR="/pkcs8/",N1="/info/",aa=new WeakMap,Fs={minKeyLength:112/8,minSaltLength:128/8,minIterationCount:1e3},ad={dek:{keyLength:512/8,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function Ni(n){return n==null||typeof n!="string"?!1:n===IR(n.trim())&&n.length>0}async function Tt(){const e=Math.random()*800+200;await new Promise(r=>setTimeout(r,e))}function Us(n){return new Ge(jR+n)}function Li(n){return new Ge(N1+n)}async function eB(n){const t=Wu(n),e=await gt.digest(t);return ht.encode(e.bytes).substring(1)}var o4,a4;a4=Symbol.toStringTag,o4=Pt;class tB{constructor(t,e){u(this,"components");u(this,"init");u(this,"log");u(this,"self");u(this,a4,"@libp2p/keychain");u(this,o4,["@libp2p/keychain"]);var s,i,o,a,c,l,h,d,f,g;if(this.components=t,this.log=t.logger.forComponent("libp2p:keychain"),this.init=Gr(ad,e),this.self=e.selfKey??"self",this.init.pass!=null&&((s=this.init.pass)==null?void 0:s.length)<20)throw new Error("pass must be least 20 characters");if(((i=this.init.dek)==null?void 0:i.keyLength)!=null&&this.init.dek.keyLength<Fs.minKeyLength)throw new Error(`dek.keyLength must be least ${Fs.minKeyLength} bytes`);if(((a=(o=this.init.dek)==null?void 0:o.salt)==null?void 0:a.length)!=null&&this.init.dek.salt.length<Fs.minSaltLength)throw new Error(`dek.saltLength must be least ${Fs.minSaltLength} bytes`);if(((c=this.init.dek)==null?void 0:c.iterationCount)!=null&&this.init.dek.iterationCount<Fs.minIterationCount)throw new Error(`dek.iterationCount must be least ${Fs.minIterationCount}`);const r=this.init.pass!=null&&((l=this.init.dek)==null?void 0:l.salt)!=null?B2(this.init.pass,(h=this.init.dek)==null?void 0:h.salt,(d=this.init.dek)==null?void 0:d.iterationCount,(f=this.init.dek)==null?void 0:f.keyLength,(g=this.init.dek)==null?void 0:g.hash):"";aa.set(this,{dek:r})}static generateOptions(){const t=Object.assign({},ad),e=Math.ceil(Fs.minSaltLength/3)*3;return t.dek.salt=Z(Es(e),"base64"),t}static get options(){return ad}async findKeyByName(t){if(!Ni(t))throw await Tt(),new W(`Invalid key name '${t}'`);const e=Li(t);try{const r=await this.components.datastore.get(e);return JSON.parse(Z(r))}catch(r){throw await Tt(),this.log.error(r),new Nt(`Key '${t}' does not exist.`)}}async findKeyById(t){try{const e={prefix:N1};for await(const r of this.components.datastore.query(e)){const s=JSON.parse(Z(r.value));if(s.id===t)return s}throw new W(`Key with id '${t}' does not exist.`)}catch(e){throw await Tt(),e}}async importKey(t,e){if(!Ni(t))throw await Tt(),new W(`Invalid key name '${t}'`);if(e==null)throw await Tt(),new W("Key is required");const r=Us(t);if(await this.components.datastore.has(r))throw await Tt(),new W(`Key '${t}' already exists`);let i,o;try{i=await eB(e);const l=aa.get(this);if(l==null)throw new W("dek missing");const h=l.dek;o=await Ep(e,h,e.type==="RSA"?"pkcs-8":"libp2p-key")}catch(l){throw await Tt(),l}const a={name:t,id:i},c=this.components.datastore.batch();return c.put(r,Y(o)),c.put(Li(t),Y(JSON.stringify(a))),await c.commit(),a}async exportKey(t){if(!Ni(t))throw await Tt(),new W(`Invalid key name '${t}'`);const e=Us(t);try{const r=await this.components.datastore.get(e),s=Z(r),i=aa.get(this);if(i==null)throw new W("dek missing");const o=i.dek;return await Sp(s,o)}catch(r){throw await Tt(),r}}async removeKey(t){if(!Ni(t)||t===this.self)throw await Tt(),new W(`Invalid key name '${t}'`);const e=Us(t),r=await this.findKeyByName(t),s=this.components.datastore.batch();return s.delete(e),s.delete(Li(t)),await s.commit(),r}async listKeys(){const t={prefix:N1},e=[];for await(const r of this.components.datastore.query(t))e.push(JSON.parse(Z(r.value)));return e}async renameKey(t,e){if(!Ni(t)||t===this.self)throw await Tt(),new W(`Invalid old key name '${t}'`);if(!Ni(e)||e===this.self)throw await Tt(),new W(`Invalid new key name '${e}'`);const r=Us(t),s=Us(e),i=Li(t),o=Li(e);if(await this.components.datastore.has(s))throw await Tt(),new W(`Key '${e}' already exists`);try{const c=await this.components.datastore.get(r),l=await this.components.datastore.get(i),h=JSON.parse(Z(l));h.name=e;const d=this.components.datastore.batch();return d.put(s,c),d.put(o,Y(JSON.stringify(h))),d.delete(r),d.delete(i),await d.commit(),h}catch(c){throw await Tt(),c}}async rotateKeychainPass(t,e){var a,c,l,h;if(typeof t!="string")throw await Tt(),new W(`Invalid old pass type '${typeof t}'`);if(typeof e!="string")throw await Tt(),new W(`Invalid new pass type '${typeof e}'`);if(e.length<20)throw await Tt(),new W(`Invalid pass length ${e.length}`);this.log("recreating keychain");const r=aa.get(this);if(r==null)throw new W("dek missing");const s=r.dek;this.init.pass=e;const i=e!=null&&((a=this.init.dek)==null?void 0:a.salt)!=null?B2(e,this.init.dek.salt,(c=this.init.dek)==null?void 0:c.iterationCount,(l=this.init.dek)==null?void 0:l.keyLength,(h=this.init.dek)==null?void 0:h.hash):"";aa.set(this,{dek:i});const o=await this.listKeys();for(const d of o){const f=await this.components.datastore.get(Us(d.name)),g=Z(f),y=await Sp(g,s),p=i.toString(),w=await Ep(y,p,y.type==="RSA"?"pkcs-8":"libp2p-key"),v=this.components.datastore.batch(),x={name:d.name,id:d.id};v.put(Us(d.name),Y(w)),v.put(Li(d.name),Y(JSON.stringify(x))),await v.commit()}this.log("keychain reconstructed")}}function X7(n={}){return t=>new tB(t,n)}class Z7{constructor(t={}){u(this,"memoryStorage");u(this,"points");u(this,"duration");u(this,"blockDuration");u(this,"execEvenly");u(this,"execEvenlyMinDelayMs");u(this,"keyPrefix");this.points=t.points??4,this.duration=t.duration??1,this.blockDuration=t.blockDuration??0,this.execEvenly=t.execEvenly??!1,this.execEvenlyMinDelayMs=t.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=t.keyPrefix??"rlflx",this.memoryStorage=new rB}async consume(t,e=1,r={}){const s=this.getKey(t),i=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(s,e,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+e&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Uy("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await mm(a)}return o}penalty(t,e=1,r={}){const s=this.getKey(t),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(t,e=1,r={}){const s=this.getKey(t),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,-e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(t,e){const r=e*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(t),s,e),{remainingPoints:0,msBeforeNext:r===0?-1:r,consumedPoints:s,isFirstInDuration:!1}}set(t,e,r=0){const s=(r>=0?r:this.duration)*1e3;return this.memoryStorage.set(this.getKey(t),e,r),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:e,isFirstInDuration:!1}}get(t){const e=this.memoryStorage.get(this.getKey(t));return e!=null&&(e.remainingPoints=Math.max(this.points-e.consumedPoints,0)),e}delete(t){this.memoryStorage.delete(this.getKey(t))}_getKeySecDuration(t){return(t==null?void 0:t.customDuration)!=null&&t.customDuration>=0?t.customDuration:this.duration}getKey(t){return this.keyPrefix.length>0?`${this.keyPrefix}:${t}`:t}parseKey(t){return t.substring(this.keyPrefix.length)}}class rB{constructor(){u(this,"storage");this.storage=new Map}incrby(t,e,r){const s=this.storage.get(t);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=e,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(t,e,r)}return this.set(t,e,r)}set(t,e,r){const s=r*1e3,i=this.storage.get(t);i!=null&&clearTimeout(i.timeoutId);const o={value:e,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(t,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(t)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(t){const e=this.storage.get(t);if(e!=null)return{remainingPoints:0,msBeforeNext:e.expiresAt!=null?e.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:e.value,isFirstInDuration:!1}}delete(t){const e=this.storage.get(t);return e!=null?(e.timeoutId!=null&&clearTimeout(e.timeoutId),this.storage.delete(t),!0):!1}}var Ae;(function(n){n[n.NEW_STREAM=0]="NEW_STREAM",n[n.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",n[n.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",n[n.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",n[n.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",n[n.RESET_RECEIVER=5]="RESET_RECEIVER",n[n.RESET_INITIATOR=6]="RESET_INITIATOR"})(Ae||(Ae={}));const B0=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),_p=Object.freeze({NEW_STREAM:Ae.NEW_STREAM,MESSAGE:Ae.MESSAGE_INITIATOR,CLOSE:Ae.CLOSE_INITIATOR,RESET:Ae.RESET_INITIATOR}),nB=Object.freeze({MESSAGE:Ae.MESSAGE_RECEIVER,CLOSE:Ae.CLOSE_RECEIVER,RESET:Ae.RESET_RECEIVER}),J7=1<<20,sB=4<<20;class iB{constructor(t=J7,e=sB){u(this,"_buffer");u(this,"_headerInfo");u(this,"_maxMessageSize");u(this,"_maxUnprocessedMessageQueueSize");this._buffer=new ye,this._headerInfo=null,this._maxMessageSize=t,this._maxUnprocessedMessageQueueSize=e}write(t){if(t==null||t.length===0)return[];if(this._buffer.append(t),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw new We("Unprocessed message queue size too large!");const e=[];for(;this._buffer.length!==0;){if(this._headerInfo==null)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(l){if(l.name==="InvalidMessageError")throw l;break}const{id:r,type:s,length:i,offset:o}=this._headerInfo;if(this._buffer.length-o<i)break;const c={id:r,type:s};(s===Ae.NEW_STREAM||s===Ae.MESSAGE_INITIATOR||s===Ae.MESSAGE_RECEIVER)&&(c.data=this._buffer.sublist(o,o+i)),e.push(c),this._buffer.consume(o+i),this._headerInfo=null}return e}_decodeHeader(t){const{value:e,offset:r}=Ip(t),{value:s,offset:i}=Ip(t,r),o=e&7;if(B0[o]==null)throw new Error(`Invalid type received: ${o}`);if(s>this._maxMessageSize)throw new We("Message size too large");return{id:e>>3,type:o,offset:r+i,length:s}}}const oB=128,kp=127;function Ip(n,t=0){let e=0,r=0,s=t,i;const o=n.length;do{if(s>=o||r>49)throw t=0,new RangeError("Could not decode varint");i=n.get(s++),e+=r<28?(i&kp)<<r:(i&kp)*Math.pow(2,r),r+=7}while(i>=oB);return t=s-t,{value:e,offset:t}}const cd=10*1024;class aB{constructor(){u(this,"_pool");u(this,"_poolOffset");this._pool=sr(cd),this._poolOffset=0}write(t,e){const r=this._pool;let s=this._poolOffset;Lt(t.id<<3|t.type,r,s),s+=$e(t.id<<3|t.type),(t.type===Ae.NEW_STREAM||t.type===Ae.MESSAGE_INITIATOR||t.type===Ae.MESSAGE_RECEIVER)&&t.data!=null?(Lt(t.data.length,r,s),s+=$e(t.data.length)):(Lt(0,r,s),s+=$e(0));const i=r.subarray(this._poolOffset,s);cd-s<100?(this._pool=sr(cd),this._poolOffset=0):this._poolOffset=s,e.append(i),(t.type===Ae.NEW_STREAM||t.type===Ae.MESSAGE_INITIATOR||t.type===Ae.MESSAGE_RECEIVER)&&t.data!=null&&e.append(t.data)}}const cB=new aB;async function*lB(n){for await(const t of n){const e=new ye;cB.write(t,e),yield e}}class uB extends Error{constructor(t="Stream input buffer error"){super(t),this.name="StreamInputBufferError"}}class hB extends v0{constructor(e){super(e);u(this,"name");u(this,"streamId");u(this,"send");u(this,"types");u(this,"maxDataSize");this.types=e.direction==="outbound"?_p:nB,this.send=e.send,this.name=e.name,this.streamId=e.streamId,this.maxDataSize=e.maxDataSize}async sendNewStream(){await this.send({id:this.streamId,type:_p.NEW_STREAM,data:new ye(Y(this.name))})}async sendData(e){for(e=e.sublist();e.byteLength>0;){const r=Math.min(e.byteLength,this.maxDataSize);await this.send({id:this.streamId,type:this.types.MESSAGE,data:e.sublist(0,r)}),e.consume(r)}}async sendReset(){await this.send({id:this.streamId,type:this.types.RESET})}async sendCloseWrite(){await this.send({id:this.streamId,type:this.types.CLOSE})}async sendCloseRead(){}}function dB(n){const{id:t,name:e,send:r,onEnd:s,type:i="initiator",maxMsgSize:o=J7}=n;return new hB({id:i==="initiator"?`i${t}`:`r${t}`,streamId:t,name:`${e??t}`,direction:i==="initiator"?"outbound":"inbound",maxDataSize:o,onEnd:s,send:r,log:n.logger.forComponent(`libp2p:mplex:stream:${i}:${t}`)})}const fB=1024,gB=1024,pB=1024*1024*4,mB=5,yB=500;function Ap(n){const t={...n,type:`${B0[n.type]} (${n.type})`};return n.type===Ae.NEW_STREAM&&(t.data=Z(n.data instanceof Uint8Array?n.data:n.data.subarray())),(n.type===Ae.MESSAGE_INITIATOR||n.type===Ae.MESSAGE_RECEIVER)&&(t.data=Z(n.data instanceof Uint8Array?n.data:n.data.subarray(),"base16")),t}class wB{constructor(t,e){u(this,"protocol","/mplex/6.7.0");u(this,"sink");u(this,"source");u(this,"log");u(this,"_streamId");u(this,"_streams");u(this,"_init");u(this,"_source");u(this,"closeController");u(this,"rateLimiter");u(this,"closeTimeout");u(this,"logger");e=e??{},this.log=t.logger.forComponent("libp2p:mplex"),this.logger=t.logger,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=e,this.closeTimeout=e.closeTimeout??yB,this.sink=this._createSink(),this._source=gn({objectMode:!0,onEnd:()=>{for(const r of this._streams.initiators.values())r.destroy();for(const r of this._streams.receivers.values())r.destroy()}}),this.source=It(this._source,r=>lB(r)),this.closeController=new AbortController,this.rateLimiter=new Z7({points:e.disconnectThreshold??mB,duration:1})}get streams(){const t=[];for(const e of this._streams.initiators.values())t.push(e);for(const e of this._streams.receivers.values())t.push(e);return t}newStream(t){if(this.closeController.signal.aborted)throw new $s("Muxer already closed");const e=this._streamId++;t=t==null?e.toString():t.toString();const r=this._streams.initiators;return this._newStream({id:e,name:t,type:"initiator",registry:r})}async close(t){if(this.closeController.signal.aborted)return;const e=(t==null?void 0:t.signal)??AbortSignal.timeout(this.closeTimeout);try{await Promise.all(this.streams.map(async r=>r.close({signal:e}))),this._source.end(),await this._source.onEmpty({signal:e}),this.closeController.abort()}catch(r){this.abort(r)}}abort(t){this.closeController.signal.aborted||(this.streams.forEach(e=>{e.abort(t)}),this.closeController.abort(t))}_newReceiverStream(t){const{id:e,name:r}=t,s=this._streams.receivers;return this._newStream({id:e,name:r,type:"receiver",registry:s})}_newStream(t){const{id:e,name:r,type:s,registry:i}=t;if(this.log("new %s stream %s",s,e),s==="initiator"&&this._streams.initiators.size===(this._init.maxOutboundStreams??gB))throw new Du("Too many outbound streams open");if(i.has(e))throw new Error(`${s} stream ${e} already exists!`);const c=dB({id:e,name:r,send:async l=>{this.log.enabled&&this.log.trace("%s stream %s send",s,e,Ap(l)),this._source.push(l)},type:s,onEnd:()=>{this.log("%s stream with id %s and protocol %s ended",s,e,c.protocol),i.delete(e),this._init.onStreamEnd!=null&&this._init.onStreamEnd(c)},maxMsgSize:this._init.maxMsgSize,logger:this.logger});return i.set(e,c),c}_createSink(){return async e=>{const r=()=>{J8(e,this.log)};this.closeController.signal.addEventListener("abort",r);try{const s=new iB(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const i of e)for(const o of s.write(i))await this._handleIncoming(o);this._source.end()}catch(s){this.log("error in sink",s),this._source.end(s)}finally{this.closeController.signal.removeEventListener("abort",r)}}}async _handleIncoming(t){const{id:e,type:r}=t;if(this.log.enabled&&this.log.trace("incoming message",Ap(t)),t.type===Ae.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??fB)){this.log("too many inbound streams open"),this._source.push({id:e,type:Ae.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),this.abort(new Error("Too many open streams"));return}return}const a=this._newReceiverStream({id:e,name:Z(t.data instanceof Uint8Array?t.data:t.data.subarray())});this._init.onIncomingStream!=null&&this._init.onIncomingStream(a);return}const i=((r&1)===1?this._streams.initiators:this._streams.receivers).get(e);if(i==null){this.log("missing stream %s for message type %s",e,B0[r]);try{await this.rateLimiter.consume("missing-stream",1)}catch{this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection"),this.abort(new Error("Too many messages for missing streams"));return}return}const o=this._init.maxStreamBufferSize??pB;try{switch(r){case Ae.MESSAGE_INITIATOR:case Ae.MESSAGE_RECEIVER:if(i.sourceReadableLength()>o)throw this._source.push({id:t.id,type:r===Ae.MESSAGE_INITIATOR?Ae.RESET_RECEIVER:Ae.RESET_INITIATOR}),new uB("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");i.sourcePush(t.data);break;case Ae.CLOSE_INITIATOR:case Ae.CLOSE_RECEIVER:i.remoteCloseWrite();break;case Ae.RESET_INITIATOR:case Ae.RESET_RECEIVER:i.reset();break;default:this.log("unknown message type %s",r)}}catch(a){this.log.error("error while processing message",a),i.abort(a)}}}var c4,l4;l4=Symbol.toStringTag,c4=Pt;class bB{constructor(t,e={}){u(this,"protocol","/mplex/6.7.0");u(this,"_init");u(this,"components");u(this,l4,"@libp2p/mplex");u(this,c4,["@libp2p/stream-multiplexing"]);this.components=t,this._init=e}createStreamMuxer(t={}){return new wB(this.components,{...t,...this._init})}}function j7(n={}){return t=>new bB(t,n)}const ld=32,vB="1.0.0",EB="ping",SB="ipfs",xB=1e4,_B=2,kB=1;var u4;u4=Symbol.toStringTag;class IB{constructor(t,e={}){u(this,"protocol");u(this,"components");u(this,"started");u(this,"timeout");u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"runOnLimitedConnection");u(this,"log");u(this,u4,"@libp2p/ping");this.components=t,this.log=t.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${e.protocolPrefix??SB}/${EB}/${vB}`,this.timeout=e.timeout??xB,this.maxInboundStreams=e.maxInboundStreams??_B,this.maxOutboundStreams=e.maxOutboundStreams??kB,this.runOnLimitedConnection=e.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(t){this.log("incoming ping from %p",t.connection.remotePeer);const{stream:e}=t,r=Date.now(),s=Xl(e);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{e==null||e.abort(new Pu("ping timeout"))});const a=await s.read(ld,{signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&e.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",t.connection.remotePeer,o),e==null||e.abort(o))}).finally(()=>{const o=Date.now()-r;this.log("incoming ping from %p complete in %dms",t.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);e.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",t.connection.remotePeer,c),e==null||e.abort(c)})})}async ping(t,e={}){this.log("pinging %p",t);const r=Date.now(),s=Es(ld),i=await this.components.connectionManager.openConnection(t,e);let o;if(e.signal==null){const a=AbortSignal.timeout(this.timeout);e={...e,signal:a}}try{o=await i.newStream(this.protocol,{...e,runOnLimitedConnection:this.runOnLimitedConnection});const a=Xl(o),[,c]=await Promise.all([a.write(s,e),a.read(ld,e)]),l=Date.now()-r;if(!_e(s,c.subarray()))throw new Y4(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",i.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o==null||o.abort(a),a}finally{o!=null&&await o.close(e)}}}function AB(n={}){return t=>new IB(t,n)}var Qt;(function(n){(function(r){r.FIN="FIN",r.STOP_SENDING="STOP_SENDING",r.RESET="RESET",r.FIN_ACK="FIN_ACK"})(n.Flag||(n.Flag={}));let t;(function(r){r[r.FIN=0]="FIN",r[r.STOP_SENDING=1]="STOP_SENDING",r[r.RESET=2]="RESET",r[r.FIN_ACK=3]="FIN_ACK"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.Flag||(n.Flag={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.flag!=null&&(s.uint32(8),n.Flag.codec().encode(r.flag,s)),r.message!=null&&(s.uint32(18),s.bytes(r.message)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.flag=n.Flag.codec().decode(r);break}case 2:{o.message=r.bytes();break}default:{r.skipType(c&7);break}}}return o})),e),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>ue(r,n.codec(),s)})(Qt||(Qt={}));const TB=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"],Tp=Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"),CB="libp2p+webrtc+v1/",PB=466,DB=2*1024*1024,RB=30*1e3,lh=16*1024;function BB(n=lh){const t=$e(n-$e(n)),e=1+$e(Object.keys(Qt.Flag).length-1),r=1,s=n-t-e-r,i=$e(s);return t+e+r+i}const MB=BB(),NB=5e3,LB=5e3,OB=3e4,e9="/webrtc",L1="/webrtc-signaling/0.0.1";function FB(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var t9={exports:{}},yt=t9.exports={},nn,sn;function O1(){throw new Error("setTimeout has not been defined")}function F1(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?nn=setTimeout:nn=O1}catch{nn=O1}try{typeof clearTimeout=="function"?sn=clearTimeout:sn=F1}catch{sn=F1}})();function r9(n){if(nn===setTimeout)return setTimeout(n,0);if((nn===O1||!nn)&&setTimeout)return nn=setTimeout,setTimeout(n,0);try{return nn(n,0)}catch{try{return nn.call(null,n,0)}catch{return nn.call(this,n,0)}}}function UB(n){if(sn===clearTimeout)return clearTimeout(n);if((sn===F1||!sn)&&clearTimeout)return sn=clearTimeout,clearTimeout(n);try{return sn(n)}catch{try{return sn.call(null,n)}catch{return sn.call(this,n)}}}var Rn=[],so=!1,Qs,dl=-1;function $B(){!so||!Qs||(so=!1,Qs.length?Rn=Qs.concat(Rn):dl=-1,Rn.length&&n9())}function n9(){if(!so){var n=r9($B);so=!0;for(var t=Rn.length;t;){for(Qs=Rn,Rn=[];++dl<t;)Qs&&Qs[dl].run();dl=-1,t=Rn.length}Qs=null,so=!1,UB(n)}}yt.nextTick=function(n){var t=new Array(arguments.length-1);if(arguments.length>1)for(var e=1;e<arguments.length;e++)t[e-1]=arguments[e];Rn.push(new s9(n,t)),Rn.length===1&&!so&&r9(n9)};function s9(n,t){this.fun=n,this.array=t}s9.prototype.run=function(){this.fun.apply(null,this.array)};yt.title="browser";yt.browser=!0;yt.env={};yt.argv=[];yt.version="";yt.versions={};function Vn(){}yt.on=Vn;yt.addListener=Vn;yt.once=Vn;yt.off=Vn;yt.removeListener=Vn;yt.removeAllListeners=Vn;yt.emit=Vn;yt.prependListener=Vn;yt.prependOnceListener=Vn;yt.listeners=function(n){return[]};yt.binding=function(n){throw new Error("process.binding is not supported")};yt.cwd=function(){return"/"};yt.chdir=function(n){throw new Error("process.chdir is not supported")};yt.umask=function(){return 0};var zB=t9.exports;const fl=FB(zB);var Cp=function(n,t,e){if(e||arguments.length===2)for(var r=0,s=t.length,i;r<s;r++)(i||!(r in t))&&(i||(i=Array.prototype.slice.call(t,0,r)),i[r]=t[r]);return n.concat(i||Array.prototype.slice.call(t))},VB=function(){function n(t,e,r){this.name=t,this.version=e,this.os=r,this.type="browser"}return n}(),HB=function(){function n(t){this.version=t,this.type="node",this.name="node",this.os=fl.platform}return n}(),qB=function(){function n(t,e,r,s){this.name=t,this.version=e,this.os=r,this.bot=s,this.type="bot-device"}return n}(),WB=function(){function n(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return n}(),KB=function(){function n(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return n}(),GB=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,QB=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Pp=3,YB=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",GB]],Dp=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function XB(n){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new KB:typeof navigator<"u"?JB(navigator.userAgent):eM()}function ZB(n){return n!==""&&YB.reduce(function(t,e){var r=e[0],s=e[1];if(t)return t;var i=s.exec(n);return!!i&&[r,i]},!1)}function JB(n){var t=ZB(n);if(!t)return null;var e=t[0],r=t[1];if(e==="searchbot")return new WB;var s=r[1]&&r[1].split(".").join("_").split("_").slice(0,3);s?s.length<Pp&&(s=Cp(Cp([],s,!0),tM(Pp-s.length),!0)):s=[];var i=s.join("."),o=jB(n),a=QB.exec(n);return a&&a[1]?new qB(e,i,o,a[1]):new VB(e,i,o)}function jB(n){for(var t=0,e=Dp.length;t<e;t++){var r=Dp[t],s=r[0],i=r[1],o=i.exec(n);if(o)return s}return null}function eM(){var n=typeof fl<"u"&&fl.version;return n?new HB(fl.version.slice(1)):null}function tM(n){for(var t=[],e=0;e<n;e++)t.push("0");return t}const Rp=XB(),M0=Rp!=null&&Rp.name==="firefox",i9=async function*(){},o9=async n=>{};function rM(n,t,e=OB,r){n.readyState==="open"&&Promise.resolve().then(async()=>{if(n.bufferedAmount>0){r.log("%s drain channel with %d buffered bytes",t,n.bufferedAmount);const s=me();let i=!1;n.bufferedAmountLowThreshold=0;const o=()=>{i||(r.log("%s drain channel closed before drain",t),s.resolve())};n.addEventListener("close",o,{once:!0}),n.addEventListener("bufferedamountlow",()=>{i=!0,n.removeEventListener("close",o),s.resolve()}),await lc(s.promise,{milliseconds:e})}}).then(async()=>{n.readyState==="open"&&n.close()}).catch(s=>{r.log.error("error closing outbound stream",s)})}async function Bp(n){return n=n??{},typeof n=="function"&&(n=await n()),n.iceServers=n.iceServers??TB.map(t=>({urls:[t]})),n}const nM=(n=32)=>CB+[...Array(n)].map(()=>Tp.at(Math.floor(Math.random()*Tp.length))).join("");class U1{constructor(t,e){u(this,"log");u(this,"peerConnection");u(this,"remoteAddr");u(this,"timeline");u(this,"metrics");u(this,"source",i9());u(this,"sink",o9);this.log=t.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=e.remoteAddr,this.timeline=e.timeline,this.peerConnection=e.peerConnection;const r=this.peerConnection,s=r.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",r.connectionState,"initial state",s),(r.connectionState==="disconnected"||r.connectionState==="failed"||r.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(t){var e;this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),(e=this.metrics)==null||e.increment({close:!0})}abort(t){var e;this.log.error("closing connection due to error",t),this.peerConnection.close(),this.timeline.close=Date.now(),(e=this.metrics)==null||e.increment({abort:!0})}}class sM extends v0{constructor(e){const r=e.onEnd;e.onEnd=i=>{this.log.trace("readable and writeable ends closed",this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await lc(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(o){this.log.error("error receiving FIN_ACK",o)}}).then(()=>{this.incomingData.end(),this.channel.close(),r==null||r(i)}).catch(o=>{this.log.error("error ending stream",o)})};super(e);u(this,"channel");u(this,"incomingData");u(this,"maxBufferedAmount");u(this,"bufferedAmountLowEventTimeout");u(this,"maxMessageSize");u(this,"receiveFinAck");u(this,"finAckTimeout");u(this,"openTimeout");u(this,"closeController");switch(this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=gn(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??RB,this.maxBufferedAmount=e.maxBufferedAmount??DB,this.maxMessageSize=(e.maxMessageSize??lh)-MB,this.receiveFinAck=me(),this.finAckTimeout=e.closeTimeout??NB,this.openTimeout=e.openTimeout??LB,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new xl("Unknown datachannel state")}this.channel.onopen=i=>{this.timeline.open=new Date().getTime()},this.channel.onclose=i=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(o=>{this.log.error("error closing stream after channel closed",o)})},this.channel.onerror=i=>{this.log.trace("received onerror event"),this.closeController.abort();const o=i.error;this.abort(o)},this.channel.onmessage=async i=>{const{data:o}=i;o===null||o.byteLength===0||this.incomingData.push(new Uint8Array(o,0,o.byteLength))};const s=this;Promise.resolve().then(async()=>{for await(const i of Eo(this.incomingData)){const o=s.processIncomingProtobuf(i);o!=null&&s.sourcePush(new ye(o))}}).catch(i=>{this.log.error("error processing incoming data channel messages",i)})}sendNewStream(){}async _sendMessage(e,r=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new xl(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const s=AbortSignal.timeout(this.openTimeout),i=Ne([this.closeController.signal,s]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await _r(this.channel,"open",i)}finally{i.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(r&&this.channel.bufferedAmount>this.maxBufferedAmount){const s=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),i=Ne([this.closeController.signal,s]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await _r(this.channel,"bufferedamountlow",i)}catch(o){throw s.aborted?new Pu(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):o}finally{i.clear()}}try{this.channel.send(e.subarray())}catch(s){this.log.error("error while sending message",s)}}async sendData(e){for(this.log.trace("-> will send %d bytes",e.byteLength),e=e.sublist();e.byteLength>0;){const r=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,r),i=Qt.encode({message:s}),o=vo.single(i);this.log.trace("-> sending message %s",this.channel.readyState),await this._sendMessage(o),this.log.trace("-> sent message %s",this.channel.readyState),e.consume(r)}this.log.trace("-> sent data %s",this.channel.readyState)}async sendReset(){try{await this._sendFlag(Qt.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Qt.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await fr(this.receiveFinAck.promise,e==null?void 0:e.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(s){this.log.error("failed to await FIN_ACK",s)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Qt.Flag.STOP_SENDING)}processIncomingProtobuf(e){const r=Qt.decode(e);if(r.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',r.flag,this.writeStatus,this.readStatus),r.flag===Qt.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Qt.Flag.FIN_ACK).catch(s=>{this.log.error("error sending FIN_ACK immediately",s)})),r.flag===Qt.Flag.RESET&&this.reset(),r.flag===Qt.Flag.STOP_SENDING&&this.remoteCloseRead(),r.flag===Qt.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return r.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',this.channel.readyState,e.toString()),!1;this.log.trace("sending flag %s",e.toString());const r=Qt.encode({flag:e}),s=vo.single(r);try{return await this._sendMessage(s,!1),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}}function fu(n){const{channel:t,direction:e}=n;return new sM({id:e==="inbound"?`i${t.id}`:`r${t.id}`,log:n.logger.forComponent(`libp2p:webrtc:stream:${e}:${t.id}`),...n})}class N0{constructor(t,e){u(this,"protocol");u(this,"peerConnection");u(this,"bufferedStreams",[]);u(this,"metrics");u(this,"dataChannelOptions");u(this,"components");u(this,"log");this.components=t,this.peerConnection=e.peerConnection,this.metrics=e.metrics,this.protocol=e.protocol??e9,this.dataChannelOptions=e.dataChannelOptions??{},this.log=t.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:r})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',r.id),r.label==="init"){this.log.trace("closing early init channel"),r.close();return}const s={},i=fu({channel:r,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:t.logger,...this.dataChannelOptions});s.stream=i,s.channel=r,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(t){return new iM(this.components,{...t,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}var po,gl;class iM{constructor(t,e){ve(this,po);u(this,"init");u(this,"streams");u(this,"protocol");u(this,"log");u(this,"peerConnection");u(this,"dataChannelOptions");u(this,"metrics");u(this,"logger");u(this,"source",i9());u(this,"sink",o9);this.init=e,this.log=t.logger.forComponent("libp2p:webrtc:muxer"),this.logger=t.logger,this.streams=e.streams.map(r=>r.stream),this.peerConnection=e.peerConnection,this.protocol=e.protocol??e9,this.metrics=e.metrics,this.dataChannelOptions=e.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:r})=>{var o,a;if(this.log.trace("incoming datachannel with channel id %d",r.id),r.label==="init"){this.log.trace("closing init channel"),r.close();return}const s=r.id,i=fu({channel:r,direction:"inbound",onEnd:()=>{ie(this,po,gl).call(this,i,r),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),(o=this.metrics)==null||o.increment({incoming_stream:!0}),(a=e==null?void 0:e.onIncomingStream)==null||a.call(e,i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(r=>{var s,i,o;r.onEnd=()=>{this.log("incoming early channel %s ended with state %s",r.channel.id,r.channel.readyState),ie(this,po,gl).call(this,r.stream,r.channel)},(s=this.metrics)==null||s.increment({incoming_stream:!0}),(o=(i=this.init)==null?void 0:i.onIncomingStream)==null||o.call(i,r.stream)})})}async close(t){try{await Promise.all(this.streams.map(async e=>e.close(t)))}catch(e){this.abort(e)}}abort(t){for(const e of this.streams)e.abort(t)}newStream(){var s;const t=this.peerConnection.createDataChannel(""),e=t.id;this.log.trace("opened outgoing datachannel with channel id %s",e);const r=fu({channel:t,direction:"outbound",onEnd:()=>{ie(this,po,gl).call(this,r,t),this.log("outgoing channel %s ended",e)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(r),(s=this.metrics)==null||s.increment({outgoing_stream:!0}),r}}po=new WeakSet,gl=function(t,e){var r,s,i;this.log.trace("stream %s %s %s onEnd",t.direction,t.id,t.protocol),rM(e,`${t.direction} ${t.id} ${t.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(o=>o.id!==t.id),(r=this.metrics)==null||r.increment({stream_end:!0}),(i=(s=this.init)==null?void 0:s.onStreamEnd)==null||i.call(s,t)};const a9=globalThis.RTCPeerConnection,c9=globalThis.RTCSessionDescription,oM=globalThis.RTCIceCandidate;class wc extends Error{constructor(t){super(`WebRTC transport error: ${t}`),this.name="WebRTCTransportError"}}class ls extends wc{constructor(t="SDP handshake failed"){super(t),this.name="SDPHandshakeFailedError"}}class aM extends wc{constructor(t,e){super(`Invalid fingerprint "${t}" within ${e}`),this.name="WebRTC/InvalidFingerprintError"}}class cM extends wc{constructor(t){super(`A method (${t}) was called though it has been intentionally left unimplemented.`),this.name="WebRTC/UnimplementedError"}}class lM extends wc{constructor(t){super(`unsupported hash algorithm code: ${t} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `),this.name="WebRTC/UnsupportedHashAlgorithmError"}}var Fr;(function(n){(function(r){r.SDP_OFFER="SDP_OFFER",r.SDP_ANSWER="SDP_ANSWER",r.ICE_CANDIDATE="ICE_CANDIDATE"})(n.Type||(n.Type={}));let t;(function(r){r[r.SDP_OFFER=0]="SDP_OFFER",r[r.SDP_ANSWER=1]="SDP_ANSWER",r[r.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.Type||(n.Type={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),r.type!=null&&(s.uint32(8),n.Type.codec().encode(r.type,s)),r.data!=null&&(s.uint32(18),s.string(r.data)),i.lengthDelimited!==!1&&s.ldelim()},(r,s,i={})=>{const o={},a=s==null?r.len:r.pos+s;for(;r.pos<a;){const c=r.uint32();switch(c>>>3){case 1:{o.type=n.Type.codec().decode(r);break}case 2:{o.data=r.string();break}default:{r.skipType(c&7);break}}}return o})),e),n.encode=r=>he(r,n.codec()),n.decode=(r,s)=>ue(r,n.codec(),s)})(Fr||(Fr={}));const l9=async(n,t,e)=>{var r,s,i,o;try{const a=me();for(uM(n,a);;){const c=await Promise.race([a.promise,t.read({signal:e.signal}).catch(()=>{})]);if(c==null){(r=e.signal)==null||r.throwIfAborted();break}if(c.type!==Fr.Type.ICE_CANDIDATE)throw new We("ICE candidate message expected");const l=JSON.parse(c.data??"null");if(l===""||l===null){(s=e.onProgress)==null||s.call(e,new se("webrtc:end-of-ice-candidates")),e.log.trace("end-of-candidates received");continue}const h=new oM(l);e.log.trace("%s received new ICE candidate %o",e.direction,l);try{(i=e.onProgress)==null||i.call(e,new se("webrtc:add-ice-candidate",h.candidate)),await n.addIceCandidate(h)}catch(d){e.log.error("%s bad candidate received",e.direction,l,d)}}}catch(a){if(e.log.error("%s error parsing ICE candidate",e.direction,a),((o=e.signal)==null?void 0:o.aborted)===!0&&L0(n)!=="connected")throw a}};function L0(n){return M0?n.iceConnectionState:n.connectionState}function uM(n,t){n[M0?"oniceconnectionstatechange":"onconnectionstatechange"]=e=>{switch(L0(n)){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new cf("RTCPeerConnection was closed"));break}}}async function hM({rtcConfiguration:n,dataChannel:t,signal:e,metrics:r,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:h}=gM(s);r==null||r.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",h);const d=h.getPeerId();if(d==null)throw new W("Relay peer was missing");const f=i.getConnections(ut(d));let g,y=!1;f.length===0?(l==null||l(new se("webrtc:dial-relay")),g=await o.dial(h,{signal:e,onProgress:l}),y=!0):(l==null||l(new se("webrtc:reuse-relay-connection")),g=f[0]);try{l==null||l(new se("webrtc:open-signaling-stream"));const p=await g.newStream(L1,{signal:e,runOnLimitedConnection:!0}),w=Wt(p).pb(Fr),v=new a9(n),x=new N0({logger:c},{peerConnection:v,dataChannelOptions:t});try{const S=v.createDataChannel("init");v.onicecandidate=({candidate:C})=>{const T=JSON.stringify((C==null?void 0:C.toJSON())??null);a.trace("initiator sending ICE candidate %o",C),w.write({type:Fr.Type.ICE_CANDIDATE,data:T},{signal:e}).catch(k=>{a.error("error sending ICE candidate",k)})},v.onicecandidateerror=C=>{a.error("initiator ICE candidate error",C)};const I=await v.createOffer().catch(C=>{throw a.error("could not execute createOffer",C),new ls("Failed to set createOffer")});a.trace("initiator send SDP offer %s",I.sdp),l==null||l(new se("webrtc:send-sdp-offer")),await w.write({type:Fr.Type.SDP_OFFER,data:I.sdp},{signal:e}),await v.setLocalDescription(I).catch(C=>{throw a.error("could not execute setLocalDescription",C),new ls("Failed to set localDescription")}),l==null||l(new se("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const P=await w.read({signal:e});if(P.type!==Fr.Type.SDP_ANSWER)throw new ls("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",P.data);const A=new c9({type:"answer",sdp:P.data});return await v.setRemoteDescription(A).catch(C=>{throw a.error("could not execute setRemoteDescription",C),new ls("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l==null||l(new se("webrtc:read-ice-candidates")),await l9(v,w,{direction:"initiator",signal:e,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),S.close(),l==null||l(new se("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await p.close({signal:e}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:v,muxerFactory:x}}catch(S){throw a.error("outgoing signaling error",S),v.close(),p.abort(S),S}finally{v.onicecandidate=null,v.onicecandidateerror=null}}finally{if(y)try{await g.close({signal:e})}catch(p){g.abort(p)}}}const Mp=Qe(a8.matchers[0],Se("p2p-circuit"));class O0 extends Et{constructor(e,r){super();u(this,"transportManager");u(this,"shutdownController");u(this,"events");this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=r.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(s=>Mp.exactMatch(s)).map(s=>s.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof O0)).map(e=>e.getAddrs().filter(r=>Mp.exactMatch(r)).map(r=>r.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function dM({peerConnection:n,stream:t,signal:e,connection:r,log:s}){s.trace("new inbound signaling stream");const i=Wt(t).pb(Fr);try{n.onicecandidate=({candidate:h})=>{const d=JSON.stringify((h==null?void 0:h.toJSON())??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:Fr.Type.ICE_CANDIDATE,data:d},{signal:e}).catch(f=>{s.error("error sending ICE candidate",f)})},s.trace("recipient read SDP offer");const a=await i.read({signal:e});if(a.type!==Fr.Type.SDP_OFFER)throw new ls(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new c9({type:"offer",sdp:a.data});await n.setRemoteDescription(c).catch(h=>{throw s.error("could not execute setRemoteDescription",h),new ls("Failed to set remoteDescription")});const l=await n.createAnswer().catch(h=>{throw s.error("could not execute createAnswer",h),new ls("Failed to create answer")});s.trace("recipient send SDP answer %s",l.sdp),await i.write({type:Fr.Type.SDP_ANSWER,data:l.sdp},{signal:e}),await n.setLocalDescription(l).catch(h=>{throw s.error("could not execute setLocalDescription",h),new ls("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await l9(n,i,{direction:"recipient",signal:e,log:s})}catch(a){if(L0(n)!=="connected")throw s.error("error while handling signaling stream from peer %a",r.remoteAddr,a),n.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",r.remoteAddr,a)}const o=fe(`/webrtc/p2p/${r.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}var h4,d4,f4,g4;g4=Au,f4=Symbol.toStringTag,d4=Pt,h4=ms;class fM{constructor(t,e={}){u(this,"components");u(this,"init");u(this,"log");u(this,"_started",!1);u(this,"metrics");u(this,"shutdownController");u(this,g4,!0);u(this,f4,"@libp2p/webrtc");u(this,d4,["@libp2p/transport"]);u(this,h4,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=t,this.init=e,this.log=t.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(L1,t=>{const e=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(t,e).catch(r=>{this.log.error("failed to handle incoming connect from %p",t.connection.remotePeer,r)}).finally(()=>{e.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(L1),this._started=!1}createListener(t){return new O0(this.components,{shutdownController:this.shutdownController})}listenFilter(t){return t.filter(c1.exactMatch)}dialFilter(t){return this.listenFilter(t)}async dial(t,e){var c;this.log.trace("dialing address: %a",t);const{remoteAddress:r,peerConnection:s,muxerFactory:i}=await hM({rtcConfiguration:await Bp(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:t,dataChannelOptions:this.init.dataChannel,signal:e.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:e.onProgress}),o=new U1(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:r,metrics:(c=this.metrics)==null?void 0:c.dialerEvents}),a=await e.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:e.onProgress,signal:e.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:t,stream:e},r){var o;const s=new a9(await Bp(this.init.rtcConfiguration)),i=new N0(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a}=await dM({peerConnection:s,connection:t,stream:e,signal:r,log:this.log});await e.close({signal:r});const c=new U1(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents});await this.components.upgrader.upgradeInbound(c,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:r}),this._closeOnShutdown(s,c)}catch(a){throw this.log.error("incoming signaling error",a),s.close(),e.abort(a),a}}_closeOnShutdown(t,e){const r=()=>{e.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",r),t.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",r)})}}function gM(n){const t=n.toString().split("/webrtc/");if(t.length!==2)throw new W("webrtc protocol was not present in multiaddr");if(!t[0].includes("/p2p-circuit"))throw new W("p2p-circuit protocol was not present in multiaddr");let e=fe(t[0]);const s=fe("/"+t[1]).getPeerId();if(s==null)throw new W("destination peer id was missing");const i=e.protos().pop();if(i===void 0)throw new W("invalid multiaddr");return i.name!=="p2p"&&(e=e.encapsulate(`/p2p/${s}`)),{baseAddr:e,peerId:ut(s)}}class pM extends Et{async listen(){throw new cM("WebRTCTransport.createListener")}getAddrs(){return[]}updateAnnounceAddrs(){}async close(){}}const u9=Object.values(Cl).map(n=>n.decoder).reduce((n,t)=>n.or(t)),mM=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function yM(n){var e;if(n==null)return;const t=n.match(mM);return(e=t==null?void 0:t.groups)==null?void 0:e.fingerprint}function h9(n){const e=n.stringTuples().filter(r=>r[0]===PB).map(r=>r[1])[0];if(e===void 0||e==="")throw new W(`Couldn't find a certhash component of multiaddr: ${n.toString()}`);return e}function wM(n){return bt(u9.decode(n))}function bM(n){const t=wM(h9(n)),e=EM(t.code),r=t.digest.reduce((i,o)=>i+o.toString(16).padStart(2,"0"),""),s=r.match(/.{1,2}/g);if(s==null)throw new aM(r,n.toString());return`${e} ${s.join(":").toUpperCase()}`}function vM(n){const t=n.split(":").map(s=>parseInt(s,16)),e=Uint8Array.from(t),r=On(gt.code,e);return fe(`/certhash/${Ef.encode(r.bytes)}`)}function EM(n){switch(n){case 17:return"sha-1";case 18:return"sha-256";case 19:return"sha-512";default:throw new lM(n)}}function SM(n,t){const{host:e,port:r,family:s}=n.toOptions(),i=bM(n);return{type:"answer",sdp:`v=0
o=- 0 0 IN IP${s} ${e}
s=-
t=0 0
a=ice-lite
m=application ${r} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${s} ${e}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${t}
a=ice-pwd:${t}
a=fingerprint:${i}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${lh}
a=candidate:1467250027 1 UDP 1467250027 ${e} ${r} typ host
a=end-of-candidates
`}}function xM(n,t){const{host:e,port:r,family:s}=n.toOptions();return{type:"offer",sdp:`v=0
o=- 0 0 IN IP${s} ${e}
s=-
c=IN IP${s} ${e}
t=0 0
a=ice-options:ice2,trickle
m=application ${r} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${t}
a=ice-pwd:${t}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${lh}
a=candidate:1467250027 1 UDP 1467250027 ${e} ${r} typ host
a=end-of-candidates
`}}function Np(n,t){if(n.sdp===void 0)throw new W("Can't munge a missing SDP");const e=n.sdp.includes(`\r
`)?`\r
`:`
`;return n.sdp=n.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+t+e).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+t+e),n}const ud=Y("libp2p-webrtc-noise:");function _M(n,t,e){const r=n.trim().toLowerCase().replaceAll(":",""),s=Y(r,"hex"),i=On(gt.code,s),o=u9.decode(h9(t)),a=ud.byteLength+i.bytes.byteLength+o.byteLength;return ft(e==="server"?[ud,o,i.bytes]:[ud,i.bytes,o],a)}const kM=M0?"iceconnectionstatechange":"connectionstatechange";async function IM(n,t,e){var f,g,y;const r=n.createDataChannel("",{negotiated:!0,id:0});if(e.role==="client"){e.log.trace("client creating local offer");const p=await n.createOffer();e.log.trace("client created local offer %s",p.sdp);const w=Np(p,t);e.log.trace("client setting local offer %s",w.sdp),await n.setLocalDescription(w);const v=SM(e.remoteAddr,t);e.log.trace("client setting server description %s",v.sdp),await n.setRemoteDescription(v)}else{const p=xM(e.remoteAddr,t);e.log.trace("server setting client %s %s",p.type,p.sdp),await n.setRemoteDescription(p),e.log.trace("server creating local answer");const w=await n.createAnswer();e.log.trace("server created local answer");const v=Np(w,t);e.log.trace("server setting local description %s",w.sdp),await n.setLocalDescription(v)}if(e.log.trace("%s wait for handshake channel to open",e.role),await _r(r,"open",e.signal),e.log.trace("%s handshake channel opened",e.role),e.role==="server"){const p=((f=n.remoteFingerprint())==null?void 0:f.value)??"";e.remoteAddr=e.remoteAddr.encapsulate(vM(p))}const s=yM((g=n.localDescription)==null?void 0:g.sdp);if(s==null)throw new wc("Could not get fingerprint from local description sdp");e.log.trace("%s performing noise handshake",e.role);const i=_M(s,e.remoteAddr,e.role),o=K8({prologueBytes:i})(e),a=fu({channel:r,direction:"inbound",logger:e.logger,...e.dataChannel??{}}),c={...a,sink:a.sink.bind(a),source:async function*(){for await(const p of a.source)for(const w of p)yield w}()},l=new U1(e,{peerConnection:n,remoteAddr:e.remoteAddr,timeline:{open:Date.now()},metrics:e.events});n.addEventListener(kM,()=>{switch(n.connectionState){case"failed":case"disconnected":case"closed":l.close().catch(p=>{e.log.error("error closing connection",p),l.abort(p)});break}}),(y=e.events)==null||y.increment({peer_connection:!0});const h=new N0(e,{peerConnection:n,metrics:e.events,dataChannelOptions:e.dataChannel});if(e.role==="client")return e.log.trace("%s secure inbound",e.role),await o.secureInbound(c,{remotePeer:e.remotePeerId,signal:e.signal}),e.log.trace("%s upgrade outbound",e.role),e.upgrader.upgradeOutbound(l,{skipProtection:!0,skipEncryption:!0,muxerFactory:h,signal:e.signal});e.log.trace("%s secure outbound",e.role);const d=await o.secureOutbound(c,{remotePeer:e.remotePeerId,signal:e.signal});l.remoteAddr=l.remoteAddr.encapsulate(`/p2p/${d.remotePeer}`),e.log.trace("%s upgrade inbound",e.role),await e.upgrader.upgradeInbound(l,{skipProtection:!0,skipEncryption:!0,muxerFactory:h,signal:e.signal})}async function AM(n,t,e,r){r==null&&(r=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256"}));const s=typeof e=="function"?await e():e;return new RTCPeerConnection({...s??{},certificates:[r]})}var p4,m4,y4;y4=Au,m4=Symbol.toStringTag,p4=Pt;class TM{constructor(t,e={}){u(this,"log");u(this,"metrics");u(this,"components");u(this,"init");u(this,y4,!0);u(this,m4,"@libp2p/webrtc-direct");u(this,p4,["@libp2p/transport"]);this.log=t.logger.forComponent("libp2p:webrtc-direct"),this.components=t,this.init=e,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total",{label:"event",help:"Total count of WebRTC-direct dial events by type"})})}async dial(t,e){const r=await this._connect(t,e);return this.log("dialing address: %a",t),r}createListener(t){return new pM(this.components,{...this.init,...t})}listenFilter(t){return t.filter(a1.exactMatch)}dialFilter(t){return this.listenFilter(t)}async _connect(t,e){var a;e.signal.throwIfAborted();let r;const s=t.getPeerId();s!=null&&(r=ut(s));const i=nM(),o=await AM("client",i,typeof this.init.rtcConfiguration=="function"?await this.init.rtcConfiguration():this.init.rtcConfiguration??{});try{return await fr(IM(o,i,{role:"client",log:this.log,logger:this.components.logger,metrics:this.components.metrics,events:(a=this.metrics)==null?void 0:a.dialerEvents,signal:e.signal,remoteAddr:t,dataChannel:this.init.dataChannel,upgrader:e.upgrader,peerId:this.components.peerId,remotePeerId:r,privateKey:this.components.privateKey}),e.signal)}catch(c){throw o.close(),c}}}function CM(n){return t=>new TM(t,n)}function d9(n){return t=>new fM(t,n)}const PM=async n=>{if(n.readyState>=2)throw new Error("socket closed");n.readyState!==1&&await new Promise((t,e)=>{function r(){n.removeEventListener("open",s),n.removeEventListener("error",i)}function s(){r(),t()}function i(o){r(),e(o.error??new Error(`connect ECONNREFUSED ${n.url}`))}n.addEventListener("open",s),n.addEventListener("error",i)})},DM=(n,t)=>(t=t??{},t.closeOnEnd=t.closeOnEnd!==!1,async r=>{for await(const s of r){try{await PM(n)}catch(i){if(i.message==="socket closed")break;throw i}if(n.readyState===n.CLOSING||n.readyState===n.CLOSED)break;n.send(s)}t.closeOnEnd!=null&&n.readyState<=1&&await new Promise((s,i)=>{n.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{n.close()})})});var Oi={},ca={},Lp;function RM(){if(Lp)return ca;Lp=1,Object.defineProperty(ca,"__esModule",{value:!0});class n{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(r){if(this.isStopped)return;const s={value:r,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const r of this.pullQueue)r.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(r){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(r);this.pullQueue.length=0}else{const s=Promise.reject(r);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:r=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class t{constructor(r,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new n;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=r({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return ca.EventIterator=t,ca.default=t,ca}var Op;function BM(){if(Op)return Oi;Op=1,Object.defineProperty(Oi,"__esModule",{value:!0});const n=RM();Oi.EventIterator=n.EventIterator;function t(e,r,s){return new n.EventIterator(({push:i})=>(this.addEventListener(e,i,r),()=>this.removeEventListener(e,i,r)),s)}return Oi.subscribe=t,Oi.default=n.EventIterator,Oi}var MM=BM();function Fp(n){var t;return n instanceof ArrayBuffer||((t=n==null?void 0:n.constructor)==null?void 0:t.name)==="ArrayBuffer"&&typeof(n==null?void 0:n.byteLength)=="number"}const NM=n=>{n.binaryType="arraybuffer";const t=async()=>{await new Promise((i,o)=>{if(r){i();return}if(s!=null){o(s);return}const a=h=>{n.removeEventListener("open",c),n.removeEventListener("error",l),h()},c=()=>{a(i)},l=h=>{a(()=>{o(h.error??new Error(`connect ECONNREFUSED ${n.url}`))})};n.addEventListener("open",c),n.addEventListener("error",l)})},e=async function*(){const i=new MM.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let f=null;typeof d.data=="string"&&(f=Y(d.data)),Fp(d.data)&&(f=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(f=d.data),f!=null&&o(f)},h=d=>{c(d.error??new Error("Socket error"))};return n.addEventListener("message",l),n.addEventListener("error",h),n.addEventListener("close",a),()=>{n.removeEventListener("message",l),n.removeEventListener("error",h),n.removeEventListener("close",a)}},{highWaterMark:1/0});await t();for await(const o of i)yield Fp(o)?new Uint8Array(o):o}();let r=n.readyState===1,s;return n.addEventListener("open",()=>{r=!0,s=null}),n.addEventListener("close",()=>{r=!1,s=null}),n.addEventListener("error",i=>{r||(s=i.error??new Error(`connect ECONNREFUSED ${n.url}`))}),Object.assign(e,{connected:t})},LM=(n,t)=>{t=t??{};const e=NM(n);let r=t.remoteAddress,s=t.remotePort;if(n.url!=null)try{const o=new URL(n.url);r=o.hostname,s=parseInt(o.port,10)}catch{}if(r==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:DM(n,t),source:e,connected:async()=>{await e.connected()},close:async()=>{(n.readyState===n.CONNECTING||n.readyState===n.OPEN)&&await new Promise(o=>{n.addEventListener("close",()=>{o()}),n.close()})},destroy:()=>{n.terminate!=null?n.terminate():n.close()},remoteAddress:r,remotePort:s,socket:n}},OM=WebSocket,FM={"http:":"ws:","https:":"wss:"},Up="ws:",UM=(n,t)=>{if(n.startsWith("//")&&(n=`${(t==null?void 0:t.protocol)??Up}${n}`),n.startsWith("/")&&t!=null){const r=t.protocol??Up,s=t.host,i=t.port!=null&&(s==null?void 0:s.endsWith(`:${t.port}`))!==!0?`:${t.port}`:"";n=`${r}//${s}${i}${n}`}const e=new URL(n);for(const[r,s]of Object.entries(FM))e.protocol===r&&(e.protocol=s);return e};function $M(n,t){const e=typeof window>"u"?void 0:window.location;t=t??{};const r=UM(n,e),s=new OM(r.toString(),t.websocket);return LM(s,t)}function zM(n){return n.filter(t=>Ql.exactMatch(t)||za.exactMatch(t))}function VM(){throw new Error("WebSocket Servers can not be created in the browser!")}const HM=500;function qM(n,t,e){const r=e.logger.forComponent("libp2p:websockets:maconn"),s=e.metrics,i=e.metricPrefix??"",o={log:r,async sink(a){try{await n.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&r.error(c)}},source:n.source,remoteAddr:t,timeline:{open:Date.now()},async close(a={}){var h,d;const c=Date.now();if(a.signal==null){const f=AbortSignal.timeout(HM);a={...a,signal:f}}const l=()=>{const{host:f,port:g}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s after %dms, destroying it manually",f,g,Date.now()-c),this.abort(new ii("Socket close timeout"))};(h=a.signal)==null||h.addEventListener("abort",l);try{await n.close()}catch(f){r.error("error closing WebSocket gracefully",f),this.abort(f)}finally{(d=a.signal)==null||d.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();r("timeout closing stream to %s:%s due to error",c,l,a),n.destroy(),o.timeline.close=Date.now(),s==null||s.increment({[`${i}error`]:!0})}};return n.socket.addEventListener("close",()=>{s==null||s.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}var w4,b4,v4;v4=Au,b4=Symbol.toStringTag,w4=Pt;class WM{constructor(t,e={}){u(this,"log");u(this,"init");u(this,"logger");u(this,"metrics");u(this,"components");u(this,v4,!0);u(this,b4,"@libp2p/websockets");u(this,w4,["@libp2p/transport"]);this.log=t.logger.forComponent("libp2p:websockets"),this.logger=t.logger,this.components=t,this.init=e,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}async dial(t,e){var o;this.log("dialing %s",t),e=e??{};const r=await this._connect(t,e),s=qM(r,t,{logger:this.logger,metrics:(o=this.metrics)==null?void 0:o.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await e.upgrader.upgradeOutbound(s,e);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(t,e){var o,a,c,l,h;(o=e==null?void 0:e.signal)==null||o.throwIfAborted();const r=t.toOptions();this.log("dialing %s:%s",r.host,r.port);const s=me(),i=$M(w8(t),this.init);i.socket.addEventListener("error",()=>{var f;const d=new cf(`Could not connect to ${t.toString()}`);this.log.error("connection error:",d),(f=this.metrics)==null||f.dialerEvents.increment({error:!0}),s.reject(d)});try{(a=e.onProgress)==null||a.call(e,new se("websockets:open-connection")),await fr(Promise.race([i.connected(),s.promise]),e.signal)}catch(d){throw(c=e.signal)!=null&&c.aborted&&((l=this.metrics)==null||l.dialerEvents.increment({abort:!0})),i.close().catch(f=>{this.log.error("error closing raw socket",f)}),d}return this.log("connected %s",t),(h=this.metrics)==null||h.dialerEvents.increment({connect:!0}),i}createListener(t){return VM({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...t})}listenFilter(t){var e,r;return t=Array.isArray(t)?t:[t],((e=this.init)==null?void 0:e.filter)!=null?(r=this.init)==null?void 0:r.filter(t):zM(t)}dialFilter(t){return this.listenFilter(t)}}function f9(n={}){return t=>new WM(t,n)}function KM(n,t){const e=t.map((r,s)=>({record:pc(r),index:s}));return e.sort((r,s)=>{const i=r.record.sequence,o=s.record.sequence;if(i>o)return-1;if(i<o)return 1;if(r.record.validityType===zr.ValidityType.EOL&&s.record.validityType===zr.ValidityType.EOL){const a=d1.fromString(r.record.validity).toDate(),c=d1.fromString(s.record.validity).toDate();if(a.getTime()>c.getTime())return-1;if(a.getTime()<c.getTime())return 1}return 0}),e[0].index}const g9="2.8.2",p9="js-libp2p";function m9(n,t){return`${n??p9}/${t??g9} browser/${globalThis.navigator.userAgent}`}const GM="5.3.0",QM="helia",YM={list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt","/dnsaddr/va1.bootstrap.libp2p.io/p2p/12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8","/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"]};function XM(n={}){const t=`${QM}/${GM} ${m9()}`;return{privateKey:n.privateKey,dns:n.dns,nodeInfo:{userAgent:t},addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[EP(),d9(),CM(),f9()],connectionEncrypters:[K8()],streamMuxers:[TC(),j7()],peerDiscovery:[lm(YM)],services:{autoNAT:qC(),dcutr:kP(),delegatedRouting:()=>UA("https://delegated-ipfs.dev",$A()),dht:yR({clientMode:!0,validators:{ipns:D8},selectors:{ipns:KM}}),identify:bm(),identifyPush:FP(),keychain:X7(n.keychain),ping:AB()}}}async function ZM(n,t={}){const e=t.selfKey??"self",r=X7(t)({datastore:n,logger:Ku()});let s;return await n.has(new Ge(`/pkcs8/${e}`))?s=await r.exportKey(e):(s=await G6(t.keyType??"Ed25519"),await r.importKey(e,s)),s}const JM=32,{code:jM}=ge("dnsaddr");class eN extends Error{constructor(t="Max recursive depth reached"){super(t),this.name="RecursionLimitError"}}const y9=async function(t,e={}){const r=e.maxRecursiveDepth??JM;if(r===0)throw new eN("Max recursive depth reached");const[,s]=t.stringTuples().find(([l])=>l===jM)??[],o=await((e==null?void 0:e.dns)??b5()).query(`_dnsaddr.${s}`,{signal:e==null?void 0:e.signal,types:[Ss.TXT]}),a=t.getPeerId(),c=[];for(const l of o.Answer){const h=l.data.replace(/["']/g,"").trim().split("=")[1];if(h==null||a!=null&&!h.includes(a))continue;const d=fe(h);if(h.startsWith("/dnsaddr")){const f=await d.resolve({...e,maxRecursiveDepth:r-1});c.push(...f.map(g=>g.toString()))}else c.push(d.toString())}return c},tN={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:n=>n},connectionManager:{resolvers:{dnsaddr:y9}},transportManager:{faultTolerance:Ca.FATAL_ALL}};async function rN(n){var e,r;const t=Gr(tN,n);if(t.connectionProtector===null&&((r=(e=globalThis.process)==null?void 0:e.env)==null?void 0:r.LIBP2P_FORCE_PNET)!=null)throw new W("Private network is enforced, but no protector was provided");return t}const nN=36e5,sN=216e5;var Ys;(function(n){(function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:Ee(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)})(n.Peer$metadataEntry||(n.Peer$metadataEntry={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),pu.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const h=s.uint32();switch(h>>>3){case 1:{a.key=s.string();break}case 2:{a.value=pu.codec().decode(s,s.uint32(),{limits:(l=o.limits)==null?void 0:l.value});break}default:{s.skipType(h&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.Peer$tagsEntry||(n.Peer$tagsEntry={}));let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.addresses!=null)for(const i of e.addresses)r.uint32(10),gu.codec().encode(i,r);if(e.protocols!=null)for(const i of e.protocols)r.uint32(18),r.string(i);if(e.publicKey!=null&&(r.uint32(34),r.bytes(e.publicKey)),e.peerRecordEnvelope!=null&&(r.uint32(42),r.bytes(e.peerRecordEnvelope)),e.metadata!=null&&e.metadata.size!==0)for(const[i,o]of e.metadata.entries())r.uint32(50),n.Peer$metadataEntry.codec().encode({key:i,value:o},r);if(e.tags!=null&&e.tags.size!==0)for(const[i,o]of e.tags.entries())r.uint32(58),n.Peer$tagsEntry.codec().encode({key:i,value:o},r);e.updated!=null&&(r.uint32(64),r.uint64Number(e.updated)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c,l,h,d,f;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const g=e.uint32();switch(g>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Fe('Decode error - map field "addresses" had too many elements');i.addresses.push(gu.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((l=s.limits)==null?void 0:l.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Fe('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 4:{i.publicKey=e.bytes();break}case 5:{i.peerRecordEnvelope=e.bytes();break}case 6:{if(((h=s.limits)==null?void 0:h.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new m2('Decode error - map field "metadata" had too many elements');const y=n.Peer$metadataEntry.codec().decode(e,e.uint32());i.metadata.set(y.key,y.value);break}case 7:{if(((d=s.limits)==null?void 0:d.tags)!=null&&i.tags.size===s.limits.tags)throw new m2('Decode error - map field "tags" had too many elements');const y=n.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:(f=s.limits)==null?void 0:f.tags$value}});i.tags.set(y.key,y.value);break}case 8:{i.updated=e.uint64Number();break}default:{e.skipType(g&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(Ys||(Ys={}));var gu;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.multiaddr!=null&&e.multiaddr.byteLength>0&&(r.uint32(10),r.bytes(e.multiaddr)),e.isCertified!=null&&(r.uint32(16),r.bool(e.isCertified)),e.observed!=null&&(r.uint32(24),r.uint64Number(e.observed)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={multiaddr:Ee(0)},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.multiaddr=e.bytes();break}case 2:{i.isCertified=e.bool();break}case 3:{i.observed=e.uint64Number();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(gu||(gu={}));var pu;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.value!=null&&e.value!==0&&(r.uint32(8),r.uint32(e.value)),e.expiry!=null&&(r.uint32(16),r.uint64(e.expiry)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{const i={value:0},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.value=e.uint32();break}case 2:{i.expiry=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(pu||(pu={}));function iN(n,t){if(n.publicKey!=null||t.publicKey==null)return n;let e;if(n.type==="RSA"){const s=ht.decode(`z${n}`);e=bt(s)}const r=ir(t.publicKey,e);return ko(r)}function $1(n,t,e){const r=Ys.decode(t);return z1(n,r,e)}function z1(n,t,e){const r=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||r.set(i,o);return{...t,id:iN(n,t),addresses:t.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-e).map(({multiaddr:i,isCertified:o})=>({multiaddr:fe(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:r}}function oN(n,t){return aN(n.addresses,t.addresses)&&cN(n.protocols,t.protocols)&&lN(n.publicKey,t.publicKey)&&uN(n.peerRecordEnvelope,t.peerRecordEnvelope)&&hN(n.metadata,t.metadata)&&dN(n.tags,t.tags)}function aN(n,t){return b9(n,t,(e,r)=>!(e.isCertified!==r.isCertified||!_e(e.multiaddr,r.multiaddr)))}function cN(n,t){return b9(n,t,(e,r)=>e===r)}function lN(n,t){return w9(n,t)}function uN(n,t){return w9(n,t)}function hN(n,t){return v9(n,t,(e,r)=>_e(e,r))}function dN(n,t){return v9(n,t,(e,r)=>e.value===r.value&&e.expiry===r.expiry)}function w9(n,t){return n==null&&t==null?!0:n!=null&&t!=null?_e(n,t):!1}function b9(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(!e(n[r],t[r]))return!1;return!0}function v9(n,t,e){if(n.size!==t.size)return!1;for(const[r,s]of n.entries()){const i=t.get(r);if(i==null||!e(s,i))return!1}return!0}const E9="/peers/";function Xc(n){if(!q4(n)||n.type==null)throw new W("Invalid PeerId");const t=n.toCID().toString();return new Ge(`${E9}${t}`)}async function fN(n,t,e,r){const s=new Map;for(const i of e){if(i==null)continue;if(i.multiaddr instanceof Uint8Array&&(i.multiaddr=fe(i.multiaddr)),!th(i.multiaddr))throw new W("Multiaddr was invalid");if(!await t(n,i.multiaddr))continue;const o=i.isCertified??!1,a=i.multiaddr.toString(),c=s.get(a);c!=null?i.isCertified=c.isCertified||o:s.set(a,{multiaddr:i.multiaddr,isCertified:o})}return[...s.values()].sort((i,o)=>i.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({isCertified:i,multiaddr:o})=>({isCertified:i,multiaddr:o.bytes}))}async function hd(n,t,e,r){var f,g;if(t==null)throw new W("Invalid PeerData");if(t.publicKey!=null&&n.publicKey!=null&&!t.publicKey.equals(n.publicKey))throw new W("publicKey bytes do not match peer id publicKey bytes");const s=(f=r.existingPeer)==null?void 0:f.peer;if(s!=null&&!n.equals(s.id))throw new W("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,l=s==null?void 0:s.peerRecordEnvelope;if(e==="patch"){if((t.multiaddrs!=null||t.addresses!=null)&&(i=[],t.multiaddrs!=null&&i.push(...t.multiaddrs.map(y=>({isCertified:!1,multiaddr:y}))),t.addresses!=null&&i.push(...t.addresses)),t.protocols!=null&&(o=new Set(t.protocols)),t.metadata!=null){const y=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);a=Zc(y,{validate:$p})}if(t.tags!=null){const y=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags);c=Zc(y,{validate:zp,map:Vp})}t.peerRecordEnvelope!=null&&(l=t.peerRecordEnvelope)}if(e==="merge"){if(t.multiaddrs!=null&&i.push(...t.multiaddrs.map(y=>({isCertified:!1,multiaddr:y}))),t.addresses!=null&&i.push(...t.addresses),t.protocols!=null&&(o=new Set([...o,...t.protocols])),t.metadata!=null){const y=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[p,w]of y)w==null?a.delete(p):a.set(p,w);a=Zc([...a.entries()],{validate:$p})}if(t.tags!=null){const y=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),p=new Map(c);for(const[w,v]of y)v==null?p.delete(w):p.set(w,v);c=Zc([...p.entries()],{validate:zp,map:Vp})}t.peerRecordEnvelope!=null&&(l=t.peerRecordEnvelope)}let h;(s==null?void 0:s.id.publicKey)!=null?h=Ur(s.id.publicKey):t.publicKey!=null?h=Ur(t.publicKey):n.publicKey!=null&&(h=Ur(n.publicKey));const d={addresses:await fN(n,r.addressFilter??(async()=>!0),i,(g=r.existingPeer)==null?void 0:g.peerPB.addresses),protocols:[...o.values()].sort((y,p)=>y.localeCompare(p)),metadata:a,tags:c,publicKey:h,peerRecordEnvelope:l};return d.addresses.forEach(y=>{var p,w,v;y.observed=((v=(w=(p=r.existingPeer)==null?void 0:p.peerPB.addresses)==null?void 0:w.find(x=>_e(x.multiaddr,x.multiaddr)))==null?void 0:v.observed)??Date.now()}),n.type!=="RSA"&&delete d.publicKey,d}function Zc(n,t){var r;const e=new Map;for(const[s,i]of n)i!=null&&t.validate(s,i);for(const[s,i]of n.sort(([o],[a])=>o.localeCompare(a)))i!=null&&e.set(s,((r=t.map)==null?void 0:r.call(t,s,i))??i);return e}function $p(n,t){if(typeof n!="string")throw new W("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new W("Metadata value must be a Uint8Array")}function zp(n,t){if(typeof n!="string")throw new W("Tag name must be a string");if(t.value!=null){if(parseInt(`${t.value}`,10)!==t.value)throw new W("Tag value must be an integer");if(t.value<0||t.value>100)throw new W("Tag value must be between 0-100")}if(t.ttl!=null){if(parseInt(`${t.ttl}`,10)!==t.ttl)throw new W("Tag ttl must be an integer");if(t.ttl<0)throw new W("Tag ttl must be between greater than 0")}}function Vp(n,t){let e;return t.expiry!=null&&(e=t.expiry),t.ttl!=null&&(e=BigInt(Date.now()+Number(t.ttl))),{value:t.value??0,expiry:e}}function S9(n){const t=n.toString().split("/")[2],e=te.parse(t,er);return qo(e)}function dd(n,t,e){const r=S9(n);return $1(r,t,e)}function gN(n,t){return{prefix:E9,filters:(n.filters??[]).map(e=>({key:r,value:s})=>e(dd(r,s,t))),orders:(n.orders??[]).map(e=>(r,s)=>e(dd(r.key,r.value,t),dd(s.key,s.value,t)))}}var nr,pl,ml,yl;class pN{constructor(t,e={}){ve(this,nr);u(this,"peerId");u(this,"datastore");u(this,"lock");u(this,"addressFilter");u(this,"log");u(this,"maxAddressAge");u(this,"maxPeerAge");this.log=t.logger.forComponent("libp2p:peer-store"),this.peerId=t.peerId,this.datastore=t.datastore,this.addressFilter=e.addressFilter,this.lock=Xf({name:"peer-store",singleProcess:!0}),this.maxAddressAge=e.maxAddressAge??nN,this.maxPeerAge=e.maxPeerAge??sN}async has(t){try{return await this.load(t),!0}catch(e){if(e.name!=="NotFoundError")throw e}return!1}async delete(t){this.peerId.equals(t)||await this.datastore.delete(Xc(t))}async load(t){const e=Xc(t),r=await this.datastore.get(e),s=Ys.decode(r);if(ie(this,nr,yl).call(this,t,s))throw await this.datastore.delete(e),new Nt;return z1(t,s,this.peerId.equals(t)?1/0:this.maxAddressAge)}async save(t,e){const r=await ie(this,nr,pl).call(this,t),s=await hd(t,e,"patch",{addressFilter:this.addressFilter});return ie(this,nr,ml).call(this,t,s,r)}async patch(t,e){const r=await ie(this,nr,pl).call(this,t),s=await hd(t,e,"patch",{addressFilter:this.addressFilter,existingPeer:r});return ie(this,nr,ml).call(this,t,s,r)}async merge(t,e){const r=await ie(this,nr,pl).call(this,t),s=await hd(t,e,"merge",{addressFilter:this.addressFilter,existingPeer:r});return ie(this,nr,ml).call(this,t,s,r)}async*all(t){for await(const{key:e,value:r}of this.datastore.query(gN(t??{},this.maxAddressAge))){const s=S9(e);if(s.equals(this.peerId))continue;const i=Ys.decode(r);if(ie(this,nr,yl).call(this,s,i)){await this.datastore.delete(e);continue}yield z1(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}nr=new WeakSet,pl=async function(t){try{const e=Xc(t),r=await this.datastore.get(e),s=Ys.decode(r);if(ie(this,nr,yl).call(this,t,s))throw await this.datastore.delete(e),new Nt;return{peerPB:s,peer:$1(t,r,this.maxAddressAge)}}catch(e){e.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",e)}},ml=async function(t,e,r){e.updated=Date.now();const s=Ys.encode(e);return await this.datastore.put(Xc(t),s),{peer:$1(t,s,this.maxAddressAge),previous:r==null?void 0:r.peer,updated:r==null||!oN(e,r.peerPB)}},yl=function(t,e){if(e.updated==null)return!0;if(this.peerId.equals(t))return!1;const r=e.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=e.addresses.filter(o=>o.observed!=null&&o.observed>s);return r&&i.length===0};var E4,mo,wl;E4=Symbol.toStringTag;class mN{constructor(t,e={}){ve(this,mo);u(this,"store");u(this,"events");u(this,"peerId");u(this,"log");u(this,E4,"@libp2p/peer-store");this.log=t.logger.forComponent("libp2p:peer-store"),this.events=t.events,this.peerId=t.peerId,this.store=new pN(t,e)}async forEach(t,e){this.log.trace("forEach await read lock");const r=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(e))t(s)}finally{this.log.trace("forEach release read lock"),r()}}async all(t){this.log.trace("all await read lock");const e=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await Wa(this.store.all(t))}finally{this.log.trace("all release read lock"),e()}}async delete(t){this.log.trace("delete await write lock");const e=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(t)}finally{this.log.trace("delete release write lock"),e()}}async has(t){this.log.trace("has await read lock");const e=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(t)}finally{this.log.trace("has release read lock"),e()}}async get(t){this.log.trace("get await read lock");const e=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(t)}finally{this.log.trace("get release read lock"),e()}}async save(t,e){this.log.trace("save await write lock");const r=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(t,e);return ie(this,mo,wl).call(this,t,s),s.peer}finally{this.log.trace("save release write lock"),r()}}async patch(t,e){this.log.trace("patch await write lock");const r=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(t,e);return ie(this,mo,wl).call(this,t,s),s.peer}finally{this.log.trace("patch release write lock"),r()}}async merge(t,e){this.log.trace("merge await write lock");const r=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(t,e);return ie(this,mo,wl).call(this,t,s),s.peer}finally{this.log.trace("merge release write lock"),r()}}async consumePeerRecord(t,e){const r=await Is.openAndCertify(t,dn.DOMAIN),s=qo(r.publicKey.toCID());if((e==null?void 0:e.equals(s))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",e,s),!1;const i=dn.createFromProtobuf(r.payload);let o;try{o=await this.get(s)}catch(a){if(a.name!=="NotFoundError")throw a}if((o==null?void 0:o.peerRecordEnvelope)!=null){const a=await Is.createFromProtobuf(o.peerRecordEnvelope),c=dn.createFromProtobuf(a.payload);if(c.seqNumber>=i.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,i.seqNumber),!1}return await this.patch(i.peerId,{peerRecordEnvelope:t,addresses:i.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}}mo=new WeakSet,wl=function(t,e){e.updated&&(this.peerId.equals(t)?this.events.safeDispatchEvent("self:peer:update",{detail:e}):this.events.safeDispatchEvent("peer:update",{detail:e}))};function yN(n,t={}){return new mN(n,t)}function wN(n,t){let e;const r=function(){const s=function(){e=void 0,n()};clearTimeout(e),e=setTimeout(s,t)};return r.start=()=>{},r.stop=()=>{clearTimeout(e)},r}const Hp=864e13,bN=448,fd=449,vN=53,EN=54,SN=55,xN=56;class _N{constructor(t,e={}){u(this,"log");u(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(t){const e=this.findHost(t);for(const r of this.mappings.values())if(r.domain===e)return!0;return!1}add(t,e){e.forEach(r=>{this.log("add DNS mapping %s to %s",r,t);const s=Ds(r)===!0;this.mappings.set(r,{domain:t,verified:s,expires:s?Hp-Date.now():0,lastVerified:s?Hp-Date.now():void 0})})}remove(t){const e=this.findHost(t);let r=!1;for(const[s,i]of this.mappings.entries())i.domain===e&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),r=r||i.verified);return r}getAll(t){const e=[];for(let r=0;r<t.length;r++){const i=t[r].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(t.splice(r,1),r--,e.push({multiaddr:fe(`/${i.map(h=>[ge(h[0]).name,h[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return e}maybeAddSNITuple(t,e){var r;for(let s=0;s<t.length;s++)if(t[s][0]===bN&&((r=t[s+1])==null?void 0:r[0])!==fd)return t.splice(s+1,0,[fd,e]),!0;return!1}confirm(t,e){const r=this.findHost(t);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+e,o.lastVerified=Date.now());return s}unconfirm(t,e){const r=this.findHost(t);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===r&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+e);return s}findHost(t){for(const e of t.stringTuples())if(e[0]===fd||e[0]===vN||e[0]===EN||e[0]===SN||e[0]===xN)return e[1]}}const gd=4,pd=41,md=6,kN=273;class IN{constructor(t,e={}){u(this,"log");u(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(t){const e=t.stringTuples();for(const r of this.mappings.values())for(const s of r)if(s.externalIp===e[0][1])return!0;return!1}add(t,e,r,s=e,i="tcp"){const o=`${t}-${e}-${i}`,a=this.mappings.get(o)??[],c={internalIp:t,internalPort:e,externalIp:r,externalPort:s,externalFamily:Po(r)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(t){const e=t.stringTuples(),r=e[0][1]??"",s=e[1][0]===md?"tcp":"udp",i=parseInt(e[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const h=c[l];h.externalIp===r&&h.externalPort===i&&h.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",h.externalIp,h.externalPort,r,i,s),o=o||h.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(t){const e=[];for(const{multiaddr:r}of t){const s=r.stringTuples();let i;if((s[0][0]===gd||s[0][0]===pd)&&s[1][0]===md?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===gd||s[0][0]===pd)&&s[1][0]===kN&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?gd:pd,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,e.push({multiaddr:fe(`/${s.map(c=>[ge(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return e}confirm(t,e){const s=t.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+e,a.lastVerified=Date.now());return i}unconfirm(t,e){const r=t.stringTuples(),s=r[0][1]??"",i=r[1][0]===md?"tcp":"udp",o=parseInt(r[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const h=c[l];h.externalIp===s&&h.externalPort===o&&h.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",h.externalIp,h.externalPort,s,o,i),a=a||h.verified,h.verified=!1,h.expires=Date.now()+e)}return a}}const AN=4,TN=41;function CN(n){try{const[[t,e]]=n.stringTuples();if(e==null)return!1;if(t===AN)return e.startsWith("169.254.");if(t===TN)return e.toLowerCase().startsWith("fe80")}catch{}return!1}const PN={maxObservedAddresses:10};class DN{constructor(t,e={}){u(this,"log");u(this,"addresses");u(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=e.maxObservedAddresses??PN.maxObservedAddresses}has(t){return this.addresses.has(t.toString())}removePrefixed(t){for(const e of this.addresses.keys())e.toString().startsWith(t)&&this.addresses.delete(e)}add(t){this.addresses.size!==this.maxObservedAddresses&&(gi(t)||CN(t)||(this.log("adding observed address %a",t),this.addresses.set(t.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([t,e])=>({multiaddr:fe(t),verified:e.verified,type:"observed",expires:e.expires,lastVerified:e.lastVerified}))}remove(t){var r;const e=((r=this.addresses.get(t.toString()))==null?void 0:r.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(t.toString()),e}confirm(t,e){const r=t.toString(),s=this.addresses.get(r)??{verified:!1,expires:Date.now()+e,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,s),i}}const RN=4,BN=41,MN=53,NN=54,LN=55,ON=56,FN=[RN,BN,MN,NN,LN,ON];function qp(n){try{const[[t]]=n.stringTuples();return FN.includes(t)}catch{}return!1}const UN={maxObservedAddresses:10};class $N{constructor(t,e={}){u(this,"log");u(this,"addresses");u(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=e.maxObservedAddresses??UN.maxObservedAddresses}get(t,e){if(gi(t))return{multiaddr:t,verified:!0,type:"transport",expires:Date.now()+e,lastVerified:Date.now()};const r=this.toKey(t);let s=this.addresses.get(r);return s==null&&(s={verified:!qp(t),expires:0},this.addresses.set(r,s)),{multiaddr:t,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(t){const e=this.toKey(t);return this.addresses.has(e)}remove(t){var s;const e=this.toKey(t),r=((s=this.addresses.get(e))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(e),r}confirm(t,e){const r=this.toKey(t),s=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.addresses.set(r,s),i}unconfirm(t,e){const r=this.toKey(t),s=this.addresses.get(r)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+e,this.addresses.set(r,s),i}toKey(t){if(qp(t)){const e=t.toOptions();return`${e.host}-${e.port}-${e.transport}`}return t.toString()}}const Wp=6e4,Kp={addressVerificationTTL:Wp*10,addressVerificationRetry:Wp*5},zN=n=>n;function yd(n,t){const e=n.getPeerId();return e!=null&&ut(e).equals(t)&&(n=n.decapsulate(fe(`/p2p/${t.toString()}`))),n}var S4;S4=Symbol.toStringTag;class VN{constructor(t,e={}){u(this,"log");u(this,"components");u(this,"listen");u(this,"announce");u(this,"appendAnnounce");u(this,"announceFilter");u(this,"observed");u(this,"dnsMappings");u(this,"ipMappings");u(this,"transportAddresses");u(this,"observedAddressFilter");u(this,"addressVerificationTTL");u(this,"addressVerificationRetry");u(this,S4,"@libp2p/address-manager");const{listen:r=[],announce:s=[],appendAnnounce:i=[]}=e;this.components=t,this.log=t.logger.forComponent("libp2p:address-manager"),this.listen=r.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new DN(t,e),this.dnsMappings=new _N(t,e),this.ipMappings=new IN(t,e),this.transportAddresses=new $N(t,e),this.announceFilter=e.announceFilter??zN,this.observedAddressFilter=hi(1024),this.addressVerificationTTL=e.addressVerificationTTL??Kp.addressVerificationTTL,this.addressVerificationRetry=e.addressVerificationRetry??Kp.addressVerificationRetry,this._updatePeerStoreAddresses=wN(this._updatePeerStoreAddresses.bind(this),1e3),t.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),t.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const t=this.getAddresses().map(e=>e.getPeerId()===this.components.peerId.toString()?e.decapsulate(`/p2p/${this.components.peerId.toString()}`):e);this.components.peerStore.patch(this.components.peerId,{multiaddrs:t}).catch(e=>{this.log.error("error updating addresses",e)})}getListenAddrs(){return Array.from(this.listen).map(t=>fe(t))}getAnnounceAddrs(){return Array.from(this.announce).map(t=>fe(t))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(t=>fe(t))}getObservedAddrs(){return this.observed.getAll().map(t=>t.multiaddr)}addObservedAddr(t){const e=t.stringTuples(),r=`${e[0][1]}:${e[1][1]}`;this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),t=yd(t,this.components.peerId),!this.ipMappings.has(t)&&(this.dnsMappings.has(t)||this.observed.add(t)))}confirmObservedAddr(t,e){t=yd(t,this.components.peerId);let r=!0;((e==null?void 0:e.type)==="transport"||this.transportAddresses.has(t))&&!this.transportAddresses.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&r&&(r=!1),((e==null?void 0:e.type)==="dns-mapping"||this.dnsMappings.has(t))&&!this.dnsMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&r&&(r=!1),((e==null?void 0:e.type)==="ip-mapping"||this.ipMappings.has(t))&&!this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&r&&(r=!1),((e==null?void 0:e.type)==="observed"||this.observed.has(t))&&(this.maybeUpgradeToIPMapping(t)?(this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL),r=!1):!this.observed.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&r&&(r=!1)),r||this._updatePeerStoreAddresses()}removeObservedAddr(t,e){t=yd(t,this.components.peerId),this.observed.has(t)&&this.observed.remove(t),this.transportAddresses.has(t)&&this.transportAddresses.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.dnsMappings.has(t)&&this.dnsMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.ipMappings.has(t)&&this.ipMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry)}getAddresses(){const t=new Set,e=this.getAddressesWithMetadata().filter(r=>{if(!r.verified)return!1;const s=r.multiaddr.toString();return t.has(s)?!1:(t.add(s),!0)}).map(r=>r.multiaddr);return this.announceFilter(e.map(r=>{var i;const s=fe(r);return((i=s.protos().pop())==null?void 0:i.path)===!0||s.getPeerId()===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const t=this.getAnnounceAddrs();if(t.length>0)return this.components.transportManager.getListeners().forEach(r=>{r.updateAnnounceAddrs(t)}),t.map(r=>({multiaddr:r,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let e=[];return e=e.concat(this.components.transportManager.getAddrs().map(r=>this.transportAddresses.get(r,this.addressVerificationTTL))),e=e.concat(this.getAppendAnnounceAddrs().map(r=>({multiaddr:r,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}))),e=e.concat(this.observed.getAll()),e=e.concat(this.ipMappings.getAll(e)),e=e.concat(this.dnsMappings.getAll(e)),e}addDNSMapping(t,e){this.dnsMappings.add(t,e)}removeDNSMapping(t){this.dnsMappings.remove(fe(`/dns/${t}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(t,e,r,s=e,i="tcp"){this.ipMappings.add(t,e,r,s,i),this.observed.removePrefixed(`/ip${Po(r)?4:6}/${r}/${i}/${s}`)}removePublicAddressMapping(t,e,r,s=e,i="tcp"){this.ipMappings.remove(fe(`/ip${Po(r)?4:6}/${r}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(t){if(this.ipMappings.has(t))return!1;const e=t.toOptions();if(e.family===6||e.host==="127.0.0.1"||Ds(e.host)===!0)return!1;const r=this.components.transportManager.getListeners(),s=[i=>za.exactMatch(i)||Ql.exactMatch(i),i=>Gl.exactMatch(i),i=>RI.exactMatch(i)];for(const i of s){if(!i(t))continue;const o=r.filter(l=>l.getAddrs().filter(h=>h.toOptions().family===4&&i(h)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(t),this.ipMappings.add(c.host,c.port,e.host,e.port,e.transport),!0}return!1}}var Gp;(function(n){n.NOT_STARTED_YET="The libp2p node is not started yet",n.NOT_FOUND="Not found"})(Gp||(Gp={}));class HN extends Error{constructor(t="Missing service"){super(t),this.name="MissingServiceError"}}class qN extends Error{constructor(t="Unmet service dependencies"){super(t),this.name="UnmetServiceDependenciesError"}}class wd extends Error{constructor(t="No content routers available"){super(t),this.name="NoContentRoutersError"}}class Qp extends Error{constructor(t="No peer routers available"){super(t),this.name="NoPeerRoutersError"}}class WN extends Error{constructor(t="Should not try to find self"){super(t),this.name="QueriedForSelfError"}}class KN extends Error{constructor(t="Unhandled protocol error"){super(t),this.name="UnhandledProtocolError"}}class GN extends Error{constructor(t="Duplicate protocol handler error"){super(t),this.name="DuplicateProtocolHandlerError"}}class Yp extends Error{constructor(t="Dial denied error"){super(t),this.name="DialDeniedError"}}class QN extends Error{constructor(t="No transport was configured to listen on this address"){super(t),this.name="UnsupportedListenAddressError"}}class YN extends Error{constructor(t="Configured listen addresses could not be listened on"){super(t),this.name="UnsupportedListenAddressesError"}}class XN extends Error{constructor(t="No valid addresses"){super(t),this.name="NoValidAddressesError"}}class ZN extends Error{constructor(t="Connection intercepted"){super(t),this.name="ConnectionInterceptedError"}}class JN extends Error{constructor(t="Connection denied"){super(t),this.name="ConnectionDeniedError"}}class Jc extends Error{constructor(t="Stream is not multiplexed"){super(t),this.name="MuxerUnavailableError"}}class jc extends Error{constructor(t="Encryption failed"){super(t),this.name="EncryptionFailedError"}}class jN extends Error{constructor(t="Transport unavailable"){super(t),this.name="TransportUnavailableError"}}class eL{constructor(t={}){u(this,"components",{});u(this,"_started",!1);this.components={};for(const[e,r]of Object.entries(t))this.components[e]=r;this.components.logger==null&&(this.components.logger=Ku())}isStarted(){return this._started}async _invokeStartableMethod(t){await Promise.all(Object.values(this.components).filter(e=>hf(e)).map(async e=>{var r;await((r=e[t])==null?void 0:r.call(e))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const tL=["metrics","connectionProtector","dns"],rL=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function nL(n={}){const t=new eL(n);return new Proxy(t,{get(r,s,i){if(typeof s=="string"&&!rL.includes(s)){const o=t.components[s];if(o==null&&!tL.includes(s))throw new HN(`${s} not set`);return o}return Reflect.get(r,s,i)},set(r,s,i){return typeof s=="string"?t.components[s]=i:Reflect.set(r,s,i),!0}})}function sL(n){const t={};for(const e of Object.values(n.components))for(const r of iL(e))t[r]=!0;for(const e of Object.values(n.components))for(const r of oL(e))if(t[r]!==!0)throw new qN(`Service "${aL(e)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function iL(n){return Array.isArray(n==null?void 0:n[Pt])?n[Pt]:[]}function oL(n){return Array.isArray(n==null?void 0:n[ms])?n[ms]:[]}function aL(n){return(n==null?void 0:n[Symbol.toStringTag])??(n==null?void 0:n.toString())??"unknown"}const cL=4,lL=41;function uL(n={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async t=>{if(za.matches(t))return!1;const e=t.stringTuples();return e[0][0]===cL||e[0][0]===lL?!!Ds(`${e[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...n}}function x9(n){if(q4(n))return{peerId:n,multiaddrs:[]};Array.isArray(n)||(n=[n]);let t;if(n.length>0){const e=n[0].getPeerId();t=e==null?void 0:ut(e),n.forEach(r=>{if(!th(r))throw new Tu("Invalid multiaddr");const s=r.getPeerId();if(s==null){if(t!=null)throw new W("Multiaddrs must all have the same peer id or have no peer id")}else{const i=ut(s);if((t==null?void 0:t.equals(i))!==!0)throw new W("Multiaddrs must all have the same peer id or have no peer id")}})}return{peerId:t,multiaddrs:n}}const hL=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function dL(n,t){var s;const e=((s=n==null?void 0:n.streams)==null?void 0:s.map(i=>i.protocol))??[],r=(t==null?void 0:t.closableProtocols)??hL;if(!(e.filter(i=>i!=null&&!r.includes(i)).length>0))try{await(n==null?void 0:n.close(t))}catch(i){n==null||n.abort(i)}}const _9=1e4,fL=1e4,Xp=1e4,k9=25,gL=5,pL=10,mL=5,yL="last-dial-failure",wL="last-dial-success",I9=500,A9=100,T9=50;async function bL(n,t){let e=!1;for(const s of d0.keys())if(e=n.protoNames().includes(s),e)break;if(!e)return[n];const r=await n.resolve(t);return t.log("resolved %s to",n,r.map(s=>s.toString())),r}function V1(n){try{let t;if(typeof n=="string"?t=fe(n):t=n,!t.protoNames().includes("ipcidr")){const r=t.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";t=t.encapsulate(r)}return rA(t)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${n}`)}}const vL={maxConnections:A9};class EL{constructor(t,e={}){u(this,"maxConnections");u(this,"connectionManager");u(this,"peerStore");u(this,"allow");u(this,"events");u(this,"log");this.maxConnections=e.maxConnections??vL.maxConnections,this.allow=(e.allow??[]).map(r=>V1(r)),this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(t=>{this.log.error("error while pruning connections %e",t)})}async _maybePruneConnections(){const t=this.connectionManager.getConnections(),e=t.length;if(this.log("checking max connections limit %d/%d",e,this.maxConnections),e<=this.maxConnections)return;const r=new Ps;for(const a of t){const c=a.remotePeer;if(!r.has(c)){r.set(c,0);try{const l=await this.peerStore.get(c);r.set(c,[...l.tags.values()].reduce((h,d)=>h+d.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(t,r),i=Math.max(e-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await dL(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(t,e){return t.sort((r,s)=>{const i=r.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((r,s)=>r.direction==="outbound"&&s.direction==="inbound"?1:r.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((r,s)=>r.streams.length>s.streams.length?1:r.streams.length<s.streams.length?-1:0).sort((r,s)=>{const i=e.get(r.remotePeer)??0,o=e.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class SL extends oi{constructor(t={}){super({...t,sort:(e,r)=>e.options.priority>r.options.priority?-1:e.options.priority<r.options.priority?1:0})}}function xL(n){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n)||/^::1$/.test(n)}function Zp(n){if(!tm(n))return!1;const{address:t}=n.nodeAddress();return xL(t)}function _L(n,t){const e=Gl.exactMatch(n.multiaddr),r=Gl.exactMatch(t.multiaddr);if(e&&!r)return-1;if(!e&&r)return 1;const s=Ql.exactMatch(n.multiaddr),i=Ql.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=za.exactMatch(n.multiaddr),a=za.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=c1.exactMatch(n.multiaddr),l=c1.exactMatch(t.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const h=a1.exactMatch(n.multiaddr),d=a1.exactMatch(t.multiaddr);if(h&&!d)return-1;if(!h&&d)return 1;const f=ug.exactMatch(n.multiaddr),g=ug.exactMatch(t.multiaddr);return f&&!g?-1:!f&&g?1:0}function kL(n,t){const e=Zp(n.multiaddr),r=Zp(t.multiaddr);return e&&!r?1:!e&&r?-1:0}function IL(n,t){const e=gi(n.multiaddr),r=gi(t.multiaddr);return e&&!r?1:!e&&r?-1:0}function AL(n,t){return n.isCertified&&!t.isCertified?-1:!n.isCertified&&t.isCertified?1:0}function TL(n,t){const e=_s.exactMatch(n.multiaddr),r=_s.exactMatch(t.multiaddr);return e&&!r?1:!e&&r?-1:0}function CL(n){return n.sort(_L).sort(AL).sort(TL).sort(IL).sort(kL)}const el={maxParallelDials:T9,maxDialQueueLength:I9,maxPeerAddrsToDial:k9,dialTimeout:_9};class PL{constructor(t,e={}){u(this,"queue");u(this,"components");u(this,"addressSorter");u(this,"maxPeerAddrsToDial");u(this,"maxDialQueueLength");u(this,"dialTimeout");u(this,"shutDownController");u(this,"connections");u(this,"log");this.addressSorter=e.addressSorter,this.maxPeerAddrsToDial=e.maxPeerAddrsToDial??el.maxPeerAddrsToDial,this.maxDialQueueLength=e.maxDialQueueLength??el.maxDialQueueLength,this.dialTimeout=e.dialTimeout??el.dialTimeout,this.connections=e.connections??new Ps,this.log=t.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=t,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[r,s]of Object.entries(e.resolvers??{}))d0.set(r,s);this.queue=new SL({concurrency:e.maxParallelDials??el.maxParallelDials,metricName:"libp2p_dial_queue",metrics:t.metrics}),this.queue.addEventListener("error",r=>{r.detail.name!==ii.name&&this.log.error("error in dial queue - %e",r.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(t,e={}){var a,c,l;const{peerId:r,multiaddrs:s}=x9(t),i=Array.from(this.connections.values()).flat().find(h=>e.force===!0?!1:h.remotePeer.equals(r)?!0:s.find(d=>d.equals(h.remoteAddr)));if((i==null?void 0:i.status)==="open")return this.log("already connected to %a",i.remoteAddr),(a=e.onProgress)==null||a.call(e,new se("dial-queue:already-connected")),i;const o=this.queue.queue.find(h=>{if((r==null?void 0:r.equals(h.options.peerId))===!0)return!0;const d=h.options.multiaddrs;if(d==null)return!1;for(const f of s)if(d.has(f.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",r);for(const h of s)o.options.multiaddrs.add(h.toString());return(c=e.onProgress)==null||c.call(e,new se("dial-queue:already-in-dial-queue")),o.join(e)}if(this.queue.size>=this.maxDialQueueLength)throw new eo("Dial queue is full");return this.log("creating dial target for %p",r,s.map(h=>h.toString())),(l=e.onProgress)==null||l.call(e,new se("dial-queue:add-to-dial-queue")),this.queue.add(async h=>{var f;(f=h.onProgress)==null||f.call(h,new se("dial-queue:start-dial"));const d=Ne([this.shutDownController.signal,h.signal]);try{return await this.dialPeer(h,d)}finally{d.clear()}},{peerId:r,priority:e.priority??C9,multiaddrs:new Set(s.map(h=>h.toString())),signal:e.signal??AbortSignal.timeout(this.dialTimeout),onProgress:e.onProgress})}async dialPeer(t,e){var h;const r=t.peerId,s=t.multiaddrs,i=new Set;let o=t.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",r);o||s.size>0;){c++,o=!1;const d=[],f=new Set(t.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",r,[...f]);const g=await this.calculateMultiaddrs(r,f,{...t,signal:e});for(const y of g){if(i.has(y.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",y.multiaddr,r);continue}d.push(y)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",r,d.map(y=>y.multiaddr.toString())),(h=t==null?void 0:t.onProgress)==null||h.call(t,new se("dial-queue:calculated-addresses",d));for(const y of d){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,t.peerId),new eo("Peer had more than maxPeerAddrsToDial");a++;try{const p=await this.components.transportManager.dial(y.multiaddr,{...t,signal:e});this.log("dial to %a succeeded",y.multiaddr);try{await this.components.peerStore.merge(p.remotePeer,{multiaddrs:[p.remoteAddr],metadata:{[wL]:Y(Date.now().toString())}})}catch(w){this.log.error("could not update last dial failure key for %p",r,w)}return p}catch(p){if(this.log.error("dial failed to %a",y.multiaddr,p),i.add(y.multiaddr.toString()),r!=null)try{await this.components.peerStore.merge(r,{metadata:{[yL]:Y(Date.now().toString())}})}catch(w){this.log.error("could not update last dial failure key for %p",r,w)}if(e.aborted)throw new Pu(p.message);l.push(p)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(t,e=new Set,r={}){var d,f;const s=[...e].map(g=>({multiaddr:fe(g),isCertified:!1}));if(t!=null){if(this.components.peerId.equals(t))throw new eo("Tried to dial self");if(await((f=(d=this.components.connectionGater).denyDialPeer)==null?void 0:f.call(d,t))===!0)throw new Yp("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",t);try{const g=await this.components.peerStore.get(t);s.push(...g.addresses),this.log("loaded multiaddrs for %p",t,s.map(({multiaddr:y})=>y.toString()))}catch(g){if(g.name!=="NotFoundError")throw g}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",t);try{const g=await this.components.peerRouting.findPeer(t,r);this.log("found multiaddrs for %p in the peer routing",t,s.map(({multiaddr:y})=>y.toString())),s.push(...g.multiaddrs.map(y=>({multiaddr:y,isCertified:!1})))}catch(g){g.name==="NoPeerRoutersError"?this.log("no peer routers configured",t):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",t,g)}}}let i=(await Promise.all(s.map(async g=>{const y=await bL(g.multiaddr,{dns:this.components.dns,...r,log:this.log});return y.length===1&&y[0].equals(g.multiaddr)?g:y.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(t!=null){const g=`/p2p/${t.toString()}`;i=i.map(y=>{const p=y.multiaddr.protos().pop();return(p==null?void 0:p.path)===!0?y:y.multiaddr.getPeerId()==null?{multiaddr:y.multiaddr.encapsulate(g),isCertified:y.isCertified}:y})}const o=i.filter(g=>{if(this.components.transportManager.dialTransportForMultiaddr(g.multiaddr)==null)return!1;const y=g.multiaddr.getPeerId();return t!=null&&y!=null?t.equals(y):!0}),a=new Map;for(const g of o){const y=g.multiaddr.toString(),p=a.get(y);if(p!=null){p.isCertified=p.isCertified||g.isCertified||!1;continue}a.set(y,g)}const c=[...a.values()];if(c.length===0)throw new XN("The dial request has no valid addresses");const l=[];for(const g of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(g.multiaddr)||l.push(g);const h=this.addressSorter==null?CL(l):l.sort(this.addressSorter);if(h.length===0)throw new Yp("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",t??"unknown peer",i.map(({multiaddr:g})=>g.toString())),this.log.trace("addresses for %p after filtering",t??"unknown peer",h.map(({multiaddr:g})=>g.toString())),h}async isDialable(t,e={}){Array.isArray(t)||(t=[t]);try{const r=await this.calculateMultiaddrs(void 0,new Set(t.map(s=>s.toString())),e);return e.runOnLimitedConnection===!1?r.find(s=>!_s.matches(s.multiaddr))!=null:!0}catch(r){this.log.trace("error calculating if multiaddr(s) were dialable",r)}return!1}}var bd={},vd,Jp;function DL(){if(Jp)return vd;Jp=1;function n(t,e){typeof e=="boolean"&&(e={forever:e}),this._originalTimeouts=JSON.parse(JSON.stringify(t)),this._timeouts=t,this._options=e||{},this._maxRetryTime=e&&e.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return vd=n,n.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},n.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},n.prototype.retry=function(t){if(this._timeout&&clearTimeout(this._timeout),!t)return!1;var e=new Date().getTime();if(t&&e-this._operationStart>=this._maxRetryTime)return this._errors.push(t),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(t);var r=this._timeouts.shift();if(r===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},r),this._options.unref&&this._timer.unref(),!0},n.prototype.attempt=function(t,e){this._fn=t,e&&(e.timeout&&(this._operationTimeout=e.timeout),e.cb&&(this._operationTimeoutCb=e.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},n.prototype.try=function(t){console.log("Using RetryOperation.try() is deprecated"),this.attempt(t)},n.prototype.start=function(t){console.log("Using RetryOperation.start() is deprecated"),this.attempt(t)},n.prototype.start=n.prototype.try,n.prototype.errors=function(){return this._errors},n.prototype.attempts=function(){return this._attempts},n.prototype.mainError=function(){if(this._errors.length===0)return null;for(var t={},e=null,r=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(t[o]||0)+1;t[o]=a,a>=r&&(e=i,r=a)}return e},vd}var jp;function RL(){return jp||(jp=1,function(n){var t=DL();n.operation=function(e){var r=n.timeouts(e);return new t(r,{forever:e&&(e.forever||e.retries===1/0),unref:e&&e.unref,maxRetryTime:e&&e.maxRetryTime})},n.timeouts=function(e){if(e instanceof Array)return[].concat(e);var r={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in e)r[s]=e[s];if(r.minTimeout>r.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<r.retries;o++)i.push(this.createTimeout(o,r));return e&&e.forever&&!i.length&&i.push(this.createTimeout(o,r)),i.sort(function(a,c){return a-c}),i},n.createTimeout=function(e,r){var s=r.randomize?Math.random()+1:1,i=Math.round(s*Math.max(r.minTimeout,1)*Math.pow(r.factor,e));return i=Math.min(i,r.maxTimeout),i},n.wrap=function(e,r,s){if(r instanceof Array&&(s=r,r=null),!s){s=[];for(var i in e)typeof e[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=e[a];e[a]=(function(h){var d=n.operation(r),f=Array.prototype.slice.call(arguments,1),g=f.pop();f.push(function(y){d.retry(y)||(y&&(arguments[0]=d.mainError()),g.apply(this,arguments))}),d.attempt(function(){h.apply(e,f)})}).bind(e,c),e[a].options=r}}}(bd)),bd}var Ed,e3;function BL(){return e3||(e3=1,Ed=RL()),Ed}var ML=BL();const NL=Fn(ML),LL=Object.prototype.toString,OL=n=>LL.call(n)==="[object Error]",FL=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function UL(n){return n&&OL(n)&&n.name==="TypeError"&&typeof n.message=="string"?n.message==="Load failed"?n.stack===void 0:FL.has(n.message):!1}class $L extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,{message:t}=t):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}const t3=(n,t,e)=>{const r=e.retries-(t-1);return n.attemptNumber=t,n.retriesLeft=r,n};async function zL(n,t){return new Promise((e,r)=>{t={...t},t.onFailedAttempt??(t.onFailedAttempt=()=>{}),t.shouldRetry??(t.shouldRetry=()=>!0),t.retries??(t.retries=10);const s=NL.operation(t),i=()=>{var a;s.stop(),r((a=t.signal)==null?void 0:a.reason)};t.signal&&!t.signal.aborted&&t.signal.addEventListener("abort",i,{once:!0});const o=()=>{var a;(a=t.signal)==null||a.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await n(a);o(),e(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof $L)throw c.originalError;if(c instanceof TypeError&&!UL(c))throw c;if(t3(c,a,t),await t.shouldRetry(c)||(s.stop(),r(c)),await t.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(l){t3(l,a,t),o(),r(l)}}})})}class VL{constructor(t,e={}){u(this,"log");u(this,"queue");u(this,"started");u(this,"peerStore");u(this,"retries");u(this,"retryInterval");u(this,"backoffFactor");u(this,"connectionManager");u(this,"events");this.log=t.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.queue=new ys({concurrency:e.maxParallelReconnects??mL,metricName:"libp2p_reconnect_queue",metrics:t.metrics}),this.started=!1,this.retries=e.retries??5,this.backoffFactor=e.backoffFactor,this.retryInterval=e.retryInterval,this.events=t.events,t.events.addEventListener("peer:disconnect",r=>{this.maybeReconnect(r.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",r.detail,s)})})}async maybeReconnect(t){if(!this.started)return;const e=await this.peerStore.get(t);r3(e)&&(this.queue.has(t)||this.queue.add(async r=>{await zL(async s=>{if(this.started)try{await this.connectionManager.openConnection(t,{signal:r==null?void 0:r.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",t,s,this.retries,i),i}},{signal:r==null?void 0:r.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:t}).catch(async r=>{this.log.error("failed to reconnect to %p - %e",t,r);const s={};[...e.tags.keys()].forEach(i=>{i.startsWith(Iu)&&(s[i]=void 0)}),await this.peerStore.merge(t,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:t})}).catch(async r=>{this.log.error("failed to remove keep-alive tag from %p - %e",t,r)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[e=>r3(e)]});await Promise.all(t.map(async e=>{await this.connectionManager.openConnection(e.id).catch(r=>{this.log.error(r)})}))}).catch(t=>{this.log.error(t)})}stop(){this.started=!1,this.queue.abort()}}function r3(n){for(const t of n.tags.keys())if(t.startsWith(Iu))return!0;return!1}const C9=50,Sd={maxConnections:A9,inboundConnectionThreshold:gL,maxIncomingPendingConnections:pL};var x4;x4=Symbol.toStringTag;class HL{constructor(t,e={}){u(this,"started");u(this,"connections");u(this,"allow");u(this,"deny");u(this,"maxIncomingPendingConnections");u(this,"incomingPendingConnections");u(this,"outboundPendingConnections");u(this,"maxConnections");u(this,"dialQueue");u(this,"reconnectQueue");u(this,"connectionPruner");u(this,"inboundConnectionRateLimiter");u(this,"peerStore");u(this,"metrics");u(this,"events");u(this,"log");u(this,"peerId");u(this,x4,"@libp2p/connection-manager");var r;if(this.maxConnections=e.maxConnections??Sd.maxConnections,this.maxConnections<1)throw new W("Connection Manager maxConnections must be greater than 0");this.connections=new Ps,this.started=!1,this.peerId=t.peerId,this.peerStore=t.peerStore,this.metrics=t.metrics,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(e.allow??[]).map(s=>V1(s)),this.deny=(e.deny??[]).map(s=>V1(s)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=e.maxIncomingPendingConnections??Sd.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new Z7({points:e.inboundConnectionThreshold??Sd.inboundConnectionThreshold,duration:1}),this.connectionPruner=new EL({connectionManager:this,peerStore:t.peerStore,events:t.events,logger:t.logger},{maxConnections:this.maxConnections,allow:(r=e.allow)==null?void 0:r.map(s=>fe(s))}),this.dialQueue=new PL(t,{addressSorter:e.addressSorter,maxParallelDials:e.maxParallelDials??T9,maxDialQueueLength:e.maxDialQueueLength??I9,maxPeerAddrsToDial:e.maxPeerAddrsToDial??k9,dialTimeout:e.dialTimeout??_9,resolvers:e.resolvers??{dnsaddr:y9},connections:this.connections}),this.reconnectQueue=new VL({events:t.events,peerStore:t.peerStore,logger:t.logger,connectionManager:this},{retries:e.reconnectRetries,retryInterval:e.reconnectRetryInterval,backoffFactor:e.reconnectBackoffFactor,maxParallelReconnects:e.maxParallelReconnects})}async start(){var t,e,r;(t=this.metrics)==null||t.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(e=this.metrics)==null||e.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(r=this.metrics)==null||r.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const l of a.streams){const h=`${l.direction} ${l.protocol??"unnegotiated"}`;c[h]=(c[h]??0)+1}for(const[l,h]of Object.entries(c))s[l]=s[l]??[],s[l].push(h)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((l,h)=>l-h);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Ln(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Cs(this.reconnectQueue,this.dialQueue,this.connectionPruner);const t=[];for(const e of this.connections.values())for(const r of e)t.push((async()=>{try{await r.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",t.length),await Promise.all(t),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(t){this._onConnect(t).catch(e=>{this.log.error(e)})}async _onConnect(t){const{detail:e}=t;if(!this.started){await e.close();return}if(e.status!=="open")return;const r=e.remotePeer,s=!this.connections.has(r),i=this.connections.get(r)??[];i.push(e),this.connections.set(r,i),r.publicKey!=null&&r.type==="RSA"&&await this.peerStore.patch(r,{publicKey:r.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:e.remotePeer})}onDisconnect(t){const{detail:e}=t,r=e.remotePeer,i=(this.connections.get(r)??[]).filter(o=>o.id!==e.id);this.connections.set(r,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:e.remotePeer}))}getConnections(t){if(t!=null)return this.connections.get(t)??[];let e=[];for(const r of this.connections.values())e=e.concat(r);return e}getConnectionsMap(){return this.connections}async openConnection(t,e={}){var r,s;if(!this.started)throw new bo("Not started");this.outboundPendingConnections++;try{(r=e.signal)==null||r.throwIfAborted();const{peerId:i}=x9(t);if(this.peerId.equals(i))throw new lf("Can not dial self");if(i!=null&&e.force!==!0){this.log("dial %p",i);const l=this.getConnections(i).find(h=>h.limits==null);if(l!=null)return this.log("had an existing non-limited connection to %p",i),(s=e.onProgress)==null||s.call(e,new se("dial-queue:already-connected")),l}const o=await this.dialQueue.dial(t,{...e,priority:e.priority??C9});if(o.status!=="open")throw new af("Remote closed connection during opening");let a=this.connections.get(o.remotePeer);a==null&&(a=[],this.connections.set(o.remotePeer,a));let c=!1;for(const l of a)if(l.id===o.id&&(c=!0),e.force!==!0&&l.id!==o.id&&l.remoteAddr.equals(o.remoteAddr))return o.abort(new Tu("Duplicate multiaddr connection")),l;return c||a.push(o),o}finally{this.outboundPendingConnections--}}async closeConnections(t,e={}){const r=this.connections.get(t)??[];await Promise.all(r.map(async s=>{try{await s.close(e)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(t){if(this.deny.some(s=>s.contains(t.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",t.remoteAddr),!1;if(this.allow.some(s=>s.contains(t.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",t.remoteAddr),!1;if(t.remoteAddr.isThinWaistAddress()){const s=t.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",t.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",t.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const t={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(e=>({id:e.id,status:t[e.status],peerId:e.options.peerId,multiaddrs:[...e.options.multiaddrs].map(r=>fe(r))}))}async isDialable(t,e={}){return this.dialQueue.isDialable(t,e)}}const qL=1e4,WL="1.0.0",KL="ping",GL="ipfs",n3=32,QL=!0;var _4,k4;k4=Symbol.toStringTag,_4=Pt;class YL{constructor(t,e={}){u(this,"protocol");u(this,"components");u(this,"log");u(this,"heartbeatInterval");u(this,"pingIntervalMs");u(this,"abortController");u(this,"timeout");u(this,"abortConnectionOnPingFailure");u(this,k4,"@libp2p/connection-monitor");u(this,_4,["@libp2p/connection-monitor"]);this.components=t,this.protocol=`/${e.protocolPrefix??GL}/${KL}/${WL}`,this.log=t.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=e.pingInterval??qL,this.abortConnectionOnPingFailure=e.abortConnectionOnPingFailure??QL,this.timeout=new Qa({...e.pingTimeout??{},metrics:t.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(t=>{Promise.resolve().then(async()=>{var r;let e=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(r=this.abortController)==null?void 0:r.signal}),i=await t.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=Xl(i);e=Date.now(),await Promise.all([o.write(Es(n3),{signal:s}),o.read(n3,{signal:s})]),t.rtt=Date.now()-e,await o.unwrap().close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;t.rtt=(Date.now()-e)/2}}).catch(e=>{this.log.error("error during heartbeat",e),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),t.abort(e)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var t;(t=this.abortController)==null||t.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var I4;I4=Symbol.toStringTag;class XL{constructor(t,e){u(this,"routers");u(this,"started");u(this,"components");u(this,I4,"@libp2p/content-routing");var r,s,i,o,a;this.routers=e.routers??[],this.started=!1,this.components=t,this.findProviders=((r=t.metrics)==null?void 0:r.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()}),getAttributesFromYieldedValue:(c,l)=>({...l,providers:[...Array.isArray(l.providers)?l.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=t.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],l)=>({...l,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=t.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:Z(c,"base36")})}))??this.put,this.get=((a=t.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:Z(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(t,e={}){if(this.routers.length===0)throw new wd("No content routers available");const r=this,s=new $r;for await(const i of us(...r.routers.map(o=>o.findProviders(t,e))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(t,e={}){if(this.routers.length===0)throw new wd("No content routers available");await Promise.all(this.routers.map(async r=>{await r.provide(t,e)}))}async cancelReprovide(t,e={}){if(this.routers.length===0)throw new wd("No content routers available");await Promise.all(this.routers.map(async r=>{await r.cancelReprovide(t,e)}))}async put(t,e,r){if(!this.isStarted())throw new bo;await Promise.all(this.routers.map(async s=>{await s.put(t,e,r)}))}async get(t,e){if(!this.isStarted())throw new bo;return Promise.any(this.routers.map(async r=>r.get(t,e)))}}var A4;A4=Symbol.toStringTag;class ZL{constructor(t,e={}){u(this,"log");u(this,"peerId");u(this,"peerStore");u(this,"routers");u(this,A4,"@libp2p/peer-routing");var r,s;this.log=t.logger.forComponent("libp2p:peer-routing"),this.peerId=t.peerId,this.peerStore=t.peerStore,this.routers=e.routers??[],this.findPeer=((r=t.metrics)==null?void 0:r.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:Z(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(t,e){if(this.routers.length===0)throw new Qp("No peer routers available");if(t.toString()===this.peerId.toString())throw new WN("Should not try to find self");const r=this,s=us(...this.routers.map(i=>async function*(){try{yield await i.findPeer(t,e)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new Nt}async*getClosestPeers(t,e={}){if(this.routers.length===0)throw new Qp("No peer routers available");const r=this,s=hi(1024);for await(const i of Rs(async function*(){const o=us(...r.routers.map(a=>a.getClosestPeers(t,e)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await r.findPeer(a.id,{...e,useCache:!1})}catch(c){r.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}var T4,C4;class JL extends(C4=Et,T4=Symbol.toStringTag,C4){constructor(e){super();u(this,"peerRouting");u(this,"log");u(this,"walking");u(this,"walkers");u(this,"shutdownController");u(this,"walkController");u(this,"needNext");u(this,T4,"@libp2p/random-walk");this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){var s,i;this.walking||this.startWalk(),this.walkers++;const r=Ne([this.shutdownController.signal,e==null?void 0:e.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=me(),yield(await _r(this,"walk:peer",r,{errorEvent:"walk:error"})).detail}finally{r.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Ne([this.walkController.signal,this.shutdownController.signal]),r=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Es(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await fr(this.needNext.promise,e)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-r),this.walking=!1})}}const P9=32,D9=64;var P4;P4=Symbol.toStringTag;class jL{constructor(t){u(this,"log");u(this,"topologies");u(this,"handlers");u(this,"components");u(this,P4,"@libp2p/registrar");this.log=t.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=t,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(t){const e=this.handlers.get(t);if(e==null)throw new KN(`No handler registered for protocol ${t}`);return e}getTopologies(t){const e=this.topologies.get(t);return e==null?[]:[...e.values()]}async handle(t,e,r){if(this.handlers.has(t)&&(r==null?void 0:r.force)!==!0)throw new GN(`Handler already registered for protocol ${t}`);const s=Gr.bind({ignoreUndefined:!0})({maxInboundStreams:P9,maxOutboundStreams:D9},r);this.handlers.set(t,{handler:e,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[t]})}async unhandle(t){(Array.isArray(t)?t:[t]).forEach(r=>{this.handlers.delete(r)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(t,e){if(e==null)throw new W("invalid topology");const r=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(t);return s==null&&(s=new Map,this.topologies.set(t,s)),s.set(r,e),r}unregister(t){for(const[e,r]of this.topologies.entries())r.has(t)&&(r.delete(t),r.size===0&&this.topologies.delete(e))}_onDisconnect(t){const e=t.detail;this.components.peerStore.get(e).then(r=>{var s,i,o;for(const a of r.protocols){const c=this.topologies.get(a);if(c!=null)for(const l of c.values())((s=l.filter)==null?void 0:s.has(e))!==!1&&((i=l.filter)==null||i.remove(e),(o=l.onDisconnect)==null||o.call(l,e))}}).catch(r=>{r.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",e,r)})}_onPeerUpdate(t){var i,o,a;const{peer:e,previous:r}=t.detail,s=((r==null?void 0:r.protocols)??[]).filter(c=>!e.protocols.includes(c));for(const c of s){const l=this.topologies.get(c);if(l!=null)for(const h of l.values())((i=h.filter)==null?void 0:i.has(e.id))!==!1&&((o=h.filter)==null||o.remove(e.id),(a=h.onDisconnect)==null||a.call(h,e.id))}}_onPeerIdentify(t){var i,o,a;const e=t.detail.protocols,r=t.detail.connection,s=t.detail.peerId;for(const c of e){const l=this.topologies.get(c);if(l!=null)for(const h of l.values())r.limits!=null&&h.notifyOnLimitedConnection!==!0||((i=h.filter)==null?void 0:i.has(s))!==!0&&((o=h.filter)==null||o.add(s),(a=h.onConnect)==null||a.call(h,s,r))}}}var D4;D4=Symbol.toStringTag;class eO{constructor(t,e={}){u(this,"log");u(this,"components");u(this,"transports");u(this,"listeners");u(this,"faultTolerance");u(this,"started");u(this,D4,"@libp2p/transport-manager");this.log=t.logger.forComponent("libp2p:transports"),this.components=t,this.started=!1,this.transports=new Map,this.listeners=Y5({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=e.faultTolerance??Ca.FATAL_ALL}add(t){const e=t[Symbol.toStringTag];if(e==null)throw new W("Transport must have a valid tag");if(this.transports.has(e))throw new W(`There is already a transport with the tag ${e}`);this.log("adding transport %s",e),this.transports.set(e,t),this.listeners.has(e)||this.listeners.set(e,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const t=this.components.addressManager.getListenAddrs();await this.listen(t)}async stop(){const t=[];for(const[e,r]of this.listeners)for(this.log("closing listeners for %s",e);r.length>0;){const s=r.pop();s!=null&&t.push(s.close())}await Promise.all(t),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(t,e){var s;const r=this.dialTransportForMultiaddr(t);if(r==null)throw new jN(`No transport available for address ${String(t)}`);return(s=e==null?void 0:e.onProgress)==null||s.call(e,new se("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(t,{...e,upgrader:this.components.upgrader})}getAddrs(){let t=[];for(const e of this.listeners.values())for(const r of e)t=[...t,...r.getAddrs()];return t}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(t){for(const e of this.transports.values())if(e.dialFilter([t]).length>0)return e}listenTransportForMultiaddr(t){for(const e of this.transports.values())if(e.listenFilter([t]).length>0)return e}async listen(t){if(!this.isStarted())throw new bo("Not started");if(t==null||t.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const e={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};t.forEach(i=>{e.errors.set(i.toString(),new QN)});const r=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(t);for(const c of a){this.log("creating listener for %s on %a",i,c);const l=o.createListener({upgrader:this.components.upgrader});let h=this.listeners.get(i)??[];h==null&&(h=[],this.listeners.set(i,h)),h.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=h.findIndex(f=>f===l);h.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),cg.matches(c)?e.ipv4.attempts++:lg.matches(c)&&e.ipv6.attempts++,r.push(l.listen(c).then(()=>{e.errors.delete(c.toString()),cg.matches(c)&&e.ipv4.success++,lg.matches(c)&&e.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),e.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(r);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(e)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Ca.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new YN(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...e.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(t){if(t.ipv4.attempts===0||t.ipv6.attempts===0)return!1;const e=t.ipv4.attempts===t.ipv4.success,r=t.ipv6.success===0;return e&&r}async remove(t){const e=this.listeners.get(t)??[];this.log.trace("removing transport %s",t);const r=[];for(this.log.trace("closing listeners for %s",t);e.length>0;){const s=e.pop();s!=null&&r.push(s.close())}await Promise.all(r),this.transports.delete(t),this.listeners.delete(t)}async removeAll(){const t=[];for(const e of this.transports.keys())t.push(this.remove(e));await Promise.all(t)}}const Jt="/multistream/1.0.0",F0=1024,tO=Y(`
`);async function wa(n,t,e){await n.write(t,e)}async function rO(n,t,e){await n.writeV(t,e)}async function nO(n,t){const e=await n.read(t);if(e.byteLength===0||e.get(e.byteLength-1)!==tO[0])throw t.log.error("Invalid mss message - missing newline",e),new We("Missing newline");return e.sublist(0,-1)}async function io(n,t){const e=await nO(n,t);return Z(e.subarray())}async function xd(n,t,e){if(t=Array.isArray(t)?[...t]:[t],t.length===1&&e.negotiateFully===!1)return sO(n,t[0],e);const r=Do(n,{...e,maxDataLength:F0}),s=t.shift();if(s==null)throw new Error("At least one protocol must be specified");e.log.trace('select: write ["%s", "%s"]',Jt,s);const i=Y(`${Jt}
`),o=Y(`${s}
`);await rO(r,[i,o],e),e.log.trace("select: reading multistream-select header");let a=await io(r,e);if(e.log.trace('select: read "%s"',a),a===Jt&&(e.log.trace("select: reading protocol response"),a=await io(r,e),e.log.trace('select: read "%s"',a)),a===s)return{stream:r.unwrap(),protocol:s};for(const c of t){e.log.trace('select: write "%s"',c),await wa(r,Y(`${c}
`),e),e.log.trace("select: reading protocol response");const l=await io(r,e);if(e.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:r.unwrap(),protocol:c}}throw new ic("protocol selection failed")}function sO(n,t,e){const r=n.sink.bind(n),s=n.source;let i=!1,o=!1;const a=me();let c=!1,l=!1;const h=me();let d=!1,f=!1;const g=me(),y=Do({sink:r,source:s},{...e,maxDataLength:F0});n.sink=async x=>{const{sink:S}=y.unwrap();await S(async function*(){let I=!1;for await(const P of x){if(l&&await h.promise,c)yield P;else{l=!0,e.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Jt,t,P.byteLength);const A=`${t}
`;yield new ye(Uint8Array.from([19]),Y(`${Jt}
`),Lt(A.length),Y(A),P).subarray(),e.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Jt,t,P.byteLength),c=!0,l=!1,h.resolve(),p().catch(C=>{e.log.error("could not finish optimistic protocol negotiation of %s",t,C)})}I=!0}I||await p()}())};async function p(){if(o){e.log.trace("optimistic: already negotiating %s stream",t),await a.promise;return}o=!0;try{c||(e.log.trace("optimistic: doing send protocol for %s stream",t),await w()),d||(e.log.trace("optimistic: doing read protocol for %s stream",t),await v())}finally{o=!1,i=!0,a.resolve()}}async function w(){if(l){await h.promise;return}l=!0;try{e.log.trace('optimistic: write ["%s", "%s", data] in source',Jt,t),await y.writeV([Y(`${Jt}
`),Y(`${t}
`)]),e.log.trace('optimistic: wrote ["%s", "%s", data] in source',Jt,t)}finally{c=!0,l=!1,h.resolve()}}async function v(){if(f){await g.promise;return}f=!0;try{e.log.trace("optimistic: reading multistream select header");let x=await io(y,e);if(e.log.trace('optimistic: read multistream select header "%s"',x),x===Jt&&(x=await io(y,e)),e.log.trace('optimistic: read protocol "%s", expecting "%s"',x,t),x!==t)throw new ic("protocol selection failed")}finally{d=!0,f=!1,g.resolve()}}if(n.source=async function*(){await p(),e.log.trace('optimistic: reading data from "%s" stream',t),yield*y.unwrap().source}(),n.closeRead!=null){const x=n.closeRead.bind(n);n.closeRead=async S=>{i||await p().catch(I=>{e.log.error("could not negotiate protocol before close read",I)}),await x(S)}}if(n.closeWrite!=null){const x=n.closeWrite.bind(n);n.closeWrite=async S=>{i||await p().catch(I=>{e.log.error("could not negotiate protocol before close write",I)}),await x(S)}}if(n.close!=null){const x=n.close.bind(n);n.close=async S=>{const I=[];l&&I.push(h.promise),f&&I.push(g.promise),I.length>0?await fr(Promise.all(I),S==null?void 0:S.signal):(i=!0,o=!1,a.resolve()),await x(S)}}return{stream:n,protocol:t}}async function _d(n,t,e){t=Array.isArray(t)?t:[t],e.log.trace("handle: available protocols %s",t);const r=Do(n,{...e,maxDataLength:F0,maxLengthLength:2});for(;;){e.log.trace("handle: reading incoming string");const s=await io(r,e);if(e.log.trace('handle: read "%s"',s),s===Jt){e.log.trace('handle: respond with "%s" for "%s"',Jt,s),await wa(r,Y(`${Jt}
`),e),e.log.trace('handle: responded with "%s" for "%s"',Jt,s);continue}if(t.includes(s))return e.log.trace('handle: respond with "%s" for "%s"',s,s),await wa(r,Y(`${s}
`),e),e.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:r.unwrap(),protocol:s};if(s==="ls"){const i=new ye(...t.map(o=>vo.single(Y(`${o}
`))),Y(`
`));e.log.trace('handle: respond with "%s" for %s',t,s),await wa(r,i,e),e.log.trace('handle: responded with "%s" for %s',t,s);continue}e.log.trace('handle: respond with "na" for "%s"',s),await wa(r,Y(`na
`),e),e.log('handle: responded with "na" for "%s"',s)}}const iO=500;var R4,B4;B4=Symbol.toStringTag,R4=My;class oO{constructor(t){u(this,"id");u(this,"remoteAddr");u(this,"remotePeer");u(this,"direction");u(this,"timeline");u(this,"multiplexer");u(this,"encryption");u(this,"status");u(this,"limits");u(this,"log");u(this,"tags");u(this,"_newStream");u(this,"_close");u(this,"_abort");u(this,"_getStreams");u(this,B4,"Connection");u(this,R4,!0);const{remoteAddr:e,remotePeer:r,newStream:s,close:i,abort:o,getStreams:a}=t;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=e,this.remotePeer=r,this.direction=t.direction,this.status="open",this.timeline=t.timeline,this.multiplexer=t.multiplexer,this.encryption=t.encryption,this.limits=t.limits,this.log=t.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}get streams(){return this._getStreams()}async newStream(t,e){if(this.status==="closing")throw new K4("the connection is being closed");if(this.status==="closed")throw new af("the connection is closed");if(Array.isArray(t)||(t=[t]),this.limits!=null&&(e==null?void 0:e.runOnLimitedConnection)!==!0)throw new uf("Cannot open protocol stream on limited connection");const r=await this._newStream(t,e);return r.direction="outbound",r}async close(t={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",t.signal==null){const e=AbortSignal.timeout(iO);t={...t,signal:e}}try{this.log.trace("closing underlying transport"),await this._close(t),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(e){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,e),this.abort(e)}}}abort(t){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,t),this.status="closing",this._abort(t),this.status="closed",this.timeline.close=Date.now())}}function aO(n){return new oO(n)}function cO(n,t){try{const{options:e}=t.getHandler(n);return e.maxInboundStreams}catch(e){if(e.name!=="UnhandledProtocolError")throw e}return P9}function lO(n,t,e={}){try{const{options:r}=t.getHandler(n);if(r.maxOutboundStreams!=null)return r.maxOutboundStreams}catch(r){if(r.name!=="UnhandledProtocolError")throw r}return e.maxOutboundStreams??D9}function s3(n,t,e){let r=0;return e.streams.forEach(s=>{s.direction===t&&s.protocol===n&&r++}),r}var M4;M4=Symbol.toStringTag;class uO{constructor(t,e){u(this,"components");u(this,"connectionEncrypters");u(this,"streamMuxers");u(this,"inboundUpgradeTimeout");u(this,"inboundStreamProtocolNegotiationTimeout");u(this,"outboundStreamProtocolNegotiationTimeout");u(this,"events");u(this,"metrics");u(this,M4,"@libp2p/upgrader");var r,s;this.components=t,this.connectionEncrypters=new Map,e.connectionEncrypters.forEach(i=>{this.connectionEncrypters.set(i.protocol,i)}),this.streamMuxers=new Map,e.streamMuxers.forEach(i=>{this.streamMuxers.set(i.protocol,i)}),this.inboundUpgradeTimeout=e.inboundUpgradeTimeout??fL,this.inboundStreamProtocolNegotiationTimeout=e.inboundStreamProtocolNegotiationTimeout??Xp,this.outboundStreamProtocolNegotiationTimeout=e.outboundStreamProtocolNegotiationTimeout??Xp,this.events=t.events,this.metrics={dials:(r=t.metrics)==null?void 0:r.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=t.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}async shouldBlockConnection(t,...e){const r=this.components.connectionGater[t];if(r==null)return;if(await r.apply(this.components.connectionGater,e)===!0)throw new ZN(`The multiaddr connection is blocked by gater.${t}`)}createInboundAbortSignal(t){return Ne([AbortSignal.timeout(this.inboundUpgradeTimeout),t])}async upgradeInbound(t,e){var i,o;let r=!1;const s=this.createInboundAbortSignal(e.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),r=await this.components.connectionManager.acceptIncomingConnection(t),!r)throw new JN("Connection denied");await this.shouldBlockConnection("denyInboundConnection",t),await this._performUpgrade(t,"inbound",{...e,signal:s})}catch(a){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),a}finally{s.clear(),r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(t,e){var r,s;try{(r=this.metrics.dials)==null||r.increment({outbound:!0});const i=t.remoteAddr.getPeerId();let o;i!=null&&(o=ut(i),await this.shouldBlockConnection("denyOutboundConnection",o,t));let a="outbound";return e.initiator===!1&&(a="inbound"),await this._performUpgrade(t,a,e)}catch(i){throw(s=this.metrics.errors)==null||s.increment({outbound:!0}),i}}async _performUpgrade(t,e,r){var h,d,f;let s,i,o,a,c;(h=this.components.metrics)==null||h.trackMultiaddrConnection(t),t.log.trace("starting the %s connection upgrade",e);let l=t;if((r==null?void 0:r.skipProtection)!==!0){const g=this.components.connectionProtector;g!=null&&(t.log("protecting the %s connection",e),l=await g.protect(t,r))}try{if(s=l,(r==null?void 0:r.skipEncryption)!==!0){(d=r==null?void 0:r.onProgress)==null||d.call(r,new se(`upgrader:encrypt-${e}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(e==="inbound"?this._encryptInbound(l,r):this._encryptOutbound(l,r));const g={...l,...s};await this.shouldBlockConnection(e==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,g)}else{const g=t.remoteAddr.getPeerId();if(g==null)throw new Tu(`${e} connection that skipped encryption must have a peer id`);const y=ut(g);c="native",i=y}if(i.equals(this.components.peerId)){const g=new lf("Can not dial self");throw t.abort(g),g}if(o=s,(r==null?void 0:r.muxerFactory)!=null)a=r.muxerFactory;else if(a==null&&this.streamMuxers.size>0){(f=r==null?void 0:r.onProgress)==null||f.call(r,new se(`upgrader:multiplex-${e}-connection`));const g=await(e==="inbound"?this._multiplexInbound({...l,...s},this.streamMuxers,r):this._multiplexOutbound({...l,...s},this.streamMuxers,r));a=g.muxerFactory,o=g.stream}}catch(g){throw t.log.error("failed to upgrade inbound connection %s %a - %e",e==="inbound"?"from":"to",t.remoteAddr,g),g}return await this.shouldBlockConnection(e==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,t),t.log("successfully upgraded %s connection",e),this._createConnection({cryptoProtocol:c,direction:e,maConn:t,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:r==null?void 0:r.limits})}_createConnection(t){const{cryptoProtocol:e,direction:r,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=t;let l,h,d;a!=null&&(l=a.createStreamMuxer({direction:r,onIncomingStream:y=>{d!=null&&Promise.resolve().then(async()=>{var P;const p=this.components.registrar.getProtocols(),w=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:v,protocol:x}=await _d(y,p,{signal:w,log:y.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",x);const S=cO(x,this.components.registrar);if(s3(x,"inbound",d)===S){const A=new X4(`Too many inbound protocol streams for protocol "${x}" - limit ${S}`);throw y.abort(A),A}y.source=v.source,y.sink=v.sink,y.protocol=x,v.closeWrite!=null&&(y.closeWrite=v.closeWrite),v.closeRead!=null&&(y.closeRead=v.closeRead),v.close!=null&&(y.close=v.close),await this.components.peerStore.merge(o,{protocols:[x]}),(P=this.components.metrics)==null||P.trackProtocolStream(y,d),this._onStream({connection:d,stream:y,protocol:x})}).catch(async p=>{d.log.error("error handling incoming stream id %s - %e",y.id,p),y.timeline.close==null&&await y.close()})}}),h=async(y,p={})=>{var v;if(l==null)throw new Jc("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",y);const w=await l.newStream();d.log.trace("started new stream %s for protocols %s",w.id,y);try{if(p.signal==null){w.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",y);const A=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);p={...p,signal:A}}w.log.trace("selecting protocol from protocols %s",y);const{stream:x,protocol:S}=await xd(w,y,{...p,log:w.log,yieldBytes:!0});w.log.trace("selected protocol %s",S);const I=lO(S,this.components.registrar,p),P=s3(S,"outbound",d);if(P>=I){const A=new Du(`Too many outbound protocol streams for protocol "${S}" - ${P}/${I}`);throw w.abort(A),A}return await this.components.peerStore.merge(o,{protocols:[S]}),w.source=x.source,w.sink=x.sink,w.protocol=S,x.closeWrite!=null&&(w.closeWrite=x.closeWrite),x.closeRead!=null&&(w.closeRead=x.closeRead),x.close!=null&&(w.close=x.close),(v=this.components.metrics)==null||v.trackProtocolStream(w,d),w}catch(x){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",r==="inbound"?"from":"to",t.maConn.remoteAddr,y,x),w.timeline.close==null&&w.abort(x),x}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(y=>{d.log.error("error piping data through muxer - %e",y)}));const f=s.timeline;s.timeline=new Proxy(f,{set:(...y)=>(y[1]==="close"&&y[2]!=null&&f.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(p){d.log.error("error closing connection after timeline close %e",p)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(p=>{d.log.error("error thrown while dispatching connection:close event %e",p)}),Reflect.set(...y))}),s.timeline.upgraded=Date.now();const g=()=>{throw new Jc("Connection is not multiplexed")};return d=aO({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:r,timeline:s.timeline,multiplexer:l==null?void 0:l.protocol,encryption:e,limits:c,logger:this.components.logger,newStream:h??g,getStreams:()=>(l==null?void 0:l.streams)??[],close:async y=>{await(l==null?void 0:l.close(y)),await s.close(y)},abort:y=>{s.abort(y),l==null||l.abort(y)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=f,d}_onStream(t){const{connection:e,stream:r,protocol:s}=t,{handler:i,options:o}=this.components.registrar.getHandler(s);if(e.limits!=null&&o.runOnLimitedConnection!==!0)throw new uf("Cannot open protocol stream on limited connection");i({connection:e,stream:r})}async _encryptInbound(t,e){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await _d(t,r,{...e,log:t.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new jc(`no crypto module found for ${i}`);return t.log("encrypting inbound connection to %a using %s",t.remoteAddr,i),{...await o.secureInbound(s,e),protocol:i}}catch(s){throw t.log.error("encrypting inbound connection from %a failed",t.remoteAddr,s),new jc(s.message)}}async _encryptOutbound(t,e){const r=Array.from(this.connectionEncrypters.keys());try{t.log.trace("selecting encrypter from %s",r);const{stream:s,protocol:i}=await xd(t,r,{...e,log:t.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new jc(`no crypto module found for ${i}`);return t.log("encrypting outbound connection to %a using %s",t.remoteAddr,i),{...await o.secureOutbound(s,e),protocol:i}}catch(s){throw t.log.error("encrypting outbound connection to %a failed",t.remoteAddr,s),new jc(s.message)}}async _multiplexOutbound(t,e,r){const s=Array.from(e.keys());t.log("outbound selecting muxer %s",s);try{t.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await xd(t,s,{...r,log:t.log,yieldBytes:!0});t.log("selected %s as muxer protocol",o);const a=e.get(o);return{stream:i,muxerFactory:a}}catch(i){throw t.log.error("error multiplexing outbound connection",i),new Jc(String(i))}}async _multiplexInbound(t,e,r){const s=Array.from(e.keys());t.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await _d(t,s,{...r,log:t.log}),a=e.get(o);return{stream:i,muxerFactory:a}}catch(i){throw t.log.error("error multiplexing inbound connection",i),new Jc(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}var sc,H1;class hO extends Et{constructor(e){var h,d,f,g,y,p,w,v,x,S,I,P;super();ve(this,sc);u(this,"peerId");u(this,"peerStore");u(this,"contentRouting");u(this,"peerRouting");u(this,"metrics");u(this,"services");u(this,"logger");u(this,"status");u(this,"components");u(this,"log");this.status="stopped";const r=new Et,s=r.dispatchEvent.bind(r);r.dispatchEvent=A=>{const C=s(A),T=this.dispatchEvent(new CustomEvent(A.type,{detail:A.detail}));return C||T},this.peerId=e.peerId,this.logger=e.logger??Ku(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((h=e.nodeInfo)==null?void 0:h.name)??p9,o=((d=e.nodeInfo)==null?void 0:d.version)??g9,a=this.components=nL({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:o,userAgent:((f=e.nodeInfo)==null?void 0:f.userAgent)??m9(i,o)},logger:this.logger,events:r,datastore:e.datastore??new p0,connectionGater:uL(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",yN(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),a.events.addEventListener("peer:update",A=>{if(A.detail.previous==null){const C={id:A.detail.peer.id,multiaddrs:A.detail.peer.addresses.map(T=>T.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:C})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(a)),this.components.upgrader=new uO(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((A,C)=>this.configureComponent(`connection-encryption-${C}`,A(this.components))),streamMuxers:(e.streamMuxers??[]).map((A,C)=>this.configureComponent(`stream-muxers-${C}`,A(this.components))),inboundUpgradeTimeout:(g=e.connectionManager)==null?void 0:g.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:((y=e.connectionManager)==null?void 0:y.inboundStreamProtocolNegotiationTimeout)??((p=e.connectionManager)==null?void 0:p.protocolNegotiationTimeout),outboundStreamProtocolNegotiationTimeout:((w=e.connectionManager)==null?void 0:w.outboundStreamProtocolNegotiationTimeout)??((v=e.connectionManager)==null?void 0:v.protocolNegotiationTimeout)}),this.configureComponent("transportManager",new eO(this.components,e.transportManager)),this.configureComponent("connectionManager",new HL(this.components,e.connectionManager)),((x=e.connectionMonitor)==null?void 0:x.enabled)!==!1&&this.configureComponent("connectionMonitor",new YL(this.components,e.connectionMonitor)),this.configureComponent("registrar",new jL(this.components)),this.configureComponent("addressManager",new VN(this.components,e.addresses));const c=(e.peerRouters??[]).map((A,C)=>this.configureComponent(`peer-router-${C}`,A(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new ZL(this.components,{routers:c}));const l=(e.contentRouters??[]).map((A,C)=>this.configureComponent(`content-router-${C}`,A(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new XL(this.components,{routers:l})),this.configureComponent("randomWalk",new JL(this.components)),(e.peerDiscovery??[]).forEach((A,C)=>{this.configureComponent(`peer-discovery-${C}`,A(this.components)).addEventListener("peer",k=>{ie(this,sc,H1).call(this,k)})}),(S=e.transports)==null||S.forEach((A,C)=>{this.components.transportManager.add(this.configureComponent(`transport-${C}`,A(this.components)))}),e.services!=null)for(const A of Object.keys(e.services)){const C=e.services[A],T=C(this.components);if(T==null){this.log.error("service factory %s returned null or undefined instance",A);continue}this.services[A]=T,this.configureComponent(A,T),T[yo]!=null&&(this.log("registering service %s for content routing",A),l.push(T[yo])),T[wo]!=null&&(this.log("registering service %s for peer routing",A),c.push(T[wo])),T[El]!=null&&(this.log("registering service %s for peer discovery",A),(P=(I=T[El]).addEventListener)==null||P.call(I,"peer",k=>{ie(this,sc,H1).call(this,k)}))}sL(a)}configureComponent(e,r){return r==null&&this.log.error("component %s was null or undefined",e),this.components[e]=r,r}async start(){var e,r,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((r=(e=this.components).beforeStart)==null?void 0:r.call(e)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(o){throw this.log.error("An error occurred starting libp2p",o),this.status="started",await this.stop(),o}}}async stop(){var e,r,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((r=(e=this.components).beforeStop)==null?void 0:r.call(e)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new $r;for(const r of this.components.connectionManager.getConnections())e.add(r.remotePeer);return Array.from(e)}async dial(e,r={}){return this.components.connectionManager.openConnection(e,{priority:75,...r})}async dialProtocol(e,r,s={}){if(r==null)throw new W("no protocols were provided to open a stream");if(r=Array.isArray(r)?r:[r],r.length===0)throw new W("no protocols were provided to open a stream");return(await this.dial(e,s)).newStream(r,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,r={}){th(e)&&(e=ut(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,r)}async getPublicKey(e,r={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const a=await this.peerStore.get(e);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=ft([Y("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(s,r),o=ir(i);return await this.peerStore.patch(e,{publicKey:o}),o}async handle(e,r,s){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,r,s)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async r=>{await this.components.registrar.unhandle(r)}))}async register(e,r){return this.components.registrar.register(e,r)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,r={}){return this.components.connectionManager.isDialable(e,r)}}sc=new WeakSet,H1=function(e){const{detail:r}=e;if(r.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(r.id,{multiaddrs:r.multiaddrs}).catch(s=>{this.log.error(s)})};async function R9(n={}){n.privateKey??(n.privateKey=await G6("Ed25519"));const t=new hO({...await rN(n),peerId:CS(n.privateKey)});return n.start!==!1&&await t.start(),t}async function dO(n){const t=n.libp2p??{};t.privateKey==null&&n.datastore!=null&&(t.privateKey=await ZM(n.datastore,n.keychain));const e=XM(t);return e.datastore=e.datastore??n.datastore,await R9({...e,...t,start:!1})}async function fO(n={}){const t=n.datastore??new p0,e=n.blockstore??new M8;let r;gO(n.libp2p)?r=n.libp2p:r=await dO({...n,libp2p:{dns:n.dns,...n.libp2p,start:void 0},datastore:t});const s=new pT({...n,libp2p:r,datastore:t,blockstore:e,blockBrokers:n.blockBrokers??[SA(),mI()],routers:n.routers??[uT(r),cT()],metrics:r.metrics});return n.start!==!1&&await s.start(),s}function gO(n){return n==null?!1:["dial","dialProtocol","hangUp","handle","unhandle","getMultiaddrs","getProtocols"].every(e=>typeof n[e]=="function")}class pO{constructor(t){u(this,"components");this.components=t}async add(t,e={}){const r=Y(t),s=await(e.hasher??gt).digest(r),i=e.codec??xf,o=te.createV1(i.code,s);return await this.components.blockstore.put(o,r,e),o}async get(t,e={}){const r=await this.components.blockstore.get(t,e);return Z(r)}}function mO(n){return new pO(n)}class yO{constructor(t){u(this,"components");this.components=t}async add(t,e={}){const r=u6(t),s=await(e.hasher??gt).digest(r),i=te.createV1(Mu,s);return await this.components.blockstore.put(i,r,e),i}async get(t,e={}){const r=await this.components.blockstore.get(t,e);return Sf(r)}}function wO(n){return new yO(n)}function bO(n){return n[Symbol.asyncIterator]!=null}function B9(n,t=1){return t=Number(t),bO(n)?async function*(){let e=[];if(t<1&&(t=1),t!==Math.round(t))throw new Error("Batch size must be an integer");for await(const r of n)for(e.push(r);e.length>=t;)yield e.slice(0,t),e=e.slice(t);for(;e.length>0;)yield e.slice(0,t),e=e.slice(t)}():function*(){let e=[];if(t<1&&(t=1),t!==Math.round(t))throw new Error("Batch size must be an integer");for(const r of n)for(e.push(r);e.length>=t;)yield e.slice(0,t),e=e.slice(t);for(;e.length>0;)yield e.slice(0,t),e=e.slice(t)}()}async function*M9(n,t=1){for await(const e of B9(n,t)){const r=e.map(async s=>s().then(i=>({ok:!0,value:i}),i=>({ok:!1,err:i})));for(let s=0;s<r.length;s++){const i=await r[s];if(i.ok)yield i.value;else throw i.err}}}const vO=262144,N9=(n={})=>{const t=n.chunkSize??vO;return async function*(r){let s=new ye,i=0,o=!1;for await(const a of r)for(s.append(a),i+=a.length;i>=t;)if(yield s.slice(0,t),o=!0,t===s.length)s=new ye,i=0;else{const c=new ye;c.append(s.sublist(t)),s=c,i-=t}(!o||i>0)&&(yield s.subarray(0,i))}},qi=class qi extends Error{constructor(e="Invalid type"){super(e);u(this,"name",qi.name);u(this,"code",qi.code)}};u(qi,"name","InvalidTypeError"),u(qi,"code","ERR_INVALID_TYPE");let mu=qi;var rn;(function(n){(function(r){r.Raw="Raw",r.Directory="Directory",r.File="File",r.Metadata="Metadata",r.Symlink="Symlink",r.HAMTShard="HAMTShard"})(n.DataType||(n.DataType={}));let t;(function(r){r[r.Raw=0]="Raw",r[r.Directory=1]="Directory",r[r.File=2]="File",r[r.Metadata=3]="Metadata",r[r.Symlink=4]="Symlink",r[r.HAMTShard=5]="HAMTShard"})(t||(t={})),function(r){r.codec=()=>Ht(t)}(n.DataType||(n.DataType={}));let e;n.codec=()=>(e==null&&(e=de((r,s,i={})=>{if(i.lengthDelimited!==!1&&s.fork(),r.Type!=null&&(s.uint32(8),n.DataType.codec().encode(r.Type,s)),r.Data!=null&&(s.uint32(18),s.bytes(r.Data)),r.filesize!=null&&(s.uint32(24),s.uint64(r.filesize)),r.blocksizes!=null)for(const o of r.blocksizes)s.uint32(32),s.uint64(o);r.hashType!=null&&(s.uint32(40),s.uint64(r.hashType)),r.fanout!=null&&(s.uint32(48),s.uint64(r.fanout)),r.mode!=null&&(s.uint32(56),s.uint32(r.mode)),r.mtime!=null&&(s.uint32(66),yu.codec().encode(r.mtime,s)),i.lengthDelimited!==!1&&s.ldelim()},(r,s)=>{const i={blocksizes:[]},o=s==null?r.len:r.pos+s;for(;r.pos<o;){const a=r.uint32();switch(a>>>3){case 1:i.Type=n.DataType.codec().decode(r);break;case 2:i.Data=r.bytes();break;case 3:i.filesize=r.uint64();break;case 4:i.blocksizes.push(r.uint64());break;case 5:i.hashType=r.uint64();break;case 6:i.fanout=r.uint64();break;case 7:i.mode=r.uint32();break;case 8:i.mtime=yu.codec().decode(r,r.uint32());break;default:r.skipType(a&7);break}}return i})),e),n.encode=r=>he(r,n.codec()),n.decode=r=>ue(r,n.codec())})(rn||(rn={}));var yu;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.Seconds!=null&&(r.uint32(8),r.int64(e.Seconds)),e.FractionalNanoseconds!=null&&(r.uint32(21),r.fixed32(e.FractionalNanoseconds)),s.lengthDelimited!==!1&&r.ldelim()},(e,r)=>{const s={},i=r==null?e.len:e.pos+r;for(;e.pos<i;){const o=e.uint32();switch(o>>>3){case 1:s.Seconds=e.int64();break;case 2:s.FractionalNanoseconds=e.fixed32();break;default:e.skipType(o&7);break}}return s})),t),n.encode=e=>he(e,n.codec()),n.decode=e=>ue(e,n.codec())})(yu||(yu={}));var i3;(function(n){let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),e.MimeType!=null&&(r.uint32(10),r.string(e.MimeType)),s.lengthDelimited!==!1&&r.ldelim()},(e,r)=>{const s={},i=r==null?e.len:e.pos+r;for(;e.pos<i;){const o=e.uint32();switch(o>>>3){case 1:s.MimeType=e.string();break;default:e.skipType(o&7);break}}return s})),t),n.encode=e=>he(e,n.codec()),n.decode=e=>ue(e,n.codec())})(i3||(i3={}));const o3={Raw:"raw",Directory:"directory",File:"file",Metadata:"metadata",Symlink:"symlink",HAMTShard:"hamt-sharded-directory"},EO=["directory","hamt-sharded-directory"],a3=parseInt("0644",8),c3=parseInt("0755",8);let ke=class L9{constructor(t={type:"file"}){u(this,"type");u(this,"data");u(this,"blockSizes");u(this,"hashType");u(this,"fanout");u(this,"mtime");u(this,"_mode");u(this,"_originalMode");const{type:e,data:r,blockSizes:s,hashType:i,fanout:o,mtime:a,mode:c}=t;if(e!=null&&!Object.values(o3).includes(e))throw new mu("Type: "+e+" is not valid");this.type=e??"file",this.data=r,this.hashType=i,this.fanout=o,this.blockSizes=s??[],this._originalMode=0,this.mode=c,this.mtime=a}static unmarshal(t){const e=rn.decode(t),r=new L9({type:o3[e.Type!=null?e.Type.toString():"File"],data:e.Data,blockSizes:e.blocksizes,mode:e.mode,mtime:e.mtime!=null?{secs:e.mtime.Seconds??0n,nsecs:e.mtime.FractionalNanoseconds}:void 0,fanout:e.fanout});return r._originalMode=e.mode??0,r}set mode(t){t==null?this._mode=this.isDirectory()?c3:a3:this._mode=t&4095}get mode(){return this._mode}isDirectory(){return EO.includes(this.type)}addBlockSize(t){this.blockSizes.push(t)}removeBlockSize(t){this.blockSizes.splice(t,1)}fileSize(){if(this.isDirectory())return 0n;let t=0n;return this.blockSizes.forEach(e=>{t+=e}),this.data!=null&&(t+=BigInt(this.data.length)),t}marshal(){let t;switch(this.type){case"raw":t=rn.DataType.Raw;break;case"directory":t=rn.DataType.Directory;break;case"file":t=rn.DataType.File;break;case"metadata":t=rn.DataType.Metadata;break;case"symlink":t=rn.DataType.Symlink;break;case"hamt-sharded-directory":t=rn.DataType.HAMTShard;break;default:throw new mu(`Type: ${t} is not valid`)}let e=this.data;(this.data==null||this.data.length===0)&&(e=void 0);let r;this.mode!=null&&(r=this._originalMode&4294963200|(this.mode??0),r===a3&&!this.isDirectory()&&(r=void 0),r===c3&&this.isDirectory()&&(r=void 0));let s;return this.mtime!=null&&(s={Seconds:this.mtime.secs,FractionalNanoseconds:this.mtime.nsecs}),rn.encode({Type:t,Data:e,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:r,mtime:s})}};const $o=async(n,t,e)=>{e.codec==null&&(e.codec=dc);const r=await gt.digest(n),s=te.create(e.cidVersion,e.codec.code,r);return await t.put(s,n,e),s};function SO(n){return async function*(e,r){let s=0n;for await(let i of e.content)yield async()=>{var l;let o;const a={codec:dc,cidVersion:n.cidVersion,onProgress:n.onProgress};n.rawLeaves?(a.codec=xf,a.cidVersion=1):(o=new ke({type:n.leafType,data:i}),i=pt({Data:o.marshal(),Links:[]}));const c=await $o(i,r,a);return s+=BigInt(i.byteLength),(l=n.onProgress)==null||l.call(n,new se("unixfs:importer:progress:file:write",{bytesWritten:s,cid:c,path:e.path})),{cid:c,unixfs:o,size:BigInt(i.length),block:i}}}}var Dn;let xO=(Dn=class extends Error{constructor(e="Invalid parameters"){super(e);u(this,"name",Dn.name);u(this,"code",Dn.code)}},u(Dn,"name","InvalidParametersError"),u(Dn,"code","ERR_INVALID_PARAMS"),Dn);const Wi=class Wi extends Error{constructor(e="Invalid content"){super(e);u(this,"name",Wi.name);u(this,"code",Wi.code)}};u(Wi,"name","InvalidContentError"),u(Wi,"code","ERR_INVALID_CONTENT");let zo=Wi;const _O=async(n,t,e)=>{const r=new ke({type:"directory",mtime:n.mtime,mode:n.mode}),s=pt(gr({Data:r.marshal()})),i=await $o(s,t,e),o=n.path;return{cid:i,path:o,unixfs:r,size:BigInt(s.length),originalPath:n.originalPath,block:s}};async function*kO(n,t,e){let r=-1,s;for await(const i of M9(e.bufferImporter(n,t),e.blockWriteConcurrency)){if(r++,r===0){s={...i,single:!0};continue}else r===1&&s!=null&&(yield{...s,block:void 0,single:void 0},s=void 0);yield{...i,block:void 0}}s!=null&&(yield s)}function l3(n){return n.single===!0}const IO=(n,t,e)=>async function(s){var h,d;if(s.length===1&&l3(s[0])&&e.reduceSingleLeafToSelf){const f=s[0];let g=f.block;return l3(f)&&(n.mtime!==void 0||n.mode!==void 0)&&(f.unixfs=new ke({type:"file",mtime:n.mtime,mode:n.mode,data:f.block}),g={Data:f.unixfs.marshal(),Links:[]},f.block=pt(gr(g)),f.cid=await $o(f.block,t,{...e,cidVersion:e.cidVersion}),f.size=BigInt(f.block.length)),(h=e.onProgress)==null||h.call(e,new se("unixfs:importer:progress:file:layout",{cid:f.cid,path:f.originalPath})),{cid:f.cid,path:n.path,unixfs:f.unixfs,size:f.size,originalPath:f.originalPath}}const i=new ke({type:"file",mtime:n.mtime,mode:n.mode}),o=s.filter(f=>{var g,y;return f.cid.code===qr&&f.size>0||f.unixfs!=null&&f.unixfs.data==null&&f.unixfs.fileSize()>0n?!0:!!((y=(g=f.unixfs)==null?void 0:g.data)!=null&&y.length)}).map(f=>{var g,y;return f.cid.code===qr?(i.addBlockSize(f.size),{Name:"",Tsize:Number(f.size),Hash:f.cid}):(((g=f.unixfs)==null?void 0:g.data)==null?i.addBlockSize(((y=f.unixfs)==null?void 0:y.fileSize())??0n):i.addBlockSize(BigInt(f.unixfs.data.length)),{Name:"",Tsize:Number(f.size),Hash:f.cid})}),a={Data:i.marshal(),Links:o},c=pt(gr(a)),l=await $o(c,t,e);return(d=e.onProgress)==null||d.call(e,new se("unixfs:importer:progress:file:layout",{cid:l,path:n.originalPath})),{cid:l,path:n.path,unixfs:i,size:BigInt(c.length+a.Links.reduce((f,g)=>f+(g.Tsize??0),0)),originalPath:n.originalPath,block:c}},AO=async(n,t,e)=>e.layout(kO(n,t,e),IO(n,t,e));function TO(n){return Symbol.iterator in n}function CO(n){return Symbol.asyncIterator in n}function PO(n){try{if(n instanceof Uint8Array)return async function*(){yield n}();if(TO(n))return async function*(){yield*n}();if(CO(n))return n}catch{throw new zo("Content was invalid")}throw new zo("Content was invalid")}function DO(n){return async function*(e,r){for await(const s of e){let i;if(s.path!=null&&(i=s.path,s.path=s.path.split("/").filter(o=>o!=null&&o!==".").join("/")),RO(s)){const o={path:s.path,mtime:s.mtime,mode:s.mode,content:async function*(){var c;let a=0n;for await(const l of n.chunker(n.chunkValidator(PO(s.content)))){const h=BigInt(l.byteLength);a+=h,(c=n.onProgress)==null||c.call(n,new se("unixfs:importer:progress:file:read",{bytesRead:a,chunkSize:h,path:s.path})),yield l}}(),originalPath:i};yield async()=>AO(o,r,n)}else if(s.path!=null){const o={path:s.path,mtime:s.mtime,mode:s.mode,originalPath:i};yield async()=>_O(o,r,n)}else throw new Error("Import candidate must have content or path or both")}}}function RO(n){return n.content!=null}const BO=()=>async function*(t){for await(const e of t){if(e.length===void 0)throw new zo("Content was invalid");if(typeof e=="string"||e instanceof String)yield Y(e.toString());else if(Array.isArray(e))yield Uint8Array.from(e);else if(e instanceof Uint8Array)yield e;else throw new zo("Content was invalid")}},MO=174;function O9(n){const t=(n==null?void 0:n.maxChildrenPerNode)??MO;return async function e(r,s){const i=[];for await(const o of B9(r,t))i.push(await s(o));return i.length>1?e(i,s):i[0]}}let Za=class{constructor(t,e){u(this,"options");u(this,"root");u(this,"dir");u(this,"path");u(this,"dirty");u(this,"flat");u(this,"parent");u(this,"parentKey");u(this,"unixfs");u(this,"mode");u(this,"mtime");u(this,"cid");u(this,"size");u(this,"nodeSize");this.options=e??{},this.root=t.root,this.dir=t.dir,this.path=t.path,this.dirty=t.dirty,this.flat=t.flat,this.parent=t.parent,this.parentKey=t.parentKey,this.unixfs=t.unixfs,this.mode=t.mode,this.mtime=t.mtime}};const q1=te.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"),W1=te.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");class U0 extends Za{constructor(e,r){super(e,r);u(this,"_children");this._children=new Map}async put(e,r){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,this._children.set(e,r)}async get(e){return Promise.resolve(this._children.get(e))}childCount(){return this._children.size}directChildrenCount(){return this.childCount()}onlyChild(){return this._children.values().next().value}async*eachChildSeries(){for(const[e,r]of this._children.entries())yield{key:e,child:r}}estimateNodeSize(){if(this.nodeSize!==void 0)return this.nodeSize;this.nodeSize=0;for(const[e,r]of this._children.entries())r.size!=null&&r.cid!=null&&(this.nodeSize+=e.length+(this.options.cidVersion===1?W1.bytes.byteLength:q1.bytes.byteLength));return this.nodeSize}async*flush(e){const r=[];for(const[l,h]of this._children.entries()){let d=h;if(h instanceof Za)for await(const f of h.flush(e))d=f,yield f;d.size!=null&&d.cid!=null&&r.push({Name:l,Tsize:Number(d.size),Hash:d.cid})}const s=new ke({type:"directory",mtime:this.mtime,mode:this.mode}),i={Data:s.marshal(),Links:r},o=pt(gr(i)),a=await $o(o,e,this.options),c=o.length+i.Links.reduce((l,h)=>l+(h.Tsize??0),0);this.cid=a,this.size=c,yield{cid:a,unixfs:s,path:this.path,size:BigInt(c)}}}var tl={exports:{}},u3;function NO(){return u3||(u3=1,function(n,t){(function(e,r){var s={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function i(p){if(!Array.isArray(p)&&!ArrayBuffer.isView(p))return!1;for(var w=0;w<p.length;w++)if(!Number.isInteger(p[w])||p[w]<0||p[w]>255)return!1;return!0}function o(p,w){return(p&65535)*w+(((p>>>16)*w&65535)<<16)}function a(p,w){return p<<w|p>>>32-w}function c(p){return p^=p>>>16,p=o(p,2246822507),p^=p>>>13,p=o(p,3266489909),p^=p>>>16,p}function l(p,w){p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535],w=[w[0]>>>16,w[0]&65535,w[1]>>>16,w[1]&65535];var v=[0,0,0,0];return v[3]+=p[3]+w[3],v[2]+=v[3]>>>16,v[3]&=65535,v[2]+=p[2]+w[2],v[1]+=v[2]>>>16,v[2]&=65535,v[1]+=p[1]+w[1],v[0]+=v[1]>>>16,v[1]&=65535,v[0]+=p[0]+w[0],v[0]&=65535,[v[0]<<16|v[1],v[2]<<16|v[3]]}function h(p,w){p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535],w=[w[0]>>>16,w[0]&65535,w[1]>>>16,w[1]&65535];var v=[0,0,0,0];return v[3]+=p[3]*w[3],v[2]+=v[3]>>>16,v[3]&=65535,v[2]+=p[2]*w[3],v[1]+=v[2]>>>16,v[2]&=65535,v[2]+=p[3]*w[2],v[1]+=v[2]>>>16,v[2]&=65535,v[1]+=p[1]*w[3],v[0]+=v[1]>>>16,v[1]&=65535,v[1]+=p[2]*w[2],v[0]+=v[1]>>>16,v[1]&=65535,v[1]+=p[3]*w[1],v[0]+=v[1]>>>16,v[1]&=65535,v[0]+=p[0]*w[3]+p[1]*w[2]+p[2]*w[1]+p[3]*w[0],v[0]&=65535,[v[0]<<16|v[1],v[2]<<16|v[3]]}function d(p,w){return w%=64,w===32?[p[1],p[0]]:w<32?[p[0]<<w|p[1]>>>32-w,p[1]<<w|p[0]>>>32-w]:(w-=32,[p[1]<<w|p[0]>>>32-w,p[0]<<w|p[1]>>>32-w])}function f(p,w){return w%=64,w===0?p:w<32?[p[0]<<w|p[1]>>>32-w,p[1]<<w]:[p[1]<<w-32,0]}function g(p,w){return[p[0]^w[0],p[1]^w[1]]}function y(p){return p=g(p,[0,p[0]>>>1]),p=h(p,[4283543511,3981806797]),p=g(p,[0,p[0]>>>1]),p=h(p,[3301882366,444984403]),p=g(p,[0,p[0]>>>1]),p}s.x86.hash32=function(p,w){if(s.inputValidation&&!i(p))return r;w=w||0;for(var v=p.length%4,x=p.length-v,S=w,I=0,P=3432918353,A=461845907,C=0;C<x;C=C+4)I=p[C]|p[C+1]<<8|p[C+2]<<16|p[C+3]<<24,I=o(I,P),I=a(I,15),I=o(I,A),S^=I,S=a(S,13),S=o(S,5)+3864292196;switch(I=0,v){case 3:I^=p[C+2]<<16;case 2:I^=p[C+1]<<8;case 1:I^=p[C],I=o(I,P),I=a(I,15),I=o(I,A),S^=I}return S^=p.length,S=c(S),S>>>0},s.x86.hash128=function(p,w){if(s.inputValidation&&!i(p))return r;w=w||0;for(var v=p.length%16,x=p.length-v,S=w,I=w,P=w,A=w,C=0,T=0,k=0,N=0,$=597399067,z=2869860233,q=951274213,U=2716044179,L=0;L<x;L=L+16)C=p[L]|p[L+1]<<8|p[L+2]<<16|p[L+3]<<24,T=p[L+4]|p[L+5]<<8|p[L+6]<<16|p[L+7]<<24,k=p[L+8]|p[L+9]<<8|p[L+10]<<16|p[L+11]<<24,N=p[L+12]|p[L+13]<<8|p[L+14]<<16|p[L+15]<<24,C=o(C,$),C=a(C,15),C=o(C,z),S^=C,S=a(S,19),S+=I,S=o(S,5)+1444728091,T=o(T,z),T=a(T,16),T=o(T,q),I^=T,I=a(I,17),I+=P,I=o(I,5)+197830471,k=o(k,q),k=a(k,17),k=o(k,U),P^=k,P=a(P,15),P+=A,P=o(P,5)+2530024501,N=o(N,U),N=a(N,18),N=o(N,$),A^=N,A=a(A,13),A+=S,A=o(A,5)+850148119;switch(C=0,T=0,k=0,N=0,v){case 15:N^=p[L+14]<<16;case 14:N^=p[L+13]<<8;case 13:N^=p[L+12],N=o(N,U),N=a(N,18),N=o(N,$),A^=N;case 12:k^=p[L+11]<<24;case 11:k^=p[L+10]<<16;case 10:k^=p[L+9]<<8;case 9:k^=p[L+8],k=o(k,q),k=a(k,17),k=o(k,U),P^=k;case 8:T^=p[L+7]<<24;case 7:T^=p[L+6]<<16;case 6:T^=p[L+5]<<8;case 5:T^=p[L+4],T=o(T,z),T=a(T,16),T=o(T,q),I^=T;case 4:C^=p[L+3]<<24;case 3:C^=p[L+2]<<16;case 2:C^=p[L+1]<<8;case 1:C^=p[L],C=o(C,$),C=a(C,15),C=o(C,z),S^=C}return S^=p.length,I^=p.length,P^=p.length,A^=p.length,S+=I,S+=P,S+=A,I+=S,P+=S,A+=S,S=c(S),I=c(I),P=c(P),A=c(A),S+=I,S+=P,S+=A,I+=S,P+=S,A+=S,("00000000"+(S>>>0).toString(16)).slice(-8)+("00000000"+(I>>>0).toString(16)).slice(-8)+("00000000"+(P>>>0).toString(16)).slice(-8)+("00000000"+(A>>>0).toString(16)).slice(-8)},s.x64.hash128=function(p,w){if(s.inputValidation&&!i(p))return r;w=w||0;for(var v=p.length%16,x=p.length-v,S=[0,w],I=[0,w],P=[0,0],A=[0,0],C=[2277735313,289559509],T=[1291169091,658871167],k=0;k<x;k=k+16)P=[p[k+4]|p[k+5]<<8|p[k+6]<<16|p[k+7]<<24,p[k]|p[k+1]<<8|p[k+2]<<16|p[k+3]<<24],A=[p[k+12]|p[k+13]<<8|p[k+14]<<16|p[k+15]<<24,p[k+8]|p[k+9]<<8|p[k+10]<<16|p[k+11]<<24],P=h(P,C),P=d(P,31),P=h(P,T),S=g(S,P),S=d(S,27),S=l(S,I),S=l(h(S,[0,5]),[0,1390208809]),A=h(A,T),A=d(A,33),A=h(A,C),I=g(I,A),I=d(I,31),I=l(I,S),I=l(h(I,[0,5]),[0,944331445]);switch(P=[0,0],A=[0,0],v){case 15:A=g(A,f([0,p[k+14]],48));case 14:A=g(A,f([0,p[k+13]],40));case 13:A=g(A,f([0,p[k+12]],32));case 12:A=g(A,f([0,p[k+11]],24));case 11:A=g(A,f([0,p[k+10]],16));case 10:A=g(A,f([0,p[k+9]],8));case 9:A=g(A,[0,p[k+8]]),A=h(A,T),A=d(A,33),A=h(A,C),I=g(I,A);case 8:P=g(P,f([0,p[k+7]],56));case 7:P=g(P,f([0,p[k+6]],48));case 6:P=g(P,f([0,p[k+5]],40));case 5:P=g(P,f([0,p[k+4]],32));case 4:P=g(P,f([0,p[k+3]],24));case 3:P=g(P,f([0,p[k+2]],16));case 2:P=g(P,f([0,p[k+1]],8));case 1:P=g(P,[0,p[k]]),P=h(P,C),P=d(P,31),P=h(P,T),S=g(S,P)}return S=g(S,[0,p.length]),I=g(I,[0,p.length]),S=l(S,I),I=l(I,S),S=y(S),I=y(I),S=l(S,I),I=l(I,S),("00000000"+(S[0]>>>0).toString(16)).slice(-8)+("00000000"+(S[1]>>>0).toString(16)).slice(-8)+("00000000"+(I[0]>>>0).toString(16)).slice(-8)+("00000000"+(I[1]>>>0).toString(16)).slice(-8)},n.exports&&(t=n.exports=s),t.murmurHash3=s})()}(tl,tl.exports)),tl.exports}var kd,h3;function LO(){return h3||(h3=1,kd=NO()),kd}var OO=LO();const FO=Fn(OO),uh=kf({name:"murmur3-128",code:34,encode:n=>Tw(FO.x64.hash128(n))});var Id,d3;function UO(){if(d3)return Id;d3=1;const n=7;Id=class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(o,a){let c=this._internalPositionFor(o,!1);if(a===void 0)c!==-1&&(this._unsetInternalPos(c),this._unsetBit(o),this._changedLength=!0,this._changedData=!0);else{let l=!1;c===-1?(c=this._data.length,this._setBit(o),this._changedData=!0):l=!0,this._setInternalPos(c,o,a,l),this._changedLength=!0}}unset(o){this.set(o,void 0)}get(o){this._sortData();const a=this._internalPositionFor(o,!0);if(a!==-1)return this._data[a][1]}push(o){return this.set(this.length,o),this.length}get length(){if(this._sortData(),this._changedLength){const o=this._data[this._data.length-1];this._length=o?o[0]+1:0,this._changedLength=!1}return this._length}forEach(o){let a=0;for(;a<this.length;)o(this.get(a),a,this),a++}map(o){let a=0,c=new Array(this.length);for(;a<this.length;)c[a]=o(this.get(a),a,this),a++;return c}reduce(o,a){let c=0,l=a;for(;c<this.length;){const h=this.get(c);l=o(l,h,c),c++}return l}find(o){let a=0,c,l;for(;a<this.length&&!c;)l=this.get(a),c=o(l),a++;return c?l:void 0}_internalPositionFor(o,a){const c=this._bytePosFor(o,a);if(c>=this._bitArrays.length)return-1;const l=this._bitArrays[c],h=o-c*n;if(!((l&1<<h)>0))return-1;const f=this._bitArrays.slice(0,c).reduce(t,0),g=~(4294967295<<h+1),y=e(l&g);return f+y-1}_bytePosFor(o,a){const c=Math.floor(o/n),l=c+1;for(;!a&&this._bitArrays.length<l;)this._bitArrays.push(0);return c}_setBit(o){const a=this._bytePosFor(o,!1);this._bitArrays[a]|=1<<o-a*n}_unsetBit(o){const a=this._bytePosFor(o,!1);this._bitArrays[a]&=~(1<<o-a*n)}_setInternalPos(o,a,c,l){const h=this._data,d=[a,c];if(l)this._sortData(),h[o]=d;else{if(h.length)if(h[h.length-1][0]>=a)h.push(d);else if(h[0][0]<=a)h.unshift(d);else{const f=Math.round(h.length/2);this._data=h.slice(0,f).concat(d).concat(h.slice(f))}else this._data.push(d);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(o){this._data.splice(o,1)}_sortData(){this._changedData&&this._data.sort(r),this._changedData=!1}bitField(){const o=[];let a=8,c=0,l=0,h;const d=this._bitArrays.slice();for(;d.length||c;){c===0&&(h=d.shift(),c=7);const g=Math.min(c,a),y=~(255<<g),p=h&y;l|=p<<8-a,h=h>>>g,c-=g,a-=g,(!a||!c&&!d.length)&&(o.push(l),l=0,a=8)}for(var f=o.length-1;f>0&&o[f]===0;f--)o.pop();return o}compactArray(){return this._sortData(),this._data.map(s)}};function t(i,o){return i+e(o)}function e(i){let o=i;return o=o-(o>>1&1431655765),o=(o&858993459)+(o>>2&858993459),(o+(o>>4)&252645135)*16843009>>24}function r(i,o){return i[0]-o[0]}function s(i){return i[1]}return Id}var $O=UO();const wu=Fn($O);class Ut{constructor(t,e,r=0){u(this,"_options");u(this,"_popCount");u(this,"_parent");u(this,"_posAtParent");u(this,"_children");u(this,"key");this._options=t,this._popCount=0,this._parent=e,this._posAtParent=r,this._children=new wu,this.key=null}async put(t,e){const r=await this._findNewBucketAndPos(t);r.bucket._putAt(r,t,e)}async get(t){const e=await this._findChild(t);if(e!=null)return e.value}async del(t){const e=await this._findPlace(t),r=e.bucket._at(e.pos);r!=null&&r.key===t&&e.bucket._delAt(e.pos)}leafCount(){return this._children.compactArray().reduce((e,r)=>r instanceof Ut?e+r.leafCount():e+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const t=this._children.compactArray();for(const e of t)e instanceof Ut?yield*e.eachLeafSeries():yield e}serialize(t,e){const r=[];return e(this._children.reduce((s,i,o)=>(i!=null&&(i instanceof Ut?s.push(i.serialize(t,e)):s.push(t(i,o))),s),r))}async asyncTransform(t,e){return F9(this,t,e)}toJSON(){return this.serialize(VO,HO)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(t){const e=await this._findPlace(t),r=e.bucket._at(e.pos);if(!(r instanceof Ut)&&r!=null&&r.key===t)return r}async _findPlace(t){const e=this._options.hash(typeof t=="string"?Y(t):t),r=await e.take(this._options.bits),s=this._children.get(r);return s instanceof Ut?s._findPlace(e):{bucket:this,pos:r,hash:e,existingChild:s}}async _findNewBucketAndPos(t){const e=await this._findPlace(t);if(e.existingChild!=null&&e.existingChild.key!==t){const r=new Ut(this._options,e.bucket,e.pos);e.bucket._putObjectAt(e.pos,r);const s=await r._findPlace(e.existingChild.hash);return s.bucket._putAt(s,e.existingChild.key,e.existingChild.value),r._findNewBucketAndPos(e.hash)}return e}_putAt(t,e,r){this._putObjectAt(t.pos,{key:e,value:r,hash:t.hash})}_putObjectAt(t,e){this._children.get(t)==null&&this._popCount++,this._children.set(t,e)}_delAt(t){if(t===-1)throw new Error("Invalid position");this._children.get(t)!=null&&this._popCount--,this._children.unset(t),this._level()}_level(){if(this._parent!=null&&this._popCount<=1)if(this._popCount===1){const t=this._children.find(zO);if(t!=null&&!(t instanceof Ut)){const e=t.hash;e.untake(this._options.bits);const r={pos:this._posAtParent,hash:e,bucket:this._parent};this._parent._putAt(r,t.key,t.value)}}else this._parent._delAt(this._posAtParent)}_at(t){return this._children.get(t)}}function zO(n){return!!n}function VO(n,t){return n.key}function HO(n){return n}async function F9(n,t,e){const r=[];for(const s of n._children.compactArray())if(s instanceof Ut)await F9(s,t,e);else{const i=await t(s);r.push({bitField:n._children.bitField(),children:i})}return e(r)}const qO=[255,254,252,248,240,224,192,128],WO=[1,3,7,15,31,63,127,255];let KO=class{constructor(t){u(this,"_value");u(this,"_currentBytePos");u(this,"_currentBitPos");this._value=t,this._currentBytePos=t.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(t){let e=t,r=0;for(;e>0&&this._haveBits();){const s=this._value[this._currentBytePos],i=this._currentBitPos+1,o=Math.min(i,e),a=GO(s,i-o,o);r=(r<<o)+a,e-=o,this._currentBitPos-=o,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return r}untake(t){for(this._currentBitPos+=t;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function GO(n,t,e){const r=QO(t,e);return(n&r)>>>t}function QO(n,t){return qO[n]&WO[Math.min(t+n-1,7)]}function YO(n){function t(e){return e instanceof f3?e:new f3(e,n)}return t}let f3=class{constructor(t,e){u(this,"_value");u(this,"_hashFn");u(this,"_depth");u(this,"_availableBits");u(this,"_currentBufferIndex");u(this,"_buffers");if(!(t instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=t,this._hashFn=e,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(t){let e=t;for(;this._availableBits<e;)await this._produceMoreBits();let r=0;for(;e>0;){const s=this._buffers[this._currentBufferIndex],i=Math.min(s.availableBits(),e),o=s.take(i);r=(r<<i)+o,e-=i,this._availableBits-=i,s.availableBits()===0&&this._currentBufferIndex++}return r}untake(t){let e=t;for(;e>0;){const r=this._buffers[this._currentBufferIndex],s=Math.min(r.totalBits()-r.availableBits(),e);r.untake(s),e-=s,this._availableBits+=s,this._currentBufferIndex>0&&r.totalBits()===r.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const t=this._depth>0?ft([this._value,Uint8Array.from([this._depth])]):this._value,e=await this._hashFn(t),r=new KO(e);this._buffers.push(r),this._availableBits+=r.availableBits()}};function $0(n){if(n==null||n.hashFn==null)throw new Error("please define an options.hashFn");const t={bits:n.bits??8,hash:YO(n.hashFn)};return new Ut(t)}async function XO(n){return(await uh.encode(n)).slice(0,8).reverse()}const U9=BigInt(34),ZO=8;let JO=class extends Za{constructor(e,r){super(e,r);u(this,"_bucket");this._bucket=$0({hashFn:XO,bits:r.shardFanoutBits??ZO})}async put(e,r){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,await this._bucket.put(e,r)}async get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:r}of this._bucket.eachLeafSeries())yield{key:e,child:r}}estimateNodeSize(){return this.nodeSize!==void 0?this.nodeSize:(this.nodeSize=z9(this._bucket,this,this.options),this.nodeSize)}async*flush(e){for await(const r of $9(this._bucket,e,this,this.options))yield{...r,path:this.path}}};async function*$9(n,t,e,r){const s=n._children,i=(n.tableSize()-1).toString(16).length,o=[];let a=0n;for(let y=0;y<s.length;y++){const p=s.get(y);if(p==null)continue;const w=y.toString(16).toUpperCase().padStart(i,"0");if(p instanceof Ut){let v;for await(const x of $9(p,t,null,r))v=x;if(v==null)throw new Error("Could not flush sharded directory, no subshard found");o.push({Name:w,Tsize:Number(v.size),Hash:v.cid}),a+=v.size}else if(jO(p.value)){const v=p.value;let x;for await(const I of v.flush(t))x=I,yield x;if(x==null)throw new Error("Did not flush dir");const S=w+p.key;o.push({Name:S,Tsize:Number(x.size),Hash:x.cid}),a+=x.size}else{const v=p.value;if(v.cid==null)continue;const x=w+p.key,S=v.size;o.push({Name:x,Tsize:Number(S),Hash:v.cid}),a+=BigInt(S??0)}}const c=Uint8Array.from(s.bitField().reverse()),l=new ke({type:"hamt-sharded-directory",data:c,fanout:BigInt(n.tableSize()),hashType:U9,mtime:e==null?void 0:e.mtime,mode:e==null?void 0:e.mode}),h={Data:l.marshal(),Links:o},d=pt(gr(h)),f=await $o(d,t,r),g=BigInt(d.byteLength)+a;yield{cid:f,unixfs:l,size:g}}function jO(n){return typeof n.flush=="function"}function z9(n,t,e){const r=n._children,s=(n.tableSize()-1).toString(16).length,i=[];for(let l=0;l<r.length;l++){const h=r.get(l);if(h==null)continue;const d=l.toString(16).toUpperCase().padStart(s,"0");if(h instanceof Ut){const f=z9(h,null,e);i.push({Name:d,Tsize:Number(f),Hash:e.cidVersion===0?q1:W1})}else if(typeof h.value.flush=="function"){const g=h.value.nodeSize();i.push({Name:d+h.key,Tsize:Number(g),Hash:e.cidVersion===0?q1:W1})}else{const f=h.value;if(f.cid==null)continue;const g=d+h.key,y=f.size;i.push({Name:g,Tsize:Number(y),Hash:f.cid})}}const o=Uint8Array.from(r.bitField().reverse()),a=new ke({type:"hamt-sharded-directory",data:o,fanout:BigInt(n.tableSize()),hashType:U9,mtime:t==null?void 0:t.mtime,mode:t==null?void 0:t.mode});return pt(gr({Data:a.marshal(),Links:i})).length}async function V9(n,t,e,r){let s=t;t instanceof U0&&t.estimateNodeSize()>e&&(s=await eF(t,r));const i=s.parent;if(i!=null){if(s!==t){if(n!=null&&(n.parent=s),s.parentKey==null)throw new Error("No parent key found");await i.put(s.parentKey,s)}return V9(s,i,e,r)}return s}async function eF(n,t){const e=new JO({root:n.root,dir:!0,parent:n.parent,parentKey:n.parentKey,path:n.path,dirty:n.dirty,flat:!1,mtime:n.mtime,mode:n.mode},t);for await(const{key:r,child:s}of n.eachChildSeries())await e.put(r,s);return e}const tF=(n="")=>n.split(new RegExp("(?<!\\\\)\\/")).filter(Boolean);async function rF(n,t,e){var a,c;const r=tF(n.path??""),s=r.length-1;let i=t,o="";for(let l=0;l<r.length;l++){const h=r[l];o+=`${o!==""?"/":""}${h}`;const d=l===s;if(i.dirty=!0,i.cid=void 0,i.size=void 0,d)await i.put(h,n),t=await V9(null,i,e.shardSplitThresholdBytes,e);else{let f=await i.get(h);(f==null||!(f instanceof Za))&&(f=new U0({root:!1,dir:!0,parent:i,parentKey:h,path:o,dirty:!0,flat:!0,mtime:(a=f==null?void 0:f.unixfs)==null?void 0:a.mtime,mode:(c=f==null?void 0:f.unixfs)==null?void 0:c.mode},e)),await i.put(h,f),i=f}}return t}async function*g3(n,t){var e;if(!(n instanceof Za)){((e=n.unixfs)==null?void 0:e.isDirectory())===!0&&(yield n);return}yield*n.flush(t)}function nF(n){return async function*(e,r){var a;let s=new U0({root:!0,dir:!0,path:"",dirty:!0,flat:!0},n),i,o=!1;for await(const c of e){if(c==null)continue;const l=`${c.originalPath??""}`.split("/")[0];l!=null&&l!==""&&(i==null?(i=l,o=!0):i!==l&&(o=!1)),s=await rF(c,s,n),((a=c.unixfs)==null?void 0:a.isDirectory())!==!0&&(yield c)}if(n.wrapWithDirectory||o&&s.childCount()>1)yield*g3(s,r);else for await(const c of s.eachChildSeries())c!=null&&(yield*g3(c.child,r))}}async function*hh(n,t,e={}){let r;Symbol.asyncIterator in n||Symbol.iterator in n?r=n:r=[n];const s=e.wrapWithDirectory??!1,i=e.shardSplitThresholdBytes??262144,o=e.shardFanoutBits??8,a=e.cidVersion??1,c=e.rawLeaves??!0,l=e.leafType??"file",h=e.fileImportConcurrency??50,d=e.blockWriteConcurrency??10,f=e.reduceSingleLeafToSelf??!0,g=e.chunker??N9(),y=e.chunkValidator??BO(),p=e.dagBuilder??DO({chunker:g,chunkValidator:y,wrapWithDirectory:s,layout:e.layout??O9(),bufferImporter:e.bufferImporter??SO({cidVersion:a,rawLeaves:c,leafType:l,onProgress:e.onProgress}),blockWriteConcurrency:d,reduceSingleLeafToSelf:f,cidVersion:a,onProgress:e.onProgress}),w=e.treeBuilder??nF({wrapWithDirectory:s,shardSplitThresholdBytes:i,shardFanoutBits:o,cidVersion:a,onProgress:e.onProgress});for await(const v of w(M9(p(r,t),h),t))yield{cid:v.cid,path:v.path,unixfs:v.unixfs,size:v.size}}async function H9(n,t,e={}){const r=await g0(hh([n],t,e));if(r==null)throw new xO("Nothing imported");return r}async function sF(n,t,e={}){return H9({content:n},t,e)}async function iF(n,t,e={}){return H9({content:n},t,e)}function oF(n){return n[Symbol.asyncIterator]!=null}function Jo(n){if(oF(n))return(async()=>{let e;for await(const r of n)e=r;return e})();let t;for(const e of n)t=e;return t}class Hn extends Error{constructor(e,r,s){super(e);u(this,"name");u(this,"code");this.name=r,this.code=s}}let dh=class extends Hn{constructor(t="not a Unixfs node"){super(t,"NotUnixFSError","ERR_NOT_UNIXFS")}};class wi extends Hn{constructor(t="invalid PBNode"){super(t,"InvalidPBNodeError","ERR_INVALID_PB_NODE")}}class z0 extends Hn{constructor(t="unknown error"){super(t,"InvalidPBNodeError","ERR_UNKNOWN_ERROR")}}class q9 extends Hn{constructor(t="path already exists"){super(t,"AlreadyExistsError","ERR_ALREADY_EXISTS")}}class aF extends Hn{constructor(t="path does not exist"){super(t,"DoesNotExistError","ERR_DOES_NOT_EXIST")}}class W9 extends Hn{constructor(t="no content"){super(t,"NoContentError","ERR_NO_CONTENT")}}class cF extends Hn{constructor(t="not a file"){super(t,"NotAFileError","ERR_NOT_A_FILE")}}class V0 extends Hn{constructor(t="not a directory"){super(t,"NotADirectoryError","ERR_NOT_A_DIRECTORY")}}let Vr=class extends Hn{constructor(t="invalid parameters"){super(t,"InvalidParametersError","ERR_INVALID_PARAMETERS")}};const bc={cidVersion:1,rawLeaves:!0,layout:O9({maxChildrenPerNode:1024}),chunker:N9({chunkSize:1048576})};async function*H0(n,t,e={}){yield*hh(n,t,{...bc,...e})}async function lF(n,t,e={}){const{cid:r}=await sF(n,t,{...bc,...e});return r}async function uF(n,t,e={}){const{cid:r}=await iF(n,t,{...bc,...e});return r}async function hF(n,t,e={}){if(n.path==null)throw new Vr("path is required");if(n.content==null)throw new Vr("content is required");const r=await Jo(H0([n],t,{...bc,...e,wrapWithDirectory:!0}));if(r==null)throw new Vr("Nothing imported");return r.cid}async function dF(n,t,e={}){if(n.content!=null)throw new Vr("Directories cannot have content, use addFile instead");const s=await(n.path==null?g0:Jo)(H0([{...n,path:n.path??"-"}],t,{...bc,...e,wrapWithDirectory:n.path!=null}));if(s==null)throw new Vr("Nothing imported");return s.cid}const Ki=class Ki extends Error{constructor(e="Bad path"){super(e);u(this,"name",Ki.name);u(this,"code",Ki.code)}};u(Ki,"name","BadPathError"),u(Ki,"code","ERR_BAD_PATH");let K1=Ki;const Gi=class Gi extends Error{constructor(e="Not found"){super(e);u(this,"name",Gi.name);u(this,"code",Gi.code)}};u(Gi,"name","NotFoundError"),u(Gi,"code","ERR_NOT_FOUND");let Ts=Gi;const Qi=class Qi extends Error{constructor(e="No resolver"){super(e);u(this,"name",Qi.name);u(this,"code",Qi.code)}};u(Qi,"name","NoResolverError"),u(Qi,"code","ERR_NO_RESOLVER");let G1=Qi;const Yi=class Yi extends Error{constructor(e="Not UnixFS"){super(e);u(this,"name",Yi.name);u(this,"code",Yi.code)}};u(Yi,"name","NotUnixFSError"),u(Yi,"code","ERR_NOT_UNIXFS");let zt=Yi;const Xi=class Xi extends Error{constructor(e="Over read"){super(e);u(this,"name",Xi.name);u(this,"code",Xi.code)}};u(Xi,"name","OverReadError"),u(Xi,"code","ERR_OVER_READ");let Q1=Xi;const Zi=class Zi extends Error{constructor(e="Under read"){super(e);u(this,"name",Zi.name);u(this,"code",Zi.code)}};u(Zi,"name","UnderReadError"),u(Zi,"code","ERR_UNDER_READ");let Y1=Zi;const Ji=class Ji extends Error{constructor(e="No Property found"){super(e);u(this,"name",Ji.name);u(this,"code",Ji.code)}};u(Ji,"name","NoPropError"),u(Ji,"code","ERR_NO_PROP");let X1=Ji;const ji=class ji extends Error{constructor(e="Invalid parameters"){super(e);u(this,"name",ji.name);u(this,"code",ji.code)}};u(ji,"name","InvalidParametersError"),u(ji,"code","ERR_INVALID_PARAMS");let zi=ji;function q0(n,t,e,r,s,i,o){let a=n,c=s;for(;i.length>0;){const l=i[0];if(l in a){i.shift(),c=`${c}/${l}`;const h=te.asCID(a[l]);if(h!=null)return{entry:{type:"object",name:r,path:s,cid:e,node:t,depth:o,size:BigInt(t.length),content:async function*(){yield n}},next:{cid:h,name:l,path:c,toResolve:i}};a=a[l]}else throw new X1(`No property named ${l} found in node ${e}`)}return{entry:{type:"object",name:r,path:s,cid:e,node:t,depth:o,size:BigInt(t.length),content:async function*(){yield n}}}}const fF=async(n,t,e,r,s,i,o,a)=>{const c=await o.get(n,a),l=F5(c);return q0(l,c,n,t,e,r,i)},gF=async(n,t,e,r,s,i,o,a)=>{const c=await o.get(n,a),l=jf(c);return q0(l,c,n,t,e,r,i)};function bu(n,t,e,r){const s=BigInt(n.length),i=BigInt(t+s);return e>=i||r<t?new Uint8Array(0):(r>=t&&r<i&&(n=n.subarray(0,Number(r-t))),e>=t&&e<i&&(n=n.subarray(Number(e-t))),n)}const W0=(n,t=0,e=n)=>{const r=BigInt(n),s=BigInt(t??0);let i=BigInt(e);if(i!==r&&(i=s+i),i>r&&(i=r),s<0n)throw new zi("Offset must be greater than or equal to 0");if(s>r)throw new zi("Offset must be less than the file size");if(i<0n)throw new zi("Length must be greater than or equal to 0");if(i>r)throw new zi("Length must be less than the file size");return{start:s,end:i}},pF=n=>{async function*t(e={}){var o;const{start:r,end:s}=W0(n.length,e.offset,e.length),i=bu(n,0n,r,s);(o=e.onProgress)==null||o.call(e,new se("unixfs:exporter:progress:identity",{bytesRead:BigInt(i.byteLength),totalBytes:s-r,fileSize:BigInt(n.byteLength)})),yield i}return t},mF=async(n,t,e,r,s,i,o,a)=>{if(r.length>0)throw new Ts(`No link named ${e} found in raw node ${n}`);const c=bt(n.multihash.bytes);return{entry:{type:"identity",name:t,path:e,cid:n,content:pF(c.digest),depth:i,size:BigInt(c.digest.length),node:c.digest}}},yF=async(n,t,e,r,s,i,o,a)=>{const c=await o.get(n,a),l=Sf(c);return q0(l,c,n,t,e,r,i)},wF=n=>{async function*t(e={}){var o;const{start:r,end:s}=W0(n.length,e.offset,e.length),i=bu(n,0n,r,s);(o=e.onProgress)==null||o.call(e,new se("unixfs:exporter:progress:raw",{bytesRead:BigInt(i.byteLength),totalBytes:s-r,fileSize:BigInt(n.byteLength)})),yield i}return t},bF=async(n,t,e,r,s,i,o,a)=>{if(r.length>0)throw new Ts(`No link named ${e} found in raw node ${n}`);const c=await o.get(n,a);return{entry:{type:"raw",name:t,path:e,cid:n,content:wF(c),depth:i,size:BigInt(c.length),node:c}}},vF=async function(n){return(await uh.encode(n)).slice(0,8).reverse()},EF=async(n,t,e)=>{const r=(t.tableSize()-1).toString(16).length;await Promise.all(n.map(async s=>{if(s.Name==null)throw new Error("Unexpected Link without a Name");if(s.Name.length===r){const i=parseInt(s.Name,16);t._putObjectAt(i,new Ut({hash:e._options.hash,bits:e._options.bits},t,i));return}await e.put(s.Name.substring(2),!0)}))},p3=(n,t)=>n.toString(16).toUpperCase().padStart(t,"0").substring(0,t),SF=n=>{let t=n.bucket;const e=[];for(;t._parent!=null;)e.push(t),t=t._parent;return e.push(t),e.reverse()},K9=async(n,t,e,r,s)=>{if(r==null){if(n.Data==null)throw new zt("no data in PBNode");let d;try{d=ke.unmarshal(n.Data)}catch(g){throw new zt(g.message)}if(d.type!=="hamt-sharded-directory")throw new zt("not a HAMT");if(d.fanout==null)throw new zt("missing fanout");const f=$0({hashFn:vF,bits:Math.log2(Number(d.fanout))});r={rootBucket:f,hamtDepth:1,lastBucket:f}}const i=(r.lastBucket.tableSize()-1).toString(16).length;await EF(n.Links,r.lastBucket,r.rootBucket);const o=await r.rootBucket._findNewBucketAndPos(t);let a=p3(o.pos,i);const c=SF(o);c.length>r.hamtDepth&&(r.lastBucket=c[r.hamtDepth],a=p3(r.lastBucket._posAtParent,i));const l=n.Links.find(d=>{if(d.Name==null)return!1;const f=d.Name.substring(0,i),g=d.Name.substring(i);return!(f!==a||g!==""&&g!==t)});if(l==null)return;if(l.Name!=null&&l.Name.substring(i)===t)return l.Hash;r.hamtDepth++;const h=await e.get(l.Hash,s);return n=Kr(h),K9(n,t,e,r,s)},xF=(n,t,e,r,s,i,o)=>{async function*a(c={}){var f;const l=c.offset??0,h=c.length??t.Links.length,d=t.Links.slice(l,h);(f=c.onProgress)==null||f.call(c,new se("unixfs:exporter:walk:directory",{cid:n})),yield*It(d,g=>Un(g,y=>async()=>{const p=y.Name??"",w=`${r}/${p}`;return(await s(y.Hash,p,w,[],i+1,o,c)).entry}),g=>Rs(g,{ordered:!0,concurrency:c.blockReadConcurrency}),g=>Jn(g,y=>y!=null))}return a};async function G9(n,t,e,r,s,i,o){if(t instanceof Uint8Array){const l=bu(t,r,s,i);e.push(l);return}if(t.Data==null)throw new zt("no data in PBNode");let a;try{a=ke.unmarshal(t.Data)}catch(l){throw new zt(l.message)}if(a.data!=null){const l=a.data,h=bu(l,r,s,i);e.push(h),r+=BigInt(h.byteLength)}const c=[];if(t.Links.length!==a.blockSizes.length)throw new zt("Inconsistent block sizes and dag links");for(let l=0;l<t.Links.length;l++){const h=t.Links[l],d=r,f=d+a.blockSizes[l];if((s>=d&&s<f||i>=d&&i<=f||s<d&&i>f)&&c.push({link:h,blockStart:r}),r=f,r>i)break}await It(c,l=>Un(l,h=>async()=>{const d=await n.get(h.link.Hash,o);return{...h,block:d}}),l=>Rs(l,{ordered:!0,concurrency:o.blockReadConcurrency}),async l=>{for await(const{link:h,block:d,blockStart:f}of l){let g;switch(h.Hash.code){case bn:g=Kr(d);break;case qr:g=d;break;default:e.end(new zt(`Unsupported codec: ${h.Hash.code}`));return}const y=new Fa({concurrency:1});y.on("error",p=>{e.end(p)}),y.add(async()=>{var p;(p=o.onProgress)==null||p.call(o,new se("unixfs:exporter:walk:file",{cid:h.Hash})),await G9(n,g,e,f,s,i,o)}),await y.onIdle()}}),r>=i&&e.end()}const m3=(n,t,e,r,s,i,o)=>{async function*a(c={}){var p,w;const l=e.fileSize();if(l===void 0)throw new Error("File was a directory");const{start:h,end:d}=W0(l,c.offset,c.length);if(d===0n)return;let f=0n;const g=d-h,y=gn();(p=c.onProgress)==null||p.call(c,new se("unixfs:exporter:walk:file",{cid:n})),G9(o,t,y,0n,h,d,c).catch(v=>{y.end(v)});for await(const v of y)if(v!=null){if(f+=BigInt(v.byteLength),f>g)throw y.end(),new Q1("Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect");f===g&&y.end(),(w=c.onProgress)==null||w.call(c,new se("unixfs:exporter:progress:unixfs:file",{bytesRead:f,totalBytes:g,fileSize:l})),yield v}if(f<g)throw new Y1("Traversed entire DAG but did not read enough bytes")}return a},_F=(n,t,e,r,s,i,o)=>{function a(c={}){var l;return(l=c.onProgress)==null||l.call(c,new se("unixfs:exporter:walk:hamt-sharded-directory",{cid:n})),Q9(t,r,s,i,o,c)}return a};async function*Q9(n,t,e,r,s,i){const o=n.Links;if(n.Data==null)throw new zt("no data in PBNode");let a;try{a=ke.unmarshal(n.Data)}catch(h){throw new zt(h.message)}if(a.fanout==null)throw new zt("missing fanout");const c=(a.fanout-1n).toString(16).length,l=It(o,h=>Un(h,d=>async()=>{var g;const f=d.Name!=null?d.Name.substring(c):null;if(f!=null&&f!==""){const y=await e(d.Hash,f,`${t}/${f}`,[],r+1,s,i);return{entries:y.entry==null?[]:[y.entry]}}else{const y=await s.get(d.Hash,i);return n=Kr(y),(g=i.onProgress)==null||g.call(i,new se("unixfs:exporter:walk:hamt-sharded-directory",{cid:d.Hash})),{entries:Q9(n,t,e,r,s,i)}}}),h=>Rs(h,{ordered:!0,concurrency:i.blockReadConcurrency}));for await(const{entries:h}of l)yield*h}const kF=(n,t)=>{const e=n.Links.find(r=>r.Name===t);return e==null?void 0:e.Hash},IF={raw:m3,file:m3,directory:xF,"hamt-sharded-directory":_F,metadata:(n,t,e,r,s,i,o)=>()=>[],symlink:(n,t,e,r,s,i,o)=>()=>[]},AF=async(n,t,e,r,s,i,o,a)=>{const c=await o.get(n,a),l=Kr(c);let h,d;if(t==null&&(t=n.toString()),l.Data==null)throw new zt("no data in PBNode");try{h=ke.unmarshal(l.Data)}catch(g){throw new zt(g.message)}if(e==null&&(e=t),r.length>0){let g;if((h==null?void 0:h.type)==="hamt-sharded-directory"?g=await K9(l,r[0],o):g=kF(l,r[0]),g==null)throw new Ts("file does not exist");const y=r.shift(),p=`${e}/${y}`;d={cid:g,toResolve:r,name:y??"",path:p}}const f=IF[h.type](n,l,h,e,s,i,o);if(f==null)throw new Ts("could not find content exporter");return h.isDirectory()?{entry:{type:"directory",name:t,path:e,cid:n,content:f,unixfs:h,depth:i,node:l,size:h.fileSize()},next:d}:{entry:{type:"file",name:t,path:e,cid:n,content:f,unixfs:h,depth:i,node:l,size:h.fileSize()},next:d}},TF={[bn]:AF,[qr]:bF,[Zf]:fF,[Jf]:gF,[bs.code]:mF,[Mu]:yF},Y9=async(n,t,e,r,s,i,o)=>{const a=TF[n.code];if(a==null)throw new G1(`No resolver for code ${n.code}`);return a(n,t,e,r,Y9,s,i,o)},CF=(n="")=>(n.trim().match(/([^\\^/]|\\\/)+/g)??[]).filter(Boolean),PF=n=>{if(n instanceof Uint8Array)return{cid:te.decode(n),toResolve:[]};const t=te.asCID(n);if(t!=null)return{cid:t,toResolve:[]};if(typeof n=="string"){n.indexOf("/ipfs/")===0&&(n=n.substring(6));const e=CF(n);return{cid:te.parse(e[0]),toResolve:e.slice(1)}}throw new K1(`Unknown path type ${n}`)};async function*X9(n,t,e={}){let{cid:r,toResolve:s}=PF(n),i=r.toString(),o=i;const a=s.length;for(;;){const c=await Y9(r,i,o,s,a,t,e);if(c.entry==null&&c.next==null)throw new Ts(`Could not resolve ${n}`);if(c.entry!=null&&(yield c.entry),c.next==null)return;s=c.next.toResolve,r=c.next.cid,i=c.next.name,o=c.next.path}}async function Bs(n,t,e={}){const r=await Jo(X9(n,t,e));if(r==null)throw new Ts(`Could not resolve ${n}`);return r}async function*Z9(n,t,e={}){const r=await Bs(n,t,e);if(r==null)return;if(yield r,r.type==="directory")for await(const i of s(r,e))yield i;async function*s(i,o){for await(const a of i.content(o))yield a,!(a instanceof Uint8Array)&&a.type==="directory"&&(yield*s(a,o))}}function J9(n){function t(e){return e instanceof y3?e:new y3(e,n)}return t}class y3{constructor(t,e){u(this,"_value");u(this,"_hashFn");u(this,"_depth");u(this,"_availableBits");u(this,"_currentBufferIndex");u(this,"_buffers");if(!(t instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=t,this._hashFn=e,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(t){let e=t;for(;this._availableBits<e;)await this._produceMoreBits();let r=0;for(;e>0;){const s=this._buffers[this._currentBufferIndex],i=Math.min(s.availableBits(),e),o=s.take(i);r=(r<<i)+o,e-=i,this._availableBits-=i,s.availableBits()===0&&this._currentBufferIndex++}return r}untake(t){let e=t;for(;e>0;){const r=this._buffers[this._currentBufferIndex],s=Math.min(r.totalBits()-r.availableBits(),e);r.untake(s),e-=s,this._availableBits+=s,this._currentBufferIndex>0&&r.totalBits()===r.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const t=this._depth>0?ft([this._value,Uint8Array.from([this._depth])]):this._value,e=await this._hashFn(t),r=new BF(e);this._buffers.push(r),this._availableBits+=r.availableBits()}}const DF=[255,254,252,248,240,224,192,128],RF=[1,3,7,15,31,63,127,255];class BF{constructor(t){u(this,"_value");u(this,"_currentBytePos");u(this,"_currentBitPos");this._value=t,this._currentBytePos=t.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(t){let e=t,r=0;for(;e>0&&this._haveBits();){const s=this._value[this._currentBytePos],i=this._currentBitPos+1,o=Math.min(i,e),a=MF(s,i-o,o);r=(r<<o)+a,e-=o,this._currentBitPos-=o,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return r}untake(t){for(this._currentBitPos+=t;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}}function MF(n,t,e){const r=NF(t,e);return(n&r)>>>t}function NF(n,t){return DF[n]&RF[Math.min(t+n-1,7)]}const K0=BigInt(uh.code),Ia=8;async function G0(n){return(await uh.encode(n)).subarray(0,8).reverse()}const jo=async(n,t,e)=>{e.codec==null&&(e.codec=dc);const r=await gt.digest(n),s=te.create(e.cidVersion,e.codec.code,r);return await t.put(s,n,{...e,signal:e.signal}),s};class LF{constructor(t,e){u(this,"options");u(this,"root");u(this,"dir");u(this,"path");u(this,"dirty");u(this,"flat");u(this,"parent");u(this,"parentKey");u(this,"unixfs");u(this,"mode");u(this,"mtime");u(this,"cid");u(this,"size");u(this,"nodeSize");this.options=e??{},this.root=t.root,this.dir=t.dir,this.path=t.path,this.dirty=t.dirty,this.flat=t.flat,this.parent=t.parent,this.parentKey=t.parentKey,this.unixfs=t.unixfs,this.mode=t.mode,this.mtime=t.mtime}}class OF extends LF{constructor(e,r){super(e,r);u(this,"_bucket");this._bucket=$0({hashFn:G0,bits:8})}async put(e,r){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,await this._bucket.put(e,r)}async get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:r}of this._bucket.eachLeafSeries())yield{key:e,child:r}}estimateNodeSize(){return this.nodeSize!==void 0?this.nodeSize:(this.nodeSize=ey(this._bucket,this,this.options),this.nodeSize)}async*flush(e){for await(const r of j9(this._bucket,e,this,this.options))yield{...r,path:this.path}}}async function*j9(n,t,e,r){const s=n._children,i=[];let o=0n;for(let g=0;g<s.length;g++){const y=s.get(g);if(y==null)continue;const p=g.toString(16).toUpperCase().padStart(2,"0");if(y instanceof Ut){let w;for await(const v of j9(y,t,null,r))w=v;if(w==null)throw new Error("Could not flush sharded directory, no sub-shard found");i.push({Name:p,Tsize:Number(w.size),Hash:w.cid}),o+=w.size}else if(FF(y.value)){const w=y.value;let v;for await(const S of w.flush(t))v=S,yield v;if(v==null)throw new Error("Did not flush dir");const x=p+y.key;i.push({Name:x,Tsize:Number(v.size),Hash:v.cid}),o+=v.size}else{const w=y.value;if(w.cid==null)continue;const v=p+y.key,x=w.size;i.push({Name:v,Tsize:Number(x),Hash:w.cid}),o+=BigInt(x??0)}}const a=Uint8Array.from(s.bitField().reverse()),c=new ke({type:"hamt-sharded-directory",data:a,fanout:BigInt(n.tableSize()),hashType:K0,mtime:e==null?void 0:e.mtime,mode:e==null?void 0:e.mode}),l={Data:c.marshal(),Links:i},h=pt(gr(l)),d=await jo(h,t,r),f=BigInt(h.byteLength)+o;yield{cid:d,unixfs:c,size:f}}function FF(n){return typeof n.flush=="function"}function ey(n,t,e){const r=n._children,s=[];for(let c=0;c<r.length;c++){const l=r.get(c);if(l==null)continue;const h=c.toString(16).toUpperCase().padStart(2,"0");if(l instanceof Ut){const d=ey(l,null,e);s.push({Name:h,Tsize:Number(d),Hash:e.cidVersion===0?Z1:J1})}else if(typeof l.value.flush=="function"){const f=l.value.nodeSize();s.push({Name:h+l.key,Tsize:Number(f),Hash:e.cidVersion===0?Z1:J1})}else{const d=l.value;if(d.cid==null)continue;const f=h+l.key,g=d.size;s.push({Name:f,Tsize:Number(g),Hash:d.cid})}}const i=Uint8Array.from(r.bitField().reverse()),o=new ke({type:"hamt-sharded-directory",data:i,fanout:BigInt(n.tableSize()),hashType:K0,mtime:t==null?void 0:t.mtime,mode:t==null?void 0:t.mode});return pt(gr({Data:o.marshal(),Links:s})).length}const Z1=te.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"),J1=te.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi"),j1=Ot("helia:unixfs:commands:utils:hamt-utils"),ef=n=>n.toString(16).toUpperCase().padStart(2,"0").substring(0,2),UF=async(n,t,e)=>{const r=new OF({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mtime:e.mtime,mode:e.mode},e);for(let i=0;i<t.length;i++)await r._bucket.put(t[i].name,{size:t[i].size,cid:t[i].cid});const s=await Jo(r.flush(n));if(s==null)throw new Error("Flushing shard yielded no result");return s},ty=async(n,t,e)=>{const r=ke.unmarshal(n[0].node.Data??new Uint8Array(0)),s=BigInt(Math.pow(2,Ia));n.reverse();let i,o;for(let a=0;a<n.length;a++){const c=a===n.length-1,l=n[a],h=Uint8Array.from(l.children.bitField().reverse()),d=new ke({type:"hamt-sharded-directory",data:h,fanout:s,hashType:K0});c&&(d.mtime=r.mtime,d.mode=r.mode),o={Data:d.marshal(),Links:l.node.Links};const f=pt(gr(o));if(i=await jo(f,t,e),!c){const g=n[a+1];if(g==null)throw new Error("Was not operating on shard root but also had no parent?");j1("updating link in parent sub-shard with prefix %s",g.prefix),g.node.Links=g.node.Links.filter(y=>y.Name!==g.prefix),g.node.Links.push({Name:g.prefix,Hash:i,Tsize:l.node.Links.reduce((y,p)=>y+(p.Tsize??0),f.byteLength)})}}if(i==null||o==null)throw new Error("Noting persisted");return{cid:i,node:o}},ry=async(n,t,e,r)=>{const i=J9(G0)(Y(t)),o=[];for(;;){const a=await e.get(n,r),c=Kr(a),l=new wu,h=await i.take(Ia),d=ef(h);o.push({prefix:d,children:l,node:c});let f;for(const y of c.Links){const p=y.Name??"";if(p.length<2)throw new Error("Invalid HAMT - link name was too short");const w=parseInt(p.substring(0,2),16);l.set(w,!0),p.startsWith(d)&&(f=y)}if(f==null){j1("no link found with prefix %s for %s",d,t);break}const g=f.Name??"";if(g.length<2)throw new Error("Invalid HAMT - link name was too short");if(g.length===2){n=f.Hash,j1("descend into sub-shard with prefix %s",g);continue}break}return{path:o,hash:i}};async function ny(n,t,e,r){if(n.Data==null)throw new Error("DagPB node had no data");const s=ke.unmarshal(n.Data);let i;if(s.type==="directory")i=$F(n);else if(s.type==="hamt-sharded-directory")i=await sy(n,0,e,t,r);else throw new Error("Can only estimate the size of directories or shards");return i>e}function $F(n){let t=0;for(const e of n.Links)t+=(e.Name??"").length,t+=e.Hash.version===1?J1.bytes.byteLength:Z1.bytes.byteLength;return t}async function sy(n,t,e,r,s){if(t>e)return e;if(n.Data==null||!ke.unmarshal(n.Data).isDirectory())return t;for(const o of n.Links){let a=o.Name??"";if(a=a.substring(2),t+=a.length,t+=o.Hash.bytes.byteLength,o.Hash.code===bn){const c=await r.get(o.Hash,s),l=Kr(c);t+=await sy(l,t,e,r,s)}}return t}const cn=Ot("helia:unixfs:components:utils:add-link");async function Q0(n,t,e,r){if(n.node.Data==null)throw new Vr("Invalid parent passed to addLink");if(ke.unmarshal(n.node.Data).type==="hamt-sharded-directory")return cn("adding link to sharded directory"),HF(n,t,e,r);cn(`adding ${t.Name} (${t.Hash}) to regular directory`);const i=await VF(n,t,e,r);if(await ny(i.node,e,r.shardSplitThresholdBytes,r)){cn("converting directory to sharded directory");const o=await zF(i,e);i.cid=o.cid,i.node=Kr(await e.get(o.cid,r))}return i}const zF=async(n,t)=>{if(n.node.Data==null)throw new Vr("Invalid parent passed to convertToShardedDirectory");const e=ke.unmarshal(n.node.Data),r=await UF(t,n.node.Links.map(s=>({name:s.Name??"",size:BigInt(s.Tsize??0),cid:s.Hash})),{mode:e.mode,mtime:e.mtime,cidVersion:n.cid.version});return cn(`converted directory to sharded directory ${r.cid}`),r},VF=async(n,t,e,r)=>{const s=n.node.Links.filter(h=>{const d=h.Name===t.Name;if(d&&!r.allowOverwriting)throw new q9;return!d});if(s.push(t),n.node.Data==null)throw new wi("Parent node with no data passed to addToDirectory");const i=ke.unmarshal(n.node.Data);let o;if(i.mtime!=null){const h=Date.now(),d=Math.floor(h/1e3);i.mtime={secs:BigInt(d),nsecs:(h-d*1e3)*1e3},o=i.marshal()}else o=n.node.Data;n.node=gr({Data:o,Links:s});const a=pt(n.node),c=await gt.digest(a),l=te.create(n.cid.version,bn,c);return await e.put(l,a),{node:n.node,cid:l}},HF=async(n,t,e,r)=>{var d;const{path:s,hash:i}=await ry(n.cid,t.Name,e,r),o=s[s.length-1];if(o==null)throw new Error("Invalid HAMT, could not generate path");const a=o.prefix,c=parseInt(a,16);cn("next prefix for %s is %s",t.Name,a);const l=`${a}${t.Name}`,h=o.node.Links.find(f=>(f.Name??"").startsWith(a));if(h!=null)if(cn("link %s was present in shard",l),h.Name===l){if(!r.allowOverwriting)throw new q9;cn("overwriting %s in sub-shard",t.Name),o.node.Links=o.node.Links.filter(f=>f.Name!==l),o.node.Links.push({Name:l,Hash:t.Hash,Tsize:t.Tsize})}else{if(((d=h.Name)==null?void 0:d.length)===2)throw new Error("Existing link was sub-shard?!");{cn("prefix %s already exists, creating new sub-shard",a);const f=o.node.Links.findIndex(v=>{var x;return(x=v.Name)==null?void 0:x.startsWith(a)}),g=o.node.Links.splice(f,1)[0],y=(g.Name??"").substring(2),w=J9(G0)(Y(y));for(let v=0;v<s.length;v++)await w.take(Ia);for(;;){const v=await w.take(Ia),x=ef(v);g.Name=`${x}${y}`;const S=await i.take(Ia),I=ef(S);if(x===I){const A=new wu;A.set(S,!0),s.push({prefix:I,children:A,node:{Links:[]}});continue}const P=new wu;P.set(S,!0),P.set(v,!0),s.push({prefix:a,children:P,node:{Links:[g,{Name:`${I}${t.Name}`,Hash:t.Hash,Tsize:t.Tsize}]}});break}}}else cn("link %s was not present in sub-shard",l),t.Name=l,o.node.Links.push(t),o.children.set(c,!0),cn("adding %s to existing sub-shard",l);return ty(s,e,r)};async function fh(n,t,e={}){const r=await Bs(n,t,e);if(r.type!=="directory")throw new V0(`${n.toString()} was not a UnixFS directory`);return{cid:n,node:r.node}}async function Y0(n,t,e,r){const s=await Bs(n,e,r);if(s.type!=="directory"&&s.type!=="file"&&s.type!=="raw")throw new dh(`${n.toString()} was not a UnixFS node`);return{Name:t,Tsize:s.node instanceof Uint8Array?s.node.byteLength:qF(s.node),Hash:n}}function qF(n){const t=n.Links.reduce((e,r)=>e+(r.Tsize??0),0);return pt(n).byteLength+t}const WF=Ot("helia:unixfs:components:utils:resolve");async function vc(n,t,e,r){if(t==null||t==="")return{cid:n};const s=`/ipfs/${n}${t==null?"":`/${t}`}`,i=await Wa(X9(s,e,r));if(i.length===0)throw new aF("Could not find path in directory");return WF("resolved %s to %c",t,n),{cid:i[i.length-1].cid,path:t,segments:i}}async function vu(n,t,e,r){if(t.segments==null||t.segments.length===0)return n;let s=t.segments.pop();if(s==null)throw new Error("Insufficient segments");s.cid=n,t.segments.reverse();for(const i of t.segments){const[o,a]=await Promise.all([fh(i.cid,e,r),Y0(s.cid,s.name,e,r)]);n=(await Q0(o,a,e,{...r,allowOverwriting:!0,cidVersion:n.version})).cid,i.cid=n,s=i}return n}const KF=Gr.bind({ignoreUndefined:!0}),GF={};async function*QF(n,t,e={}){const r=KF(GF,e),s=await vc(n,r.path,t,r),i=await Bs(s.cid,t,r);if(i.type!=="file"&&i.type!=="raw")throw new cF;if(i.content==null)throw new W9;yield*i.content(r)}const Ec=262144,YF=Gr.bind({ignoreUndefined:!0}),XF=Ot("helia:unixfs:chmod"),ZF={recursive:!1,shardSplitThresholdBytes:Ec};async function JF(n,t,e,r={}){const s=YF(ZF,r),i=await vc(n,s.path,e,r);if(XF("chmod %c %d",i.cid,t),s.recursive){const f=await It(async function*(){for await(const g of Z9(i.cid,e,r)){let y,p=[];if(g.type==="raw")y=new ke({type:"file",data:g.node});else if(g.type==="file"||g.type==="directory")y=g.unixfs,p=g.node.Links;else throw new dh;y.mode=t;const w={Data:y.marshal(),Links:p};yield{path:g.path,content:w}}},g=>hh(g,e,{...s,dagBuilder:async function*(y,p){for await(const w of y)yield async function(){const v=w.content,x=pt(v),S=await jo(x,p,{...s,cidVersion:n.version});if(v.Data==null)throw new wi(`${S} had no data`);const I=ke.unmarshal(v.Data);return{cid:S,size:BigInt(x.length),path:w.path,unixfs:I}}}}),async g=>Jo(g));if(f==null)throw new z0(`Could not chmod ${i.cid.toString()}`);return vu(f.cid,i,e,s)}const o=await e.get(i.cid,r);let a,c=[];if(i.cid.code===qr)a=new ke({type:"file",data:o});else{const f=Kr(o);if(f.Data==null)throw new wi(`${i.cid.toString()} had no data`);c=f.Links,a=ke.unmarshal(f.Data)}a.mode=t;const l=pt({Data:a.marshal(),Links:c}),h=await gt.digest(l),d=te.create(i.cid.version,bn,h);return await e.put(d,l),vu(d,i,e,s)}const jF=Gr.bind({ignoreUndefined:!0}),eU=Ot("helia:unixfs:cp"),tU={force:!1,shardSplitThresholdBytes:Ec};async function rU(n,t,e,r,s={}){const i=jF(tU,s);if(e.includes("/"))throw new Vr("Name must not have slashes");const[o,a]=await Promise.all([fh(t,r,i),Y0(n,e,r,i)]);return eU('Adding %c as "%s" to %c',n,e,t),(await Q0(o,a,r,{allowOverwriting:i.force,cidVersion:t.version,...i})).cid}const nU=Gr.bind({ignoreUndefined:!0}),sU={};async function*iU(n,t,e={}){const r=nU(sU,e),s=await vc(n,r.path,t,r),i=await Bs(s.cid,t);if(i.type==="file"||i.type==="raw"){yield i;return}if(i.content==null)throw new W9;if(i.type!=="directory")throw new V0;yield*i.content({offset:e.offset,length:e.length})}const oU=Gr.bind({ignoreUndefined:!0}),w3=Ot("helia:unixfs:mkdir"),aU={cidVersion:1,force:!1,shardSplitThresholdBytes:Ec};async function cU(n,t,e,r={}){const s=oU(aU,r);if(t.includes("/"))throw new Vr("Path must not have slashes");if((await Bs(n,e,r)).type!=="directory")throw new V0(`${n.toString()} was not a UnixFS directory`);w3("creating %s",t);const a={Data:new ke({type:"directory",mode:s.mode,mtime:s.mtime}).marshal(),Links:[]},c=pt(a),l=await gt.digest(c),h=te.create(s.cidVersion,bn,l);await e.put(h,c);const[d,f]=await Promise.all([fh(n,e,s),Y0(h,t,e,s)]);return w3("adding empty dir called %s to %c",t,n),(await Q0(d,f,e,{...s,allowOverwriting:s.force})).cid}const bl=Ot("helia:unixfs:utils:remove-link");async function lU(n,t,e,r){if(n.node.Data==null)throw new wi("Parent node had no data");if(ke.unmarshal(n.node.Data).type==="hamt-sharded-directory"){bl(`removing ${t} from sharded directory`);const i=await hU(n,t,e,r);return await ny(i.node,e,r.shardSplitThresholdBytes,r)?i:(bl("converting shard to flat directory %c",n.cid),dU(i,e,r))}return bl(`removing link ${t} regular directory`),uU(n,t,e,r)}const uU=async(n,t,e,r)=>{n.node.Links=n.node.Links.filter(o=>o.Name!==t);const s=pt(n.node),i=await jo(s,e,{...r,cidVersion:n.cid.version});return bl(`Updated regular directory ${i}`),{node:n.node,cid:i}},hU=async(n,t,e,r)=>{const{path:s}=await ry(n.cid,t,e,r),i=s[s.length-1];if(i==null)throw new Error("Invalid HAMT, could not generate path");const o=i.node.Links.filter(l=>(l.Name??"").substring(2)===t).map(l=>l.Name).pop();if(o==null)throw new Error("File not found");const a=o.substring(0,2),c=parseInt(a,16);if(i.node.Links=i.node.Links.filter(l=>l.Name!==o),i.children.unset(c),i.node.Links.length===1)for(;s.length!==1;){const l=s[s.length-1];if(l==null||l.node.Links.length>1)break;s.pop();const h=s[s.length-1];if(h==null)break;const d=l.node.Links[0];h.node.Links=h.node.Links.filter(f=>!(f.Name??"").startsWith(h.prefix)),h.node.Links.push({Hash:d.Hash,Name:`${h.prefix}${(d.Name??"").substring(2)}`,Tsize:d.Tsize})}return ty(s,e,r)},dU=async(n,t,e)=>{if(n.node.Data==null)throw new Vr("Invalid parent passed to convertToFlatDirectory");const r={Links:[]},s=await Bs(n.cid,t);if(s.type!=="directory")throw new Error("Unexpected node type");for await(const c of s.content()){let l=0;c.node instanceof Uint8Array?l=c.node.byteLength:l=pt(c.node).length,r.Links.push({Hash:c.cid,Name:c.name,Tsize:l})}const i=ke.unmarshal(n.node.Data);r.Data=new ke({type:"directory",mode:i.mode,mtime:i.mtime}).marshal();const o=pt(gr(r));return{cid:await jo(o,t,{codec:dc,cidVersion:n.cid.version,signal:e.signal}),node:r}},fU=Gr.bind({ignoreUndefined:!0}),gU=Ot("helia:unixfs:rm"),pU={shardSplitThresholdBytes:Ec};async function mU(n,t,e,r={}){const s=fU(pU,r);if(t.includes("/"))throw new Vr("Name must not have slashes");const i=await fh(n,e,s);return gU("Removing %s from %c",t,n),(await lU(i,t,e,{...s,cidVersion:n.version})).cid}const iy=1877,gh=1604,yU=Gr.bind({ignoreUndefined:!0}),wU=Ot("helia:unixfs:stat"),bU={};async function vU(n,t,e={}){const r=yU(bU,e),s=await vc(n,e.path,t,r);wU("stat %c",s.cid);const i=await Bs(s.cid,t,r);if(i.type==="raw")return e.extended===!0?_U(i):xU(i);if(i.type==="file"||i.type==="directory")return e.extended===!0?SU(i,t,e.filter??new o5({filterSize:1024}),e):EU(i);throw new dh}function EU(n){return{type:n.type,cid:n.cid,unixfs:n.unixfs,mode:n.unixfs.mode??(n.unixfs.isDirectory()?iy:gh),mtime:n.unixfs.mtime,size:n.unixfs.fileSize()}}async function SU(n,t,e,r){const s=await oy(n.cid,t,!1,e,r);return{type:n.type,cid:n.cid,unixfs:n.unixfs,size:n.unixfs.isDirectory()?s.dirSize:n.unixfs.fileSize(),mode:n.unixfs.mode??(n.unixfs.isDirectory()?iy:gh),mtime:n.unixfs.mtime,localSize:s.localSize,dagSize:s.dagSize,deduplicatedDagSize:s.deduplicatedDagSize,blocks:s.blocks,uniqueBlocks:s.uniqueBlocks}}function xU(n){return{type:n.type,cid:n.cid,unixfs:void 0,mode:gh,mtime:void 0,size:BigInt(n.node.byteLength)}}function _U(n){return{type:n.type,cid:n.cid,unixfs:void 0,mode:gh,mtime:void 0,size:BigInt(n.node.byteLength),localSize:BigInt(n.node.byteLength),dagSize:BigInt(n.node.byteLength),deduplicatedDagSize:BigInt(n.node.byteLength),blocks:1n,uniqueBlocks:1n}}async function oy(n,t,e,r,s){const i={dirSize:0n,localSize:0n,dagSize:0n,deduplicatedDagSize:0n,blocks:0n,uniqueBlocks:0n};try{const o=r.has(n.bytes);r.add(n.bytes);const a=await t.get(n,s);if(i.blocks++,i.dagSize+=BigInt(a.byteLength),o||(i.uniqueBlocks++,i.deduplicatedDagSize+=BigInt(a.byteLength)),n.code===qr)i.localSize+=BigInt(a.byteLength),e&&(i.dirSize+=BigInt(a.byteLength));else if(n.code===bn){const c=Kr(a);let l;if(c.Data!=null&&(l=ke.unmarshal(c.Data)),c.Links.length>0){for(const h of c.Links){const d=await oy(h.Hash,t,kU(h,l),r,s);i.localSize+=d.localSize,i.dagSize+=d.dagSize,i.deduplicatedDagSize+=d.deduplicatedDagSize,i.blocks+=d.blocks,i.uniqueBlocks+=d.uniqueBlocks,i.dirSize+=d.dirSize}e&&l!=null&&(i.dirSize+=l.fileSize())}else{if(l==null)throw new wi(`PBNode ${n.toString()} had no data`);l.data!=null&&(i.localSize+=BigInt(l.data.byteLength??0)),e&&(i.dirSize+=l.fileSize())}}else throw new z0(`${n.toString()} was neither DAG_PB nor RAW`)}catch(o){if(o.name!=="NotFoundError"||s.offline!==!0)throw o}return i}function kU(n,t){if(t==null)return!1;const e=n.Name;return e==null?!1:t.type==="directory"?!0:t.type==="hamt-sharded-directory"&&e.length>2}const IU=Gr.bind({ignoreUndefined:!0}),AU=Ot("helia:unixfs:touch"),TU={recursive:!1,shardSplitThresholdBytes:Ec};async function CU(n,t,e={}){const r=IU(TU,e),s=await vc(n,r.path,t,r),i=r.mtime??{secs:BigInt(Math.round(Date.now()/1e3)),nsecs:0};if(AU("touch %c %o",s.cid,i),r.recursive){const f=await It(async function*(){for await(const g of Z9(s.cid,t)){let y,p;if(g.type==="raw")y=new ke({data:g.node}),p=[];else if(g.type==="file"||g.type==="directory")y=g.unixfs,p=g.node.Links;else throw new dh;y.mtime=i;const w={Data:y.marshal(),Links:p};yield{path:g.path,content:w}}},g=>hh(g,t,{...r,dagBuilder:async function*(y,p){for await(const w of y)yield async function(){const v=w.content,x=pt(v),S=await jo(x,p,{...r,cidVersion:n.version});if(v.Data==null)throw new wi(`${S} had no data`);const I=ke.unmarshal(v.Data);return{cid:S,size:BigInt(x.length),path:w.path,unixfs:I}}}}),async g=>Jo(g));if(f==null)throw new z0(`Could not chmod ${s.cid.toString()}`);return vu(f.cid,s,t,r)}const o=await t.get(s.cid,e);let a,c=[];if(s.cid.code===qr)a=new ke({data:o});else{const f=Kr(o);if(c=f.Links,f.Data==null)throw new wi(`${s.cid.toString()} had no data`);a=ke.unmarshal(f.Data)}a.mtime=i;const l=pt({Data:a.marshal(),Links:c}),h=await gt.digest(l),d=te.create(s.cid.version,bn,h);return await t.put(d,l),vu(d,s,t,r)}class PU{constructor(t){u(this,"components");this.components=t}async*addAll(t,e={}){yield*H0(t,this.components.blockstore,e)}async addBytes(t,e={}){return lF(t,this.components.blockstore,e)}async addByteStream(t,e={}){return uF(t,this.components.blockstore,e)}async addFile(t,e={}){return hF(t,this.components.blockstore,e)}async addDirectory(t={},e={}){return dF(t,this.components.blockstore,e)}async*cat(t,e={}){yield*QF(t,this.components.blockstore,e)}async chmod(t,e,r={}){return JF(t,e,this.components.blockstore,r)}async cp(t,e,r,s={}){return rU(t,e,r,this.components.blockstore,s)}async*ls(t,e={}){yield*iU(t,this.components.blockstore,e)}async mkdir(t,e,r={}){return cU(t,e,this.components.blockstore,r)}async rm(t,e,r={}){return mU(t,e,this.components.blockstore,r)}async stat(t,e={}){return vU(t,this.components.blockstore,e)}async touch(t,e={}){return CU(t,this.components.blockstore,e)}}function DU(n){return new PU(n)}function ay(n){return n[Symbol.asyncIterator]!=null}const ph=n=>{const t=$e(n),e=sr(t);return Lt(n,e),ph.bytes=t,e};ph.bytes=0;function X0(n,t){t=t??{};const e=t.lengthEncoder??ph;function*r(s){const i=e(s.byteLength);i instanceof Uint8Array?yield i:yield*i,s instanceof Uint8Array?yield s:yield*s}return ay(n)?async function*(){for await(const s of n)yield*r(s)}():function*(){for(const s of n)yield*r(s)}()}X0.single=(n,t)=>{t=t??{};const e=t.lengthEncoder??ph;return new ye(e(n.byteLength),n)};class RU extends Error{constructor(){super(...arguments);u(this,"name","InvalidMessageLengthError");u(this,"code","ERR_INVALID_MSG_LENGTH")}}class BU extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthError");u(this,"code","ERR_MSG_DATA_TOO_LONG")}}class MU extends Error{constructor(){super(...arguments);u(this,"name","InvalidDataLengthLengthError");u(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class b3 extends Error{constructor(){super(...arguments);u(this,"name","UnexpectedEOFError");u(this,"code","ERR_UNEXPECTED_EOF")}}const NU=8,LU=1024*1024*4;var Ws;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Ws||(Ws={}));const Z0=n=>{const t=yn(n);return Z0.bytes=$e(t),t};Z0.bytes=0;function tf(n,t){const e=new ye;let r=Ws.LENGTH,s=-1;const i=(t==null?void 0:t.lengthDecoder)??Z0,o=(t==null?void 0:t.maxLengthLength)??NU,a=(t==null?void 0:t.maxDataLength)??LU;function*c(){for(;e.byteLength>0;){if(r===Ws.LENGTH)try{if(s=i(e),s<0)throw new RU("Invalid message length");if(s>a)throw new BU("Message length too long");const l=i.bytes;e.consume(l),(t==null?void 0:t.onLength)!=null&&t.onLength(s),r=Ws.DATA}catch(l){if(l instanceof RangeError){if(e.byteLength>o)throw new MU("Message length length too long");break}throw l}if(r===Ws.DATA){if(e.byteLength<s)break;const l=e.sublist(0,s);e.consume(s),(t==null?void 0:t.onData)!=null&&t.onData(l),yield l,r=Ws.LENGTH}}}return ay(n)?async function*(){for await(const l of n)e.append(l),yield*c();if(e.byteLength>0)throw new b3("Unexpected end of input")}():function*(){for(const l of n)e.append(l),yield*c();if(e.byteLength>0)throw new b3("Unexpected end of input")}()}tf.fromReader=(n,t)=>{let e=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(e);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{e=1}}();return tf(r,{...t??{},onLength:i=>{e=i}})};const ea=1e3,J0=60*ea,v3="/floodsub/1.0.0",E3="/meshsub/1.0.0",OU="/meshsub/1.1.0",Ad="/meshsub/1.2.0",FU=6,UU=4,$U=12,zU=4,VU=2,HU=5,qU=3,WU=6,KU=.25,GU=3,S3=100,QU=ea,YU=J0,XU=16,ZU=J0,JU=10*ea,jU=15,e$=300,t$=ea,r$=60,n$=2,s$=10*ea,Fi=5e3,i$=10,o$=3*ea,a$=2*J0,c$=120*1e3,l$="ERR_TOPIC_VALIDATOR_REJECT",u$="ERR_TOPIC_VALIDATOR_IGNORE",h$=0,d$=128,f$=1e3,g$=1e3,p$=1,m$=512,y$=512,w$={maxSubscriptions:1/0,maxMessages:1/0,maxIhaveMessageIDs:1/0,maxIwantMessageIDs:1/0,maxIdontwantMessageIDs:1/0,maxControlMessages:1/0,maxPeerInfos:1/0};var si;(function(n){(function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.subscribe!=null&&(i.uint32(8),i.bool(s.subscribe)),s.topic!=null&&(i.uint32(18),i.string(s.topic)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.subscribe=s.bool();break}case 2:{a.topic=s.string();break}default:{s.skipType(l&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)})(n.SubOpts||(n.SubOpts={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.from!=null&&(i.uint32(10),i.bytes(s.from)),s.data!=null&&(i.uint32(18),i.bytes(s.data)),s.seqno!=null&&(i.uint32(26),i.bytes(s.seqno)),s.topic!=null&&s.topic!==""&&(i.uint32(34),i.string(s.topic)),s.signature!=null&&(i.uint32(42),i.bytes(s.signature)),s.key!=null&&(i.uint32(50),i.bytes(s.key)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={topic:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.from=s.bytes();break}case 2:{a.data=s.bytes();break}case 3:{a.seqno=s.bytes();break}case 4:{a.topic=s.string();break}case 5:{a.signature=s.bytes();break}case 6:{a.key=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.Message||(n.Message={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.ihave!=null)for(const a of s.ihave)i.uint32(10),n.ControlIHave.codec().encode(a,i);if(s.iwant!=null)for(const a of s.iwant)i.uint32(18),n.ControlIWant.codec().encode(a,i);if(s.graft!=null)for(const a of s.graft)i.uint32(26),n.ControlGraft.codec().encode(a,i);if(s.prune!=null)for(const a of s.prune)i.uint32(34),n.ControlPrune.codec().encode(a,i);if(s.idontwant!=null)for(const a of s.idontwant)i.uint32(42),n.ControlIDontWant.codec().encode(a,i);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l,h,d,f,g,y,p,w,v,x;const a={ihave:[],iwant:[],graft:[],prune:[],idontwant:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const S=s.uint32();switch(S>>>3){case 1:{if(((l=o.limits)==null?void 0:l.ihave)!=null&&a.ihave.length===o.limits.ihave)throw new Fe('Decode error - map field "ihave" had too many elements');a.ihave.push(n.ControlIHave.codec().decode(s,s.uint32(),{limits:(h=o.limits)==null?void 0:h.ihave$}));break}case 2:{if(((d=o.limits)==null?void 0:d.iwant)!=null&&a.iwant.length===o.limits.iwant)throw new Fe('Decode error - map field "iwant" had too many elements');a.iwant.push(n.ControlIWant.codec().decode(s,s.uint32(),{limits:(f=o.limits)==null?void 0:f.iwant$}));break}case 3:{if(((g=o.limits)==null?void 0:g.graft)!=null&&a.graft.length===o.limits.graft)throw new Fe('Decode error - map field "graft" had too many elements');a.graft.push(n.ControlGraft.codec().decode(s,s.uint32(),{limits:(y=o.limits)==null?void 0:y.graft$}));break}case 4:{if(((p=o.limits)==null?void 0:p.prune)!=null&&a.prune.length===o.limits.prune)throw new Fe('Decode error - map field "prune" had too many elements');a.prune.push(n.ControlPrune.codec().decode(s,s.uint32(),{limits:(w=o.limits)==null?void 0:w.prune$}));break}case 5:{if(((v=o.limits)==null?void 0:v.idontwant)!=null&&a.idontwant.length===o.limits.idontwant)throw new Fe('Decode error - map field "idontwant" had too many elements');a.idontwant.push(n.ControlIDontWant.codec().decode(s,s.uint32(),{limits:(x=o.limits)==null?void 0:x.idontwant$}));break}default:{s.skipType(S&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.ControlMessage||(n.ControlMessage={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.topicID!=null&&(i.uint32(10),i.string(s.topicID)),s.messageIDs!=null)for(const a of s.messageIDs)i.uint32(18),i.bytes(a);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l;const a={messageIDs:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const h=s.uint32();switch(h>>>3){case 1:{a.topicID=s.string();break}case 2:{if(((l=o.limits)==null?void 0:l.messageIDs)!=null&&a.messageIDs.length===o.limits.messageIDs)throw new Fe('Decode error - map field "messageIDs" had too many elements');a.messageIDs.push(s.bytes());break}default:{s.skipType(h&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.ControlIHave||(n.ControlIHave={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.messageIDs!=null)for(const a of s.messageIDs)i.uint32(10),i.bytes(a);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l;const a={messageIDs:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const h=s.uint32();switch(h>>>3){case 1:{if(((l=o.limits)==null?void 0:l.messageIDs)!=null&&a.messageIDs.length===o.limits.messageIDs)throw new Fe('Decode error - map field "messageIDs" had too many elements');a.messageIDs.push(s.bytes());break}default:{s.skipType(h&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.ControlIWant||(n.ControlIWant={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.topicID!=null&&(i.uint32(10),i.string(s.topicID)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.topicID=s.string();break}default:{s.skipType(l&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.ControlGraft||(n.ControlGraft={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.topicID!=null&&(i.uint32(10),i.string(s.topicID)),s.peers!=null)for(const a of s.peers)i.uint32(18),n.PeerInfo.codec().encode(a,i);s.backoff!=null&&(i.uint32(24),i.uint64Number(s.backoff)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l,h;const a={peers:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.topicID=s.string();break}case 2:{if(((l=o.limits)==null?void 0:l.peers)!=null&&a.peers.length===o.limits.peers)throw new Fe('Decode error - map field "peers" had too many elements');a.peers.push(n.PeerInfo.codec().decode(s,s.uint32(),{limits:(h=o.limits)==null?void 0:h.peers$}));break}case 3:{a.backoff=s.uint64Number();break}default:{s.skipType(d&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.ControlPrune||(n.ControlPrune={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.peerID!=null&&(i.uint32(10),i.bytes(s.peerID)),s.signedPeerRecord!=null&&(i.uint32(18),i.bytes(s.signedPeerRecord)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.peerID=s.bytes();break}case 2:{a.signedPeerRecord=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.PeerInfo||(n.PeerInfo={})),function(e){let r;e.codec=()=>(r==null&&(r=de((s,i,o={})=>{if(o.lengthDelimited!==!1&&i.fork(),s.messageIDs!=null)for(const a of s.messageIDs)i.uint32(10),i.bytes(a);o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var l;const a={messageIDs:[]},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const h=s.uint32();switch(h>>>3){case 1:{if(((l=o.limits)==null?void 0:l.messageIDs)!=null&&a.messageIDs.length===o.limits.messageIDs)throw new Fe('Decode error - map field "messageIDs" had too many elements');a.messageIDs.push(s.bytes());break}default:{s.skipType(h&7);break}}}return a})),r),e.encode=s=>he(s,e.codec()),e.decode=(s,i)=>ue(s,e.codec(),i)}(n.ControlIDontWant||(n.ControlIDontWant={}));let t;n.codec=()=>(t==null&&(t=de((e,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),e.subscriptions!=null)for(const i of e.subscriptions)r.uint32(10),n.SubOpts.codec().encode(i,r);if(e.messages!=null)for(const i of e.messages)r.uint32(18),n.Message.codec().encode(i,r);e.control!=null&&(r.uint32(26),n.ControlMessage.codec().encode(e.control,r)),s.lengthDelimited!==!1&&r.ldelim()},(e,r,s={})=>{var a,c,l,h,d;const i={subscriptions:[],messages:[]},o=r==null?e.len:e.pos+r;for(;e.pos<o;){const f=e.uint32();switch(f>>>3){case 1:{if(((a=s.limits)==null?void 0:a.subscriptions)!=null&&i.subscriptions.length===s.limits.subscriptions)throw new Fe('Decode error - map field "subscriptions" had too many elements');i.subscriptions.push(n.SubOpts.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.subscriptions$}));break}case 2:{if(((l=s.limits)==null?void 0:l.messages)!=null&&i.messages.length===s.limits.messages)throw new Fe('Decode error - map field "messages" had too many elements');i.messages.push(n.Message.codec().decode(e,e.uint32(),{limits:(h=s.limits)==null?void 0:h.messages$}));break}case 3:{i.control=n.ControlMessage.codec().decode(e,e.uint32(),{limits:(d=s.limits)==null?void 0:d.control});break}default:{e.skipType(f&7);break}}}return i})),t),n.encode=e=>he(e,n.codec()),n.decode=(e,r)=>ue(e,n.codec(),r)})(si||(si={}));class b${constructor(t,e,r){u(this,"gossip");u(this,"msgs",new Map);u(this,"msgIdToStrFn");u(this,"history",[]);u(this,"notValidatedCount",0);this.gossip=t,this.msgIdToStrFn=r;for(let s=0;s<e;s++)this.history[s]=[]}get size(){return this.msgs.size}put(t,e,r=!1){const{msgIdStr:s}=t;return this.msgs.has(s)?!1:(this.msgs.set(s,{message:e,validated:r,originatingPeers:new Set,iwantCounts:new Map}),this.history[0].push({...t,topic:e.topic}),r||this.notValidatedCount++,!0)}observeDuplicate(t,e){const r=this.msgs.get(t);r!=null&&!r.validated&&r.originatingPeers.add(e)}get(t){var e;return(e=this.msgs.get(this.msgIdToStrFn(t)))==null?void 0:e.message}getWithIWantCount(t,e){const r=this.msgs.get(t);if(r==null)return null;const s=(r.iwantCounts.get(e)??0)+1;return r.iwantCounts.set(e,s),{msg:r.message,count:s}}getGossipIDs(t){const e=new Map;for(let r=0;r<this.gossip;r++)this.history[r].forEach(s=>{const i=this.msgs.get(s.msgIdStr);if(((i==null?void 0:i.validated)??!1)&&t.has(s.topic)){let o=e.get(s.topic);o==null&&(o=[],e.set(s.topic,o)),o.push(s.msgId)}});return e}validate(t){const e=this.msgs.get(t);if(e==null)return null;e.validated||this.notValidatedCount--;const{message:r,originatingPeers:s}=e;return e.validated=!0,e.originatingPeers=new Set,{message:r,originatingPeers:s}}shift(){this.history[this.history.length-1].forEach(e=>{const r=this.msgs.get(e.msgIdStr);r!=null&&(this.msgs.delete(e.msgIdStr),r.validated||this.notValidatedCount--)}),this.history.pop(),this.history.unshift([])}remove(t){const e=this.msgs.get(t);return e==null?null:(this.msgs.delete(t),e)}}var x3;(function(n){n.StrictSign="StrictSign",n.StrictNoSign="StrictNoSign"})(x3||(x3={}));var Vo;(function(n){n[n.Signing=0]="Signing",n[n.Anonymous=1]="Anonymous"})(Vo||(Vo={}));var Hr;(function(n){n.Error="error",n.Ignore="ignore",n.Reject="reject",n.Blacklisted="blacklisted"})(Hr||(Hr={}));var Yt;(function(n){n.InvalidSignature="invalid_signature",n.InvalidSeqno="invalid_seqno",n.InvalidPeerId="invalid_peerid",n.SignaturePresent="signature_present",n.SeqnoPresent="seqno_present",n.FromPresent="from_present",n.TransformFailed="transform_failed"})(Yt||(Yt={}));var Zt;(function(n){n.duplicate="duplicate",n.invalid="invalid",n.valid="valid"})(Zt||(Zt={}));function _3(n){switch(n){case xr.Ignore:return Hr.Ignore;case xr.Reject:return Hr.Reject;default:throw new Error("Unreachable")}}var k3;(function(n){n.forward="forward",n.publish="publish"})(k3||(k3={}));var jt;(function(n){n.Fanout="fanout",n.Random="random",n.Subscribed="subscribed",n.Outbound="outbound",n.NotEnough="not_enough",n.Opportunistic="opportunistic"})(jt||(jt={}));var un;(function(n){n.Dc="disconnected",n.BadScore="bad_score",n.Prune="prune",n.Excess="excess"})(un||(un={}));var Aa;(function(n){n.GraftBackoff="graft_backoff",n.BrokenPromise="broken_promise",n.MessageDeficit="message_deficit",n.IPColocation="IP_colocation"})(Aa||(Aa={}));var Ta;(function(n){n.LowScore="low_score",n.MaxIhave="max_ihave",n.MaxIasked="max_iasked"})(Ta||(Ta={}));var Vi;(function(n){n.graylist="graylist",n.publish="publish",n.gossip="gossip",n.mesh="mesh"})(Vi||(Vi={}));function v$(n,t,e){return{protocolsEnabled:n.gauge({name:"gossipsub_protocol",help:"Status of enabled protocols",labelNames:["protocol"]}),topicSubscriptionStatus:n.gauge({name:"gossipsub_topic_subscription_status",help:"Status of our subscription to this topic",labelNames:["topicStr"]}),topicPeersCount:n.gauge({name:"gossipsub_topic_peer_count",help:"Number of peers subscribed to each topic",labelNames:["topicStr"]}),meshPeerCounts:n.gauge({name:"gossipsub_mesh_peer_count",help:"Number of peers in our mesh",labelNames:["topicStr"]}),meshPeerInclusionEventsFanout:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_fanout_total",help:"Number of times we include peers in a topic mesh for fanout reasons",labelNames:["topic"]}),meshPeerInclusionEventsRandom:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_random_total",help:"Number of times we include peers in a topic mesh for random reasons",labelNames:["topic"]}),meshPeerInclusionEventsSubscribed:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_subscribed_total",help:"Number of times we include peers in a topic mesh for subscribed reasons",labelNames:["topic"]}),meshPeerInclusionEventsOutbound:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_outbound_total",help:"Number of times we include peers in a topic mesh for outbound reasons",labelNames:["topic"]}),meshPeerInclusionEventsNotEnough:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_not_enough_total",help:"Number of times we include peers in a topic mesh for not_enough reasons",labelNames:["topic"]}),meshPeerInclusionEventsOpportunistic:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_opportunistic_total",help:"Number of times we include peers in a topic mesh for opportunistic reasons",labelNames:["topic"]}),meshPeerInclusionEventsUnknown:n.gauge({name:"gossipsub_mesh_peer_inclusion_events_unknown_total",help:"Number of times we include peers in a topic mesh for unknown reasons",labelNames:["topic"]}),meshPeerChurnEventsDisconnected:n.gauge({name:"gossipsub_peer_churn_events_disconnected_total",help:"Number of times we remove peers in a topic mesh for disconnected reasons",labelNames:["topic"]}),meshPeerChurnEventsBadScore:n.gauge({name:"gossipsub_peer_churn_events_bad_score_total",help:"Number of times we remove peers in a topic mesh for bad_score reasons",labelNames:["topic"]}),meshPeerChurnEventsPrune:n.gauge({name:"gossipsub_peer_churn_events_prune_total",help:"Number of times we remove peers in a topic mesh for prune reasons",labelNames:["topic"]}),meshPeerChurnEventsExcess:n.gauge({name:"gossipsub_peer_churn_events_excess_total",help:"Number of times we remove peers in a topic mesh for excess reasons",labelNames:["topic"]}),meshPeerChurnEventsUnknown:n.gauge({name:"gossipsub_peer_churn_events_unknown_total",help:"Number of times we remove peers in a topic mesh for unknown reasons",labelNames:["topic"]}),peersPerProtocol:n.gauge({name:"gossipsub_peers_per_protocol_count",help:"Peers connected for each topic",labelNames:["protocol"]}),heartbeatDuration:n.histogram({name:"gossipsub_heartbeat_duration_seconds",help:"The time it takes to complete one iteration of the heartbeat",buckets:[.01,.1,1]}),heartbeatSkipped:n.gauge({name:"gossipsub_heartbeat_skipped",help:"Heartbeat run took longer than heartbeat interval so next is skipped"}),acceptedMessagesTotal:n.gauge({name:"gossipsub_accepted_messages_total",help:"Total accepted messages for each topic",labelNames:["topic"]}),ignoredMessagesTotal:n.gauge({name:"gossipsub_ignored_messages_total",help:"Total ignored messages for each topic",labelNames:["topic"]}),rejectedMessagesTotal:n.gauge({name:"gossipsub_rejected_messages_total",help:"Total rejected messages for each topic",labelNames:["topic"]}),unknownValidationResultsTotal:n.gauge({name:"gossipsub_unknown_validation_results_total",help:"Total unknown validation results for each topic",labelNames:["topic"]}),asyncValidationMcacheHit:n.gauge({name:"gossipsub_async_validation_mcache_hit_total",help:"Async validation result reported by the user layer",labelNames:["hit"]}),asyncValidationDelayFromFirstSeenSec:n.histogram({name:"gossipsub_async_validation_delay_from_first_seen",help:"Async validation report delay from first seen in second",buckets:[.01,.03,.1,.3,1,3,10]}),asyncValidationUnknownFirstSeen:n.gauge({name:"gossipsub_async_validation_unknown_first_seen_count_total",help:"Async validation report unknown first seen value for message"}),peerReadStreamError:n.gauge({name:"gossipsub_peer_read_stream_err_count_total",help:"Peer read stream error"}),rpcRecvBytes:n.gauge({name:"gossipsub_rpc_recv_bytes_total",help:"RPC recv"}),rpcRecvCount:n.gauge({name:"gossipsub_rpc_recv_count_total",help:"RPC recv"}),rpcRecvSubscription:n.gauge({name:"gossipsub_rpc_recv_subscription_total",help:"RPC recv"}),rpcRecvMessage:n.gauge({name:"gossipsub_rpc_recv_message_total",help:"RPC recv"}),rpcRecvControl:n.gauge({name:"gossipsub_rpc_recv_control_total",help:"RPC recv"}),rpcRecvIHave:n.gauge({name:"gossipsub_rpc_recv_ihave_total",help:"RPC recv"}),rpcRecvIWant:n.gauge({name:"gossipsub_rpc_recv_iwant_total",help:"RPC recv"}),rpcRecvGraft:n.gauge({name:"gossipsub_rpc_recv_graft_total",help:"RPC recv"}),rpcRecvPrune:n.gauge({name:"gossipsub_rpc_recv_prune_total",help:"RPC recv"}),rpcDataError:n.gauge({name:"gossipsub_rpc_data_err_count_total",help:"RPC data error"}),rpcRecvError:n.gauge({name:"gossipsub_rpc_recv_err_count_total",help:"RPC recv error"}),rpcRecvNotAccepted:n.gauge({name:"gossipsub_rpc_rcv_not_accepted_total",help:"Total count of RPC dropped because acceptFrom() == false"}),rpcSentBytes:n.gauge({name:"gossipsub_rpc_sent_bytes_total",help:"RPC sent"}),rpcSentCount:n.gauge({name:"gossipsub_rpc_sent_count_total",help:"RPC sent"}),rpcSentSubscription:n.gauge({name:"gossipsub_rpc_sent_subscription_total",help:"RPC sent"}),rpcSentMessage:n.gauge({name:"gossipsub_rpc_sent_message_total",help:"RPC sent"}),rpcSentControl:n.gauge({name:"gossipsub_rpc_sent_control_total",help:"RPC sent"}),rpcSentIHave:n.gauge({name:"gossipsub_rpc_sent_ihave_total",help:"RPC sent"}),rpcSentIWant:n.gauge({name:"gossipsub_rpc_sent_iwant_total",help:"RPC sent"}),rpcSentGraft:n.gauge({name:"gossipsub_rpc_sent_graft_total",help:"RPC sent"}),rpcSentPrune:n.gauge({name:"gossipsub_rpc_sent_prune_total",help:"RPC sent"}),rpcSentIDontWant:n.gauge({name:"gossipsub_rpc_sent_idontwant_total",help:"RPC sent"}),msgPublishCount:n.gauge({name:"gossipsub_msg_publish_count_total",help:"Total count of msg published by topic",labelNames:["topic"]}),msgPublishPeersByTopic:n.gauge({name:"gossipsub_msg_publish_peers_total",help:"Total count of peers that we publish a msg to",labelNames:["topic"]}),directPeersPublishedTotal:n.gauge({name:"gossipsub_direct_peers_published_total",help:"Total direct peers that we publish a msg to",labelNames:["topic"]}),floodsubPeersPublishedTotal:n.gauge({name:"gossipsub_floodsub_peers_published_total",help:"Total floodsub peers that we publish a msg to",labelNames:["topic"]}),meshPeersPublishedTotal:n.gauge({name:"gossipsub_mesh_peers_published_total",help:"Total mesh peers that we publish a msg to",labelNames:["topic"]}),fanoutPeersPublishedTotal:n.gauge({name:"gossipsub_fanout_peers_published_total",help:"Total fanout peers that we publish a msg to",labelNames:["topic"]}),msgPublishBytes:n.gauge({name:"gossipsub_msg_publish_bytes_total",help:"Total count of msg publish data.length bytes",labelNames:["topic"]}),msgPublishTime:n.histogram({name:"gossipsub_msg_publish_seconds",help:"Total time in seconds to publish a message",buckets:[.001,.002,.005,.01,.1,.5,1],labelNames:["topic"]}),msgForwardCount:n.gauge({name:"gossipsub_msg_forward_count_total",help:"Total count of msg forwarded by topic",labelNames:["topic"]}),msgForwardPeers:n.gauge({name:"gossipsub_msg_forward_peers_total",help:"Total count of peers that we forward a msg to",labelNames:["topic"]}),msgReceivedPreValidation:n.gauge({name:"gossipsub_msg_received_prevalidation_total",help:"Total count of recv msgs before any validation",labelNames:["topic"]}),msgReceivedError:n.gauge({name:"gossipsub_msg_received_error_total",help:"Total count of recv msgs error",labelNames:["topic"]}),prevalidationInvalidTotal:n.gauge({name:"gossipsub_pre_validation_invalid_total",help:"Total count of invalid messages received",labelNames:["topic"]}),prevalidationValidTotal:n.gauge({name:"gossipsub_pre_validation_valid_total",help:"Total count of valid messages received",labelNames:["topic"]}),prevalidationDuplicateTotal:n.gauge({name:"gossipsub_pre_validation_duplicate_total",help:"Total count of duplicate messages received",labelNames:["topic"]}),prevalidationUnknownTotal:n.gauge({name:"gossipsub_pre_validation_unknown_status_total",help:"Total count of unknown_status messages received",labelNames:["topic"]}),msgReceivedInvalid:n.gauge({name:"gossipsub_msg_received_invalid_total",help:"Tracks specific reason of invalid",labelNames:["error"]}),msgReceivedInvalidByTopic:n.gauge({name:"gossipsub_msg_received_invalid_by_topic_total",help:"Tracks specific invalid message by topic",labelNames:["topic"]}),duplicateMsgDeliveryDelay:n.histogram({name:"gossisub_duplicate_msg_delivery_delay_seconds",help:"Time since the 1st duplicated message validated",labelNames:["topic"],buckets:[.25*e.maxMeshMessageDeliveriesWindowSec,.5*e.maxMeshMessageDeliveriesWindowSec,Number(e.maxMeshMessageDeliveriesWindowSec),2*e.maxMeshMessageDeliveriesWindowSec,4*e.maxMeshMessageDeliveriesWindowSec]}),duplicateMsgLateDelivery:n.gauge({name:"gossisub_duplicate_msg_late_delivery_total",help:"Total count of late duplicate message delivery by topic, which triggers P3 penalty",labelNames:["topic"]}),duplicateMsgIgnored:n.gauge({name:"gossisub_ignored_published_duplicate_msgs_total",help:"Total count of published duplicate message ignored by topic",labelNames:["topic"]}),scoreFnCalls:n.gauge({name:"gossipsub_score_fn_calls_total",help:"Total times score() is called"}),scoreFnRuns:n.gauge({name:"gossipsub_score_fn_runs_total",help:"Total times score() call actually computed computeScore(), no cache"}),scoreCachedDelta:n.histogram({name:"gossipsub_score_cache_delta",help:"Delta of score between cached values that expired",buckets:[10,100,1e3]}),peersByScoreThreshold:n.gauge({name:"gossipsub_peers_by_score_threshold_count",help:"Current count of peers by score threshold",labelNames:["threshold"]}),score:n.avgMinMax({name:"gossipsub_score",help:"Avg min max of gossip scores"}),scoreWeights:n.avgMinMax({name:"gossipsub_score_weights",help:"Separate score weights",labelNames:["topic","p"]}),scorePerMesh:n.avgMinMax({name:"gossipsub_score_per_mesh",help:"Histogram of the scores for each mesh topic",labelNames:["topic"]}),scoringPenalties:n.gauge({name:"gossipsub_scoring_penalties_total",help:"A counter of the kind of penalties being applied to peers",labelNames:["penalty"]}),behaviourPenalty:n.histogram({name:"gossipsub_peer_stat_behaviour_penalty",help:"Current peer stat behaviour_penalty at each scrape",buckets:[.25*e.behaviourPenaltyThreshold,.5*e.behaviourPenaltyThreshold,Number(e.behaviourPenaltyThreshold),2*e.behaviourPenaltyThreshold,4*e.behaviourPenaltyThreshold]}),ihaveRcvIgnored:n.gauge({name:"gossipsub_ihave_rcv_ignored_total",help:"Total received IHAVE messages that we ignore for some reason",labelNames:["reason"]}),ihaveRcvMsgids:n.gauge({name:"gossipsub_ihave_rcv_msgids_total",help:"Total received IHAVE messages by topic",labelNames:["topic"]}),ihaveRcvNotSeenMsgids:n.gauge({name:"gossipsub_ihave_rcv_not_seen_msgids_total",help:"Total messages per topic we do not have, not actual requests",labelNames:["topic"]}),iwantRcvMsgids:n.gauge({name:"gossipsub_iwant_rcv_msgids_total",help:"Total received IWANT messages by topic",labelNames:["topic"]}),iwantRcvDonthaveMsgids:n.gauge({name:"gossipsub_iwant_rcv_dont_have_msgids_total",help:"Total requested messageIDs that we do not have"}),idontwantRcvMsgids:n.gauge({name:"gossipsub_idontwant_rcv_msgids_total",help:"Total received IDONTWANT messages"}),idontwantRcvDonthaveMsgids:n.gauge({name:"gossipsub_idontwant_rcv_dont_have_msgids_total",help:"Total received IDONTWANT messageIDs that we do not have in mcache"}),iwantPromiseStarted:n.gauge({name:"gossipsub_iwant_promise_sent_total",help:"Total count of started IWANT promises"}),iwantPromiseResolved:n.gauge({name:"gossipsub_iwant_promise_resolved_total",help:"Total count of resolved IWANT promises"}),iwantPromiseResolvedFromDuplicate:n.gauge({name:"gossipsub_iwant_promise_resolved_from_duplicate_total",help:"Total count of resolved IWANT promises from duplicate messages"}),iwantPromiseResolvedPeers:n.gauge({name:"gossipsub_iwant_promise_resolved_peers",help:"Total count of peers we have asked IWANT promises that are resolved"}),iwantPromiseBroken:n.gauge({name:"gossipsub_iwant_promise_broken",help:"Total count of broken IWANT promises"}),iwantMessagePruned:n.gauge({name:"gossipsub_iwant_message_pruned",help:"Total count of pruned IWANT messages"}),iwantPromiseDeliveryTime:n.histogram({name:"gossipsub_iwant_promise_delivery_seconds",help:"Histogram of delivery time of resolved IWANT promises",buckets:[.5*e.gossipPromiseExpireSec,Number(e.gossipPromiseExpireSec),2*e.gossipPromiseExpireSec,4*e.gossipPromiseExpireSec]}),iwantPromiseUntracked:n.gauge({name:"gossip_iwant_promise_untracked",help:"Total count of untracked IWANT promise"}),connectedPeersBackoffSec:n.histogram({name:"gossipsub_connected_peers_backoff_seconds",help:"Backoff time in seconds",buckets:[1,2,4,10,20,60,120]}),cacheSize:n.gauge({name:"gossipsub_cache_size",help:"Unbounded cache sizes",labelNames:["cache"]}),mcacheSize:n.gauge({name:"gossipsub_mcache_size",help:"Current mcache msg count"}),mcacheNotValidatedCount:n.gauge({name:"gossipsub_mcache_not_validated_count",help:"Current mcache msg count not validated"}),fastMsgIdCacheCollision:n.gauge({name:"gossipsub_fastmsgid_cache_collision_total",help:"Total count of key collisions on fastmsgid cache put"}),newConnectionCount:n.gauge({name:"gossipsub_new_connection_total",help:"Total new connection by status",labelNames:["status"]}),topicStrToLabel:t,toTopic(r){return this.topicStrToLabel.get(r)??r},onJoin(r){this.topicSubscriptionStatus.set({topicStr:r},1),this.meshPeerCounts.set({topicStr:r},0)},onLeave(r){this.topicSubscriptionStatus.set({topicStr:r},0),this.meshPeerCounts.set({topicStr:r},0)},onAddToMesh(r,s,i){const o=this.toTopic(r);switch(s){case jt.Fanout:this.meshPeerInclusionEventsFanout.inc({topic:o},i);break;case jt.Random:this.meshPeerInclusionEventsRandom.inc({topic:o},i);break;case jt.Subscribed:this.meshPeerInclusionEventsSubscribed.inc({topic:o},i);break;case jt.Outbound:this.meshPeerInclusionEventsOutbound.inc({topic:o},i);break;case jt.NotEnough:this.meshPeerInclusionEventsNotEnough.inc({topic:o},i);break;case jt.Opportunistic:this.meshPeerInclusionEventsOpportunistic.inc({topic:o},i);break;default:this.meshPeerInclusionEventsUnknown.inc({topic:o},i);break}},onRemoveFromMesh(r,s,i){const o=this.toTopic(r);switch(s){case un.Dc:this.meshPeerChurnEventsDisconnected.inc({topic:o},i);break;case un.BadScore:this.meshPeerChurnEventsBadScore.inc({topic:o},i);break;case un.Prune:this.meshPeerChurnEventsPrune.inc({topic:o},i);break;case un.Excess:this.meshPeerChurnEventsExcess.inc({topic:o},i);break;default:this.meshPeerChurnEventsUnknown.inc({topic:o},i);break}},onReportValidation(r,s,i){if(this.asyncValidationMcacheHit.inc({hit:r!=null?"hit":"miss"}),r!=null){const o=this.toTopic(r.message.topic);switch(s){case xr.Accept:this.acceptedMessagesTotal.inc({topic:o});break;case xr.Ignore:this.ignoredMessagesTotal.inc({topic:o});break;case xr.Reject:this.rejectedMessagesTotal.inc({topic:o});break;default:this.unknownValidationResultsTotal.inc({topic:o});break}}i!=null?this.asyncValidationDelayFromFirstSeenSec.observe((Date.now()-i)/1e3):this.asyncValidationUnknownFirstSeen.inc()},onScorePenalty(r){this.scoringPenalties.inc({penalty:r},1)},onIhaveRcv(r,s,i){const o=this.toTopic(r);this.ihaveRcvMsgids.inc({topic:o},s),this.ihaveRcvNotSeenMsgids.inc({topic:o},i)},onIwantRcv(r,s){for(const[i,o]of r){const a=this.toTopic(i);this.iwantRcvMsgids.inc({topic:a},o)}this.iwantRcvDonthaveMsgids.inc(s)},onIdontwantRcv(r,s){this.idontwantRcvMsgids.inc(r),this.idontwantRcvDonthaveMsgids.inc(s)},onForwardMsg(r,s){const i=this.toTopic(r);this.msgForwardCount.inc({topic:i},1),this.msgForwardPeers.inc({topic:i},s)},onPublishMsg(r,s,i,o,a){const c=this.toTopic(r);this.msgPublishCount.inc({topic:c},1),this.msgPublishBytes.inc({topic:c},i*o),this.msgPublishPeersByTopic.inc({topic:c},i),this.directPeersPublishedTotal.inc({topic:c},s.direct),this.floodsubPeersPublishedTotal.inc({topic:c},s.floodsub),this.meshPeersPublishedTotal.inc({topic:c},s.mesh),this.fanoutPeersPublishedTotal.inc({topic:c},s.fanout),this.msgPublishTime.observe({topic:c},a/1e3)},onMsgRecvPreValidation(r){const s=this.toTopic(r);this.msgReceivedPreValidation.inc({topic:s},1)},onMsgRecvError(r){const s=this.toTopic(r);this.msgReceivedError.inc({topic:s},1)},onPrevalidationResult(r,s){const i=this.toTopic(r);switch(s){case Zt.duplicate:this.prevalidationDuplicateTotal.inc({topic:i});break;case Zt.invalid:this.prevalidationInvalidTotal.inc({topic:i});break;case Zt.valid:this.prevalidationValidTotal.inc({topic:i});break;default:this.prevalidationUnknownTotal.inc({topic:i});break}},onMsgRecvInvalid(r,s){const i=this.toTopic(r),o=s.reason===Hr.Error?s.error:s.reason;this.msgReceivedInvalid.inc({error:o},1),this.msgReceivedInvalidByTopic.inc({topic:i},1)},onDuplicateMsgDelivery(r,s,i){const o=this.toTopic(r);this.duplicateMsgDeliveryDelay.observe({topic:o},s/1e3),i&&this.duplicateMsgLateDelivery.inc({topic:o},1)},onPublishDuplicateMsg(r){const s=this.toTopic(r);this.duplicateMsgIgnored.inc({topic:s},1)},onPeerReadStreamError(){this.peerReadStreamError.inc(1)},onRpcRecvError(){this.rpcRecvError.inc(1)},onRpcDataError(){this.rpcDataError.inc(1)},onRpcRecv(r,s){this.rpcRecvBytes.inc(s),this.rpcRecvCount.inc(1),r.subscriptions!=null&&this.rpcRecvSubscription.inc(r.subscriptions.length),r.messages!=null&&this.rpcRecvMessage.inc(r.messages.length),r.control!=null&&(this.rpcRecvControl.inc(1),r.control.ihave!=null&&this.rpcRecvIHave.inc(r.control.ihave.length),r.control.iwant!=null&&this.rpcRecvIWant.inc(r.control.iwant.length),r.control.graft!=null&&this.rpcRecvGraft.inc(r.control.graft.length),r.control.prune!=null&&this.rpcRecvPrune.inc(r.control.prune.length))},onRpcSent(r,s){var i,o,a,c,l;if(this.rpcSentBytes.inc(s),this.rpcSentCount.inc(1),r.subscriptions!=null&&this.rpcSentSubscription.inc(r.subscriptions.length),r.messages!=null&&this.rpcSentMessage.inc(r.messages.length),r.control!=null){const h=((i=r.control.ihave)==null?void 0:i.length)??0,d=((o=r.control.iwant)==null?void 0:o.length)??0,f=((a=r.control.graft)==null?void 0:a.length)??0,g=((c=r.control.prune)==null?void 0:c.length)??0,y=((l=r.control.idontwant)==null?void 0:l.length)??0;h>0&&this.rpcSentIHave.inc(h),d>0&&this.rpcSentIWant.inc(d),f>0&&this.rpcSentGraft.inc(f),g>0&&this.rpcSentPrune.inc(g),y>0&&this.rpcSentIDontWant.inc(y),(h>0||d>0||f>0||g>0||y>0)&&this.rpcSentControl.inc(1)}},registerScores(r,s){let i=0,o=0,a=0,c=0;for(const l of r)l>=s.graylistThreshold&&i++,l>=s.publishThreshold&&o++,l>=s.gossipThreshold&&a++,l>=0&&c++;this.peersByScoreThreshold.set({threshold:Vi.graylist},i),this.peersByScoreThreshold.set({threshold:Vi.publish},o),this.peersByScoreThreshold.set({threshold:Vi.gossip},a),this.peersByScoreThreshold.set({threshold:Vi.mesh},c),this.score.set(r)},registerScoreWeights(r){for(const[s,i]of r.byTopic)this.scoreWeights.set({topic:s,p:"p1"},i.p1w),this.scoreWeights.set({topic:s,p:"p2"},i.p2w),this.scoreWeights.set({topic:s,p:"p3"},i.p3w),this.scoreWeights.set({topic:s,p:"p3b"},i.p3bw),this.scoreWeights.set({topic:s,p:"p4"},i.p4w);this.scoreWeights.set({p:"p5"},r.p5w),this.scoreWeights.set({p:"p6"},r.p6w),this.scoreWeights.set({p:"p7"},r.p7w)},registerScorePerMesh(r,s){const i=new Map;r.forEach((o,a)=>{const c=this.topicStrToLabel.get(a)??"unknown";let l=i.get(c);l==null&&(l=new Set,i.set(c,l)),o.forEach(h=>l==null?void 0:l.add(h))});for(const[o,a]of i){const c=[];a.forEach(l=>{c.push(s.get(l)??0)}),this.scorePerMesh.set({topic:o},c)}}}}class Oe extends Error{constructor(t="Invalid peer score params"){super(t),this.name="InvalidPeerScoreParamsError"}}u(Oe,"name","InvalidPeerScoreParamsError");const E$={topics:{},topicScoreCap:10,appSpecificScore:()=>0,appSpecificWeight:10,IPColocationFactorWeight:-5,IPColocationFactorThreshold:10,IPColocationFactorWhitelist:new Set,behaviourPenaltyWeight:-10,behaviourPenaltyThreshold:0,behaviourPenaltyDecay:.2,decayInterval:1e3,decayToZero:.1,retainScore:3600*1e3},S$={topicWeight:.5,timeInMeshWeight:1,timeInMeshQuantum:1,timeInMeshCap:3600,firstMessageDeliveriesWeight:1,firstMessageDeliveriesDecay:.5,firstMessageDeliveriesCap:2e3,meshMessageDeliveriesWeight:-1,meshMessageDeliveriesDecay:.5,meshMessageDeliveriesCap:100,meshMessageDeliveriesThreshold:20,meshMessageDeliveriesWindow:10,meshMessageDeliveriesActivation:5e3,meshFailurePenaltyWeight:-1,meshFailurePenaltyDecay:.5,invalidMessageDeliveriesWeight:-1,invalidMessageDeliveriesDecay:.3};function x$(n={}){return{...E$,...n,topics:n.topics!=null?Object.entries(n.topics).reduce((t,[e,r])=>(t[e]=_$(r),t),{}):{}}}function _$(n={}){return{...S$,...n}}function k$(n){for(const[t,e]of Object.entries(n.topics))try{I$(e)}catch(r){throw new Oe(`invalid score parameters for topic ${t}: ${r.message}`)}if(n.topicScoreCap<0)throw new Oe("invalid topic score cap; must be positive (or 0 for no cap)");if(n.appSpecificScore===null||n.appSpecificScore===void 0)throw new Oe("missing application specific score function");if(n.IPColocationFactorWeight>0)throw new Oe("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");if(n.IPColocationFactorWeight!==0&&n.IPColocationFactorThreshold<1)throw new Oe("invalid IPColocationFactorThreshold; must be at least 1");if(n.behaviourPenaltyWeight>0)throw new Oe("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");if(n.behaviourPenaltyWeight!==0&&(n.behaviourPenaltyDecay<=0||n.behaviourPenaltyDecay>=1))throw new Oe("invalid BehaviourPenaltyDecay; must be between 0 and 1");if(n.decayInterval<1e3)throw new Oe("invalid DecayInterval; must be at least 1s");if(n.decayToZero<=0||n.decayToZero>=1)throw new Oe("invalid DecayToZero; must be between 0 and 1")}function I$(n){if(n.topicWeight<0)throw new Oe("invalid topic weight; must be >= 0");if(n.timeInMeshQuantum===0)throw new Oe("invalid TimeInMeshQuantum; must be non zero");if(n.timeInMeshWeight<0)throw new Oe("invalid TimeInMeshWeight; must be positive (or 0 to disable)");if(n.timeInMeshWeight!==0&&n.timeInMeshQuantum<=0)throw new Oe("invalid TimeInMeshQuantum; must be positive");if(n.timeInMeshWeight!==0&&n.timeInMeshCap<=0)throw new Oe("invalid TimeInMeshCap; must be positive");if(n.firstMessageDeliveriesWeight<0)throw new Oe("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");if(n.firstMessageDeliveriesWeight!==0&&(n.firstMessageDeliveriesDecay<=0||n.firstMessageDeliveriesDecay>=1))throw new Oe("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");if(n.firstMessageDeliveriesWeight!==0&&n.firstMessageDeliveriesCap<=0)throw new Oe("invalid FirstMessageDeliveriesCap; must be positive");if(n.meshMessageDeliveriesWeight>0)throw new Oe("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");if(n.meshMessageDeliveriesWeight!==0&&(n.meshMessageDeliveriesDecay<=0||n.meshMessageDeliveriesDecay>=1))throw new Oe("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");if(n.meshMessageDeliveriesWeight!==0&&n.meshMessageDeliveriesCap<=0)throw new Oe("invalid MeshMessageDeliveriesCap; must be positive");if(n.meshMessageDeliveriesWeight!==0&&n.meshMessageDeliveriesThreshold<=0)throw new Oe("invalid MeshMessageDeliveriesThreshold; must be positive");if(n.meshMessageDeliveriesWindow<0)throw new Oe("invalid MeshMessageDeliveriesWindow; must be non-negative");if(n.meshMessageDeliveriesWeight!==0&&n.meshMessageDeliveriesActivation<1e3)throw new Oe("invalid MeshMessageDeliveriesActivation; must be at least 1s");if(n.meshFailurePenaltyWeight>0)throw new Oe("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");if(n.meshFailurePenaltyWeight!==0&&(n.meshFailurePenaltyDecay<=0||n.meshFailurePenaltyDecay>=1))throw new Oe("invalid MeshFailurePenaltyDecay; must be between 0 and 1");if(n.invalidMessageDeliveriesWeight>0)throw new Oe("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");if(n.invalidMessageDeliveriesDecay<=0||n.invalidMessageDeliveriesDecay>=1)throw new Oe("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1")}const A$={gossipThreshold:-10,publishThreshold:-50,graylistThreshold:-80,acceptPXThreshold:10,opportunisticGraftThreshold:20};function T$(n={}){return{...A$,...n}}function rf(n,t,e=()=>!0){const r=new Set;if(t<=0)return r;for(const s of n){if(r.size>=t)break;e(s)&&(r.add(s),n.delete(s))}return r}function C$(n,t){return rf(n,t,()=>!0)}class P$ extends Map{constructor(e){super();u(this,"getDefault");this.getDefault=e}getOrDefault(e){let r=super.get(e);return r===void 0&&(r=this.getDefault(),this.set(e,r)),r}}function D$(n,t,e,r){let s=0;Object.entries(t.topics).forEach(([o,a])=>{const c=e.topics[o];if(c===void 0)return;let l=0;if(a.inMesh){let g=a.meshTime/c.timeInMeshQuantum;g>c.timeInMeshCap&&(g=c.timeInMeshCap),l+=g*c.timeInMeshWeight}let h=a.firstMessageDeliveries;if(h>c.firstMessageDeliveriesCap&&(h=c.firstMessageDeliveriesCap),l+=h*c.firstMessageDeliveriesWeight,a.meshMessageDeliveriesActive&&a.meshMessageDeliveries<c.meshMessageDeliveriesThreshold){const g=c.meshMessageDeliveriesThreshold-a.meshMessageDeliveries,y=g*g;l+=y*c.meshMessageDeliveriesWeight}const d=a.meshFailurePenalty;l+=d*c.meshFailurePenaltyWeight;const f=a.invalidMessageDeliveries*a.invalidMessageDeliveries;l+=f*c.invalidMessageDeliveriesWeight,s+=l*c.topicWeight}),e.topicScoreCap>0&&s>e.topicScoreCap&&(s=e.topicScoreCap);const i=e.appSpecificScore(n);if(s+=i*e.appSpecificWeight,t.knownIPs.forEach(o=>{if(e.IPColocationFactorWhitelist.has(o))return;const a=r.get(o),c=a!=null?a.size:0;if(c>e.IPColocationFactorThreshold){const l=c-e.IPColocationFactorThreshold,h=l*l;s+=h*e.IPColocationFactorWeight}}),t.behaviourPenalty>e.behaviourPenaltyThreshold){const o=t.behaviourPenalty-e.behaviourPenaltyThreshold,a=o*o;s+=a*e.behaviourPenaltyWeight}return s}var Td,I3;function R$(){if(I3)return Td;I3=1;function n(t,r){var r=r||{};this._capacity=r.capacity,this._head=0,this._tail=0,Array.isArray(t)?this._fromArray(t):(this._capacityMask=3,this._list=new Array(4))}return n.prototype.peekAt=function(e){var r=e;if(r===(r|0)){var s=this.size();if(!(r>=s||r<-s))return r<0&&(r+=s),r=this._head+r&this._capacityMask,this._list[r]}},n.prototype.get=function(e){return this.peekAt(e)},n.prototype.peek=function(){if(this._head!==this._tail)return this._list[this._head]},n.prototype.peekFront=function(){return this.peek()},n.prototype.peekBack=function(){return this.peekAt(-1)},Object.defineProperty(n.prototype,"length",{get:function(){return this.size()}}),n.prototype.size=function(){return this._head===this._tail?0:this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},n.prototype.unshift=function(e){if(arguments.length===0)return this.size();var r=this._list.length;return this._head=this._head-1+r&this._capacityMask,this._list[this._head]=e,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.pop(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},n.prototype.shift=function(){var e=this._head;if(e!==this._tail){var r=this._list[e];return this._list[e]=void 0,this._head=e+1&this._capacityMask,e<2&&this._tail>1e4&&this._tail<=this._list.length>>>2&&this._shrinkArray(),r}},n.prototype.push=function(e){if(arguments.length===0)return this.size();var r=this._tail;return this._list[r]=e,this._tail=r+1&this._capacityMask,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.shift(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},n.prototype.pop=function(){var e=this._tail;if(e!==this._head){var r=this._list.length;this._tail=e-1+r&this._capacityMask;var s=this._list[this._tail];return this._list[this._tail]=void 0,this._head<2&&e>1e4&&e<=r>>>2&&this._shrinkArray(),s}},n.prototype.removeOne=function(e){var r=e;if(r===(r|0)&&this._head!==this._tail){var s=this.size(),i=this._list.length;if(!(r>=s||r<-s)){r<0&&(r+=s),r=this._head+r&this._capacityMask;var o=this._list[r],a;if(e<s/2){for(a=e;a>0;a--)this._list[r]=this._list[r=r-1+i&this._capacityMask];this._list[r]=void 0,this._head=this._head+1+i&this._capacityMask}else{for(a=s-1-e;a>0;a--)this._list[r]=this._list[r=r+1+i&this._capacityMask];this._list[r]=void 0,this._tail=this._tail-1+i&this._capacityMask}return o}}},n.prototype.remove=function(e,r){var s=e,i,o=r;if(s===(s|0)&&this._head!==this._tail){var a=this.size(),c=this._list.length;if(!(s>=a||s<-a||r<1)){if(s<0&&(s+=a),r===1||!r)return i=new Array(1),i[0]=this.removeOne(s),i;if(s===0&&s+r>=a)return i=this.toArray(),this.clear(),i;s+r>a&&(r=a-s);var l;for(i=new Array(r),l=0;l<r;l++)i[l]=this._list[this._head+s+l&this._capacityMask];if(s=this._head+s&this._capacityMask,e+r===a){for(this._tail=this._tail-r+c&this._capacityMask,l=r;l>0;l--)this._list[s=s+1+c&this._capacityMask]=void 0;return i}if(e===0){for(this._head=this._head+r+c&this._capacityMask,l=r-1;l>0;l--)this._list[s=s+1+c&this._capacityMask]=void 0;return i}if(s<a/2){for(this._head=this._head+e+r+c&this._capacityMask,l=e;l>0;l--)this.unshift(this._list[s=s-1+c&this._capacityMask]);for(s=this._head-1+c&this._capacityMask;o>0;)this._list[s=s-1+c&this._capacityMask]=void 0,o--;e<0&&(this._tail=s)}else{for(this._tail=s,s=s+r+c&this._capacityMask,l=a-(r+e);l>0;l--)this.push(this._list[s++]);for(s=this._tail;o>0;)this._list[s=s+1+c&this._capacityMask]=void 0,o--}return this._head<2&&this._tail>1e4&&this._tail<=c>>>2&&this._shrinkArray(),i}}},n.prototype.splice=function(e,r){var s=e;if(s===(s|0)){var i=this.size();if(s<0&&(s+=i),!(s>i))if(arguments.length>2){var o,a,c,l=arguments.length,h=this._list.length,d=2;if(!i||s<i/2){for(a=new Array(s),o=0;o<s;o++)a[o]=this._list[this._head+o&this._capacityMask];for(r===0?(c=[],s>0&&(this._head=this._head+s+h&this._capacityMask)):(c=this.remove(s,r),this._head=this._head+s+h&this._capacityMask);l>d;)this.unshift(arguments[--l]);for(o=s;o>0;o--)this.unshift(a[o-1])}else{a=new Array(i-(s+r));var f=a.length;for(o=0;o<f;o++)a[o]=this._list[this._head+s+r+o&this._capacityMask];for(r===0?(c=[],s!=i&&(this._tail=this._head+s+h&this._capacityMask)):(c=this.remove(s,r),this._tail=this._tail-f+h&this._capacityMask);d<l;)this.push(arguments[d++]);for(o=0;o<f;o++)this.push(a[o])}return c}else return this.remove(s,r)}},n.prototype.clear=function(){this._list=new Array(this._list.length),this._head=0,this._tail=0},n.prototype.isEmpty=function(){return this._head===this._tail},n.prototype.toArray=function(){return this._copyArray(!1)},n.prototype._fromArray=function(e){var r=e.length,s=this._nextPowerOf2(r);this._list=new Array(s),this._capacityMask=s-1,this._tail=r;for(var i=0;i<r;i++)this._list[i]=e[i]},n.prototype._copyArray=function(e,r){var s=this._list,i=s.length,o=this.length;if(r=r|o,r==o&&this._head<this._tail)return this._list.slice(this._head,this._tail);var a=new Array(r),c=0,l;if(e||this._head>this._tail){for(l=this._head;l<i;l++)a[c++]=s[l];for(l=0;l<this._tail;l++)a[c++]=s[l]}else for(l=this._head;l<this._tail;l++)a[c++]=s[l];return a},n.prototype._growArray=function(){if(this._head!=0){var e=this._copyArray(!0,this._list.length<<1);this._tail=this._list.length,this._head=0,this._list=e}else this._tail=this._list.length,this._list.length<<=1;this._capacityMask=this._capacityMask<<1|1},n.prototype._shrinkArray=function(){this._list.length>>>=1,this._capacityMask>>>=1},n.prototype._nextPowerOf2=function(e){var r=Math.log(e)/Math.log(2),s=1<<r+1;return Math.max(s,4)},Td=n,Td}var B$=R$();const M$=Fn(B$);var Xt;(function(n){n[n.unknown=0]="unknown",n[n.valid=1]="valid",n[n.invalid=2]="invalid",n[n.ignored=3]="ignored"})(Xt||(Xt={}));class N${constructor(){u(this,"records");u(this,"queue");this.records=new Map,this.queue=new M$}getRecord(t){return this.records.get(t)}ensureRecord(t){let e=this.records.get(t);if(e!=null)return e;e={status:Xt.unknown,firstSeenTsMs:Date.now(),validated:0,peers:new Set},this.records.set(t,e);const r={msgId:t,expire:Date.now()+c$};return this.queue.push(r),e}gc(){const t=Date.now();let e=this.queue.peekFront();for(;e!=null&&e.expire<t;)this.records.delete(e.msgId),this.queue.shift(),e=this.queue.peekFront()}clear(){this.records.clear(),this.queue.clear()}}class L${constructor(t,e,r,s){u(this,"params");u(this,"metrics");u(this,"peerStats",new Map);u(this,"peerIPs",new P$(()=>new Set));u(this,"scoreCache",new Map);u(this,"deliveryRecords",new N$);u(this,"_backgroundInterval");u(this,"scoreCacheValidityMs");u(this,"computeScore");u(this,"log");this.params=t,this.metrics=e,k$(t),this.scoreCacheValidityMs=s.scoreCacheValidityMs,this.computeScore=s.computeScore??D$,this.log=r.forComponent("libp2p:gossipsub:score")}get size(){return this.peerStats.size}start(){if(this._backgroundInterval!=null){this.log("Peer score already running");return}this._backgroundInterval=setInterval(()=>{this.background()},this.params.decayInterval),this.log("started")}stop(){if(this._backgroundInterval==null){this.log("Peer score already stopped");return}clearInterval(this._backgroundInterval),delete this._backgroundInterval,this.peerIPs.clear(),this.peerStats.clear(),this.deliveryRecords.clear(),this.log("stopped")}background(){this.refreshScores(),this.deliveryRecords.gc()}dumpPeerScoreStats(){return Object.fromEntries(Array.from(this.peerStats.entries()).map(([t,e])=>[t,e]))}messageFirstSeenTimestampMs(t){const e=this.deliveryRecords.getRecord(t);return e!=null?e.firstSeenTsMs:null}refreshScores(){const t=Date.now(),e=this.params.decayToZero;this.peerStats.forEach((r,s)=>{if(!r.connected){t>r.expire&&(this.removeIPsForPeer(s,r.knownIPs),this.peerStats.delete(s),this.scoreCache.delete(s));return}Object.entries(r.topics).forEach(([i,o])=>{const a=this.params.topics[i];a!==void 0&&(o.firstMessageDeliveries*=a.firstMessageDeliveriesDecay,o.firstMessageDeliveries<e&&(o.firstMessageDeliveries=0),o.meshMessageDeliveries*=a.meshMessageDeliveriesDecay,o.meshMessageDeliveries<e&&(o.meshMessageDeliveries=0),o.meshFailurePenalty*=a.meshFailurePenaltyDecay,o.meshFailurePenalty<e&&(o.meshFailurePenalty=0),o.invalidMessageDeliveries*=a.invalidMessageDeliveriesDecay,o.invalidMessageDeliveries<e&&(o.invalidMessageDeliveries=0),o.inMesh&&(o.meshTime=t-o.graftTime,o.meshTime>a.meshMessageDeliveriesActivation&&(o.meshMessageDeliveriesActive=!0)))}),r.behaviourPenalty*=this.params.behaviourPenaltyDecay,r.behaviourPenalty<e&&(r.behaviourPenalty=0)})}score(t){var a,c,l;(a=this.metrics)==null||a.scoreFnCalls.inc();const e=this.peerStats.get(t);if(e==null)return 0;const r=Date.now(),s=this.scoreCache.get(t);if(s!=null&&s.cacheUntil>r)return s.score;(c=this.metrics)==null||c.scoreFnRuns.inc();const i=this.computeScore(t,e,this.params,this.peerIPs),o=r+this.scoreCacheValidityMs;return s!=null?((l=this.metrics)==null||l.scoreCachedDelta.observe(Math.abs(i-s.score)),s.score=i,s.cacheUntil=o):this.scoreCache.set(t,{score:i,cacheUntil:o}),i}addPenalty(t,e,r){var i;const s=this.peerStats.get(t);s!=null&&(s.behaviourPenalty+=e,(i=this.metrics)==null||i.onScorePenalty(r))}addPeer(t){const e={connected:!0,expire:0,topics:{},knownIPs:new Set,behaviourPenalty:0};this.peerStats.set(t,e)}addIP(t,e){const r=this.peerStats.get(t);r!=null&&r.knownIPs.add(e),this.peerIPs.getOrDefault(e).add(t)}removeIP(t,e){const r=this.peerStats.get(t);r!=null&&r.knownIPs.delete(e);const s=this.peerIPs.get(e);s!=null&&(s.delete(t),s.size===0&&this.peerIPs.delete(e))}removePeer(t){const e=this.peerStats.get(t);if(e!=null){if(this.score(t)>0){this.removeIPsForPeer(t,e.knownIPs),this.peerStats.delete(t);return}Object.entries(e.topics).forEach(([r,s])=>{s.firstMessageDeliveries=0;const i=this.params.topics[r].meshMessageDeliveriesThreshold;if(s.inMesh&&s.meshMessageDeliveriesActive&&s.meshMessageDeliveries<i){const o=i-s.meshMessageDeliveries;s.meshFailurePenalty+=o*o}s.inMesh=!1,s.meshMessageDeliveriesActive=!1}),e.connected=!1,e.expire=Date.now()+this.params.retainScore}}graft(t,e){const r=this.peerStats.get(t);if(r!=null){const s=this.getPtopicStats(r,e);s!=null&&(s.inMesh=!0,s.graftTime=Date.now(),s.meshTime=0,s.meshMessageDeliveriesActive=!1)}}prune(t,e){const r=this.peerStats.get(t);if(r!=null){const s=this.getPtopicStats(r,e);if(s!=null){const i=this.params.topics[e].meshMessageDeliveriesThreshold;if(s.meshMessageDeliveriesActive&&s.meshMessageDeliveries<i){const o=i-s.meshMessageDeliveries;s.meshFailurePenalty+=o*o}s.meshMessageDeliveriesActive=!1,s.inMesh=!1}}}validateMessage(t){this.deliveryRecords.ensureRecord(t)}deliverMessage(t,e,r){this.markFirstMessageDelivery(t,r);const s=this.deliveryRecords.ensureRecord(e),i=Date.now();if(s.status!==Xt.unknown){this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s",t,i-s.firstSeenTsMs,Xt[s.status]);return}s.status=Xt.valid,s.validated=i,s.peers.forEach(o=>{o!==t.toString()&&this.markDuplicateMessageDelivery(o,r)})}rejectInvalidMessage(t,e){this.markInvalidMessageDelivery(t,e)}rejectMessage(t,e,r,s){switch(s){case Hr.Error:this.markInvalidMessageDelivery(t,r);return;case Hr.Blacklisted:return}const i=this.deliveryRecords.ensureRecord(e);if(i.status!==Xt.unknown){this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d",t,Date.now()-i.firstSeenTsMs,Xt[i.status]);return}if(s===Hr.Ignore){i.status=Xt.ignored,i.peers.clear();return}i.status=Xt.invalid,this.markInvalidMessageDelivery(t,r),i.peers.forEach(o=>{this.markInvalidMessageDelivery(o,r)}),i.peers.clear()}duplicateMessage(t,e,r){const s=this.deliveryRecords.ensureRecord(e);if(!s.peers.has(t))switch(s.status){case Xt.unknown:s.peers.add(t);break;case Xt.valid:s.peers.add(t),this.markDuplicateMessageDelivery(t,r,s.validated);break;case Xt.invalid:this.markInvalidMessageDelivery(t,r);break;case Xt.ignored:break}}markInvalidMessageDelivery(t,e){const r=this.peerStats.get(t);if(r!=null){const s=this.getPtopicStats(r,e);s!=null&&(s.invalidMessageDeliveries+=1)}}markFirstMessageDelivery(t,e){const r=this.peerStats.get(t);if(r!=null){const s=this.getPtopicStats(r,e);if(s!=null){let i=this.params.topics[e].firstMessageDeliveriesCap;s.firstMessageDeliveries=Math.min(i,s.firstMessageDeliveries+1),s.inMesh&&(i=this.params.topics[e].meshMessageDeliveriesCap,s.meshMessageDeliveries=Math.min(i,s.meshMessageDeliveries+1))}}}markDuplicateMessageDelivery(t,e,r){var i;const s=this.peerStats.get(t);if(s!=null){const o=r!==void 0?Date.now():0,a=this.getPtopicStats(s,e);if(a!=null&&a.inMesh){const c=this.params.topics[e];if(r!==void 0){const h=o-r,d=h>c.meshMessageDeliveriesWindow;if((i=this.metrics)==null||i.onDuplicateMsgDelivery(e,h,d),d)return}const l=c.meshMessageDeliveriesCap;a.meshMessageDeliveries=Math.min(l,a.meshMessageDeliveries+1)}}}removeIPsForPeer(t,e){for(const r of e){const s=this.peerIPs.get(r);s!=null&&(s.delete(t),s.size===0&&this.peerIPs.delete(r))}}getPtopicStats(t,e){let r=t.topics[e];return r!==void 0?r:this.params.topics[e]!==void 0?(r={inMesh:!1,graftTime:0,meshTime:0,firstMessageDeliveries:0,meshMessageDeliveries:0,meshMessageDeliveriesActive:!1,meshFailurePenalty:0,invalidMessageDeliveries:0},t.topics[e]=r,r):null}}function O$(n,t,e,r,s){let i=0;const o=new Map;if(Object.entries(t.topics).forEach(([f,g])=>{const y=s.get(f)??"unknown",p=e.topics[f];if(p===void 0)return;let w=o.get(y);w==null&&(w={p1w:0,p2w:0,p3w:0,p3bw:0,p4w:0},o.set(y,w));let v=0,x=0,S=0,I=0,P=0;if(g.inMesh){const k=Math.max(g.meshTime/p.timeInMeshQuantum,p.timeInMeshCap);v+=k*p.timeInMeshWeight}let A=g.firstMessageDeliveries;if(A>p.firstMessageDeliveriesCap&&(A=p.firstMessageDeliveriesCap),x+=A*p.firstMessageDeliveriesWeight,g.meshMessageDeliveriesActive&&g.meshMessageDeliveries<p.meshMessageDeliveriesThreshold){const k=p.meshMessageDeliveriesThreshold-g.meshMessageDeliveries,N=k*k;S+=N*p.meshMessageDeliveriesWeight}const C=g.meshFailurePenalty;I+=C*p.meshFailurePenaltyWeight;const T=g.invalidMessageDeliveries*g.invalidMessageDeliveries;P+=T*p.invalidMessageDeliveriesWeight,i+=(v+x+S+I+P)*p.topicWeight,w.p1w+=v,w.p2w+=x,w.p3w+=S,w.p3bw+=I,w.p4w+=P}),e.topicScoreCap>0&&i>e.topicScoreCap){i=e.topicScoreCap;const f=e.topicScoreCap/i;for(const g of o.values())g.p1w*=f,g.p2w*=f,g.p3w*=f,g.p3bw*=f,g.p4w*=f}let a=0,c=0,l=0;const h=e.appSpecificScore(n);a+=h*e.appSpecificWeight,t.knownIPs.forEach(f=>{if(e.IPColocationFactorWhitelist.has(f))return;const g=r.get(f),y=g!=null?g.size:0;if(y>e.IPColocationFactorThreshold){const p=y-e.IPColocationFactorThreshold,w=p*p;c+=w*e.IPColocationFactorWeight}});const d=t.behaviourPenalty*t.behaviourPenalty;return l+=d*e.behaviourPenaltyWeight,i+=a+c+l,{byTopic:o,p5w:a,p6w:c,p7w:l,score:i}}function F$(n,t,e,r,s){const i={byTopic:new Map,p5w:[],p6w:[],p7w:[],score:[]};for(const o of n){const a=t.get(o);if(a!=null){const c=O$(o,a,e,r,s);for(const[l,h]of c.byTopic){let d=i.byTopic.get(l);d==null&&(d={p1w:[],p2w:[],p3w:[],p3bw:[],p4w:[]},i.byTopic.set(l,d)),d.p1w.push(h.p1w),d.p2w.push(h.p2w),d.p3w.push(h.p3w),d.p3bw.push(h.p3bw),d.p4w.push(h.p4w)}i.p5w.push(c.p5w),i.p6w.push(c.p6w),i.p7w.push(c.p7w),i.score.push(c.score)}else i.p5w.push(0),i.p6w.push(0),i.p7w.push(0),i.score.push(0)}return i}class U${constructor(t,e,r){u(this,"rawStream");u(this,"pushable");u(this,"closeController");u(this,"maxBufferSize");this.rawStream=t,this.pushable=gn(),this.closeController=new AbortController,this.maxBufferSize=r.maxBufferSize??1/0,this.closeController.signal.addEventListener("abort",()=>{t.close().catch(s=>{t.abort(s)})}),It(this.pushable,this.rawStream).catch(e)}get protocol(){return this.rawStream.protocol}push(t){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(X0.single(t))}pushPrefixed(t){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(t)}async close(){this.closeController.abort(),await this.pushable.return()}}class $${constructor(t,e={}){u(this,"source");u(this,"rawStream");u(this,"closeController");this.rawStream=t,this.closeController=new AbortController,this.closeController.signal.addEventListener("abort",()=>{t.close().catch(r=>{t.abort(r)})}),this.source=It(this.rawStream,r=>tf(r,e))}async close(){this.closeController.abort()}}class z${constructor(t,e,r){u(this,"gossipsubIWantFollowupMs");u(this,"msgIdToStrFn");u(this,"metrics");u(this,"promises",new Map);u(this,"requestMsByMsg",new Map);u(this,"requestMsByMsgExpire");this.gossipsubIWantFollowupMs=t,this.msgIdToStrFn=e,this.metrics=r,this.requestMsByMsgExpire=10*t}get size(){return this.promises.size}get requestMsByMsgSize(){return this.requestMsByMsg.size}addPromise(t,e){const r=Math.floor(Math.random()*e.length),s=e[r],i=this.msgIdToStrFn(s);let o=this.promises.get(i);o==null&&(o=new Map,this.promises.set(i,o));const a=Date.now();o.has(t)||(o.set(t,a+this.gossipsubIWantFollowupMs),this.metrics!=null&&(this.metrics.iwantPromiseStarted.inc(1),this.requestMsByMsg.has(i)||this.requestMsByMsg.set(i,a)))}getBrokenPromises(){var s;const t=Date.now(),e=new Map;let r=0;return this.promises.forEach((i,o)=>{i.forEach((a,c)=>{a<t&&(e.set(c,(e.get(c)??0)+1),i.delete(c),r++)}),i.size===0&&this.promises.delete(o)}),(s=this.metrics)==null||s.iwantPromiseBroken.inc(r),e}deliverMessage(t,e=!1){this.trackMessage(t);const r=this.promises.get(t);r!=null&&(this.promises.delete(t),this.metrics!=null&&(this.metrics.iwantPromiseResolved.inc(1),e&&this.metrics.iwantPromiseResolvedFromDuplicate.inc(1),this.metrics.iwantPromiseResolvedPeers.inc(r.size)))}rejectMessage(t,e){switch(this.trackMessage(t),e){case Hr.Error:return}this.promises.delete(t)}clear(){this.promises.clear()}prune(){var r;const t=Date.now()-this.requestMsByMsgExpire;let e=0;for(const[s,i]of this.requestMsByMsg.entries())if(i<t)this.requestMsByMsg.delete(s),e++;else break;(r=this.metrics)==null||r.iwantMessagePruned.inc(e)}trackMessage(t){if(this.metrics!=null){const e=this.requestMsByMsg.get(t);e!==void 0&&(this.metrics.iwantPromiseDeliveryTime.observe((Date.now()-e)/1e3),this.requestMsByMsg.delete(t))}}}const cy=Y("libp2p-pubsub:");async function V$(n,t,e,r){switch(n.type){case Vo.Signing:{const s={from:n.author.toMultihash().bytes,data:r,seqno:Es(8),topic:t,signature:void 0,key:void 0},i=ft([cy,si.Message.encode(s)]);s.signature=await n.privateKey.sign(i),s.key=n.key;const o={type:"signed",from:n.author,data:e,sequenceNumber:BigInt(`0x${Z(s.seqno??new Uint8Array(0),"base16")}`),topic:t,signature:s.signature,key:ir(s.key)};return{raw:s,msg:o}}case Vo.Anonymous:return{raw:{from:void 0,data:r,seqno:void 0,topic:t,signature:void 0,key:void 0},msg:{type:"unsigned",data:e,topic:t}};default:throw new Error("Unreachable")}}async function H$(n,t){switch(n){case sf:return t.signature!=null?{valid:!1,error:Yt.SignaturePresent}:t.seqno!=null?{valid:!1,error:Yt.SeqnoPresent}:t.key!=null?{valid:!1,error:Yt.FromPresent}:{valid:!0,message:{type:"unsigned",topic:t.topic,data:t.data??new Uint8Array(0)}};case Sl:{if(t.seqno==null)return{valid:!1,error:Yt.InvalidSeqno};if(t.seqno.length!==8)return{valid:!1,error:Yt.InvalidSeqno};if(t.signature==null)return{valid:!1,error:Yt.InvalidSignature};if(t.from==null)return{valid:!1,error:Yt.InvalidPeerId};let e;try{e=pr(bt(t.from))}catch{return{valid:!1,error:Yt.InvalidPeerId}}let r;if(t.key!=null){if(r=ir(t.key),e.publicKey!==void 0&&!r.equals(e.publicKey))return{valid:!1,error:Yt.InvalidPeerId}}else{if(e.publicKey==null)return{valid:!1,error:Yt.InvalidPeerId};r=e.publicKey}const s={from:t.from,data:t.data,seqno:t.seqno,topic:t.topic,signature:void 0,key:void 0},i=ft([cy,si.Message.encode(s)]);return await r.verify(i,t.signature)?{valid:!0,message:{type:"signed",from:e,data:t.data??new Uint8Array(0),sequenceNumber:BigInt(`0x${Z(t.seqno,"base16")}`),topic:t.topic,signature:t.signature,key:t.key!=null?ir(t.key):r}}:{valid:!1,error:Yt.InvalidSignature}}default:throw new Error("Unreachable")}}function jr(n=[],t){return{subscriptions:[],messages:n,control:t!==void 0?{graft:t.graft??[],prune:t.prune??[],ihave:t.ihave??[],iwant:t.iwant??[],idontwant:t.idontwant??[]}:void 0}}function A3(n){return n.control===void 0&&(n.control={graft:[],prune:[],ihave:[],iwant:[],idontwant:[]}),n}function Sn(n){if(n.length<=1)return n;const t=()=>Math.floor(Math.random()*Math.floor(n.length));for(let e=0;e<n.length;e++){const r=t(),s=n[e];n[e]=n[r],n[r]=s}return n}function q$(n){return Z(n,"base64")}function W$(n,t,e){switch(n){case Sl:return{type:Vo.Signing,author:t,key:Ur(e.publicKey),privateKey:e};case sf:return{type:Vo.Anonymous};default:throw new Error(`Unknown signature policy "${n}"`)}}const K$=(n,t)=>{const e=Y(t.toString(16).padStart(16,"0"),"base16"),r=Ur(n),s=new Uint8Array(r.byteLength+e.length);return s.set(r,0),s.set(e,r.byteLength),s};function G$(n){if(n.type!=="signed")throw new Error("expected signed message type");if(n.sequenceNumber==null)throw Error("missing seqno field");return K$(n.from.publicKey??n.key,n.sequenceNumber)}async function Q$(n){return gt.encode(n.data)}var Eu;(function(n){n[n.ip4=4]="ip4",n[n.ip6=41]="ip6"})(Eu||(Eu={}));function Y$(n){for(const t of n.tuples())switch(t[0]){case Eu.ip4:case Eu.ip6:return l0(t[0],t[1])}return null}class Cd{constructor(t){u(this,"entries",new Map);u(this,"validityMs");this.validityMs=t.validityMs}get size(){return this.entries.size}put(t,e){return this.entries.has(t)?!0:(this.entries.set(t,{value:e,validUntilMs:Date.now()+this.validityMs}),!1)}prune(){const t=Date.now();for(const[e,r]of this.entries.entries())if(r.validUntilMs<t)this.entries.delete(e);else break}has(t){return this.entries.has(t)}get(t){const e=this.entries.get(t);return e!=null&&e.validUntilMs>=Date.now()?e.value:void 0}clear(){this.entries.clear()}}var lr;(function(n){n[n.started=0]="started",n[n.stopped=1]="stopped"})(lr||(lr={}));var N4,L4,O4,F4;class ly extends(F4=Et,O4=Symbol.toStringTag,L4=Pt,N4=ms,F4){constructor(e,r={}){super();u(this,"globalSignaturePolicy");u(this,"multicodecs",[Ad,OU,E3]);u(this,"publishConfig");u(this,"dataTransform");u(this,"peers",new Set);u(this,"streamsInbound",new Map);u(this,"streamsOutbound",new Map);u(this,"outboundInflightQueue",gn({objectMode:!0}));u(this,"direct",new Set);u(this,"floodsubPeers",new Set);u(this,"seenCache");u(this,"acceptFromWhitelist",new Map);u(this,"topics",new Map);u(this,"subscriptions",new Set);u(this,"mesh",new Map);u(this,"fanout",new Map);u(this,"fanoutLastpub",new Map);u(this,"gossip",new Map);u(this,"control",new Map);u(this,"peerhave",new Map);u(this,"iasked",new Map);u(this,"backoff",new Map);u(this,"outbound",new Map);u(this,"msgIdFn");u(this,"fastMsgIdFn");u(this,"msgIdToStrFn");u(this,"fastMsgIdCache");u(this,"publishedMessageIds");u(this,"mcache");u(this,"score");u(this,"topicValidators",new Map);u(this,"log");u(this,"heartbeatTicks",0);u(this,"gossipTracer");u(this,"idontwantCounts",new Map);u(this,"idontwants",new Map);u(this,"components");u(this,"directPeerInitial",null);u(this,"opts");u(this,"decodeRpcLimits");u(this,"metrics");u(this,"status",{code:lr.stopped});u(this,"maxInboundStreams");u(this,"maxOutboundStreams");u(this,"runOnLimitedConnection");u(this,"allowedTopics");u(this,"heartbeatTimer",null);u(this,O4,"@chainsafe/libp2p-gossipsub");u(this,L4,["@libp2p/pubsub"]);u(this,N4,["@libp2p/identify"]);u(this,"runHeartbeat",()=>{var r;const e=(r=this.metrics)==null?void 0:r.heartbeatDuration.startTimer();this.heartbeat().catch(s=>{this.log("Error running heartbeat",s)}).finally(()=>{var s;if(e!=null&&e(),this.status.code===lr.started){clearTimeout(this.status.heartbeatTimeout);let i=this.opts.heartbeatInterval-(Date.now()-this.status.hearbeatStartMs)%this.opts.heartbeatInterval;i<this.opts.heartbeatInterval*.25&&(i+=this.opts.heartbeatInterval,(s=this.metrics)==null||s.heartbeatSkipped.inc()),this.status.heartbeatTimeout=setTimeout(this.runHeartbeat,i)}})});u(this,"tagMeshPeer",e=>{const{peerId:r,topic:s}=e.detail;this.components.peerStore.merge(ut(r),{tags:{[s]:{value:100}}}).catch(i=>{this.log.error("Error tagging peer %s with topic %s",r,s,i)})});u(this,"untagMeshPeer",e=>{const{peerId:r,topic:s}=e.detail;this.components.peerStore.merge(ut(r),{tags:{[s]:void 0}}).catch(i=>{this.log.error("Error untagging peer %s with topic %s",r,s,i)})});const s={fallbackToFloodsub:!0,floodPublish:!0,batchPublish:!1,tagMeshPeers:!0,doPX:!1,directPeers:[],D:FU,Dlo:UU,Dhi:$U,Dscore:zU,Dout:VU,Dlazy:WU,heartbeatInterval:QU,fanoutTTL:YU,mcacheLength:HU,mcacheGossip:qU,seenTTL:a$,gossipsubIWantFollowupMs:o$,prunePeers:XU,pruneBackoff:ZU,unsubcribeBackoff:JU,graftFloodThreshold:s$,opportunisticGraftPeers:n$,opportunisticGraftTicks:r$,directConnectTicks:e$,gossipFactor:KU,idontwantMinDataSize:m$,idontwantMaxMessages:y$,...r,scoreParams:x$(r.scoreParams),scoreThresholds:T$(r.scoreThresholds)};if(this.components=e,this.decodeRpcLimits=s.decodeRpcLimits??w$,this.globalSignaturePolicy=s.globalSignaturePolicy??Sl,s.fallbackToFloodsub&&this.multicodecs.push(v3),this.log=e.logger.forComponent(s.debugName??"libp2p:gossipsub"),this.opts=s,this.direct=new Set(s.directPeers.map(i=>i.id.toString())),this.seenCache=new Cd({validityMs:s.seenTTL}),this.publishedMessageIds=new Cd({validityMs:s.seenTTL}),r.msgIdFn!=null)this.msgIdFn=r.msgIdFn;else switch(this.globalSignaturePolicy){case Sl:this.msgIdFn=G$;break;case sf:this.msgIdFn=Q$;break;default:throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`)}if(r.fastMsgIdFn!=null&&(this.fastMsgIdFn=r.fastMsgIdFn,this.fastMsgIdCache=new Cd({validityMs:s.seenTTL})),this.msgIdToStrFn=r.msgIdToStrFn??q$,this.mcache=r.messageCache??new b$(s.mcacheGossip,s.mcacheLength,this.msgIdToStrFn),r.dataTransform!=null&&(this.dataTransform=r.dataTransform),r.metricsRegister!=null){if(r.metricsTopicStrToLabel==null)throw Error("Must set metricsTopicStrToLabel with metrics");const i=Math.max(...Object.values(s.scoreParams.topics).map(a=>a.meshMessageDeliveriesWindow),g$),o=v$(r.metricsRegister,r.metricsTopicStrToLabel,{gossipPromiseExpireSec:this.opts.gossipsubIWantFollowupMs/1e3,behaviourPenaltyThreshold:s.scoreParams.behaviourPenaltyThreshold,maxMeshMessageDeliveriesWindowSec:i/1e3});o.mcacheSize.addCollect(()=>{this.onScrapeMetrics(o)});for(const a of this.multicodecs)o.protocolsEnabled.set({protocol:a},1);this.metrics=o}else this.metrics=null;this.gossipTracer=new z$(this.opts.gossipsubIWantFollowupMs,this.msgIdToStrFn,this.metrics),this.score=new L$(this.opts.scoreParams,this.metrics,this.components.logger,{scoreCacheValidityMs:s.heartbeatInterval}),this.maxInboundStreams=r.maxInboundStreams,this.maxOutboundStreams=r.maxOutboundStreams,this.runOnLimitedConnection=r.runOnLimitedConnection,this.allowedTopics=s.allowedTopics!=null?new Set(s.allowedTopics):null}getPeers(){return[...this.peers.keys()].map(e=>ut(e))}isStarted(){return this.status.code===lr.started}async start(){if(this.isStarted())return;this.log("starting"),this.publishConfig=W$(this.globalSignaturePolicy,this.components.peerId,this.components.privateKey),this.outboundInflightQueue=gn({objectMode:!0}),It(this.outboundInflightQueue,async o=>{for await(const{peerId:a,connection:c}of o)await this.createOutboundStream(a,c)}).catch(o=>{this.log.error("outbound inflight queue error",o)}),await Promise.all(this.opts.directPeers.map(async o=>{await this.components.peerStore.merge(o.id,{multiaddrs:o.addrs})}));const e=this.components.registrar;await Promise.all(this.multicodecs.map(async o=>e.handle(o,this.onIncomingStream.bind(this),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection})));const r={onConnect:this.onPeerConnected.bind(this),onDisconnect:this.onPeerDisconnected.bind(this),notifyOnLimitedConnection:this.runOnLimitedConnection},s=await Promise.all(this.multicodecs.map(async o=>e.register(o,r))),i=setTimeout(this.runHeartbeat,S3);this.status={code:lr.started,registrarTopologyIds:s,heartbeatTimeout:i,hearbeatStartMs:Date.now()+S3},this.score.start(),this.directPeerInitial=setTimeout(()=>{Promise.resolve().then(async()=>{await Promise.all(Array.from(this.direct).map(async o=>this.connect(o)))}).catch(o=>{this.log(o)})},t$),this.opts.tagMeshPeers&&(this.addEventListener("gossipsub:graft",this.tagMeshPeer),this.addEventListener("gossipsub:prune",this.untagMeshPeer)),this.log("started")}async stop(){if(this.log("stopping"),this.status.code!==lr.started)return;const{registrarTopologyIds:e}=this.status;this.status={code:lr.stopped},this.opts.tagMeshPeers&&(this.removeEventListener("gossipsub:graft",this.tagMeshPeer),this.removeEventListener("gossipsub:prune",this.untagMeshPeer));const r=this.components.registrar;await Promise.all(this.multicodecs.map(async i=>r.unhandle(i))),e.forEach(i=>{r.unregister(i)}),this.outboundInflightQueue.end();const s=[];for(const i of this.streamsOutbound.values())s.push(i.close());this.streamsOutbound.clear();for(const i of this.streamsInbound.values())s.push(i.close());this.streamsInbound.clear(),await Promise.all(s),this.peers.clear(),this.subscriptions.clear(),this.heartbeatTimer!=null&&(this.heartbeatTimer.cancel(),this.heartbeatTimer=null),this.score.stop(),this.mesh.clear(),this.fanout.clear(),this.fanoutLastpub.clear(),this.gossip.clear(),this.control.clear(),this.peerhave.clear(),this.iasked.clear(),this.backoff.clear(),this.outbound.clear(),this.gossipTracer.clear(),this.seenCache.clear(),this.fastMsgIdCache!=null&&this.fastMsgIdCache.clear(),this.directPeerInitial!=null&&clearTimeout(this.directPeerInitial),this.idontwantCounts.clear(),this.idontwants.clear(),this.log("stopped")}dumpPeerScoreStats(){return this.score.dumpPeerScoreStats()}onIncomingStream({stream:e,connection:r}){if(!this.isStarted())return;const s=r.remotePeer;this.addPeer(s,r.direction,r.remoteAddr),this.createInboundStream(s,e),this.outboundInflightQueue.push({peerId:s,connection:r})}onPeerConnected(e,r){var s;(s=this.metrics)==null||s.newConnectionCount.inc({status:r.status}),!(!this.isStarted()||r.status!=="open")&&(this.addPeer(e,r.direction,r.remoteAddr),this.outboundInflightQueue.push({peerId:e,connection:r}))}onPeerDisconnected(e){this.log("connection ended %p",e),this.removePeer(e)}async createOutboundStream(e,r){var i;if(!this.isStarted())return;const s=e.toString();if(this.peers.has(s)&&!this.streamsOutbound.has(s))try{const o=new U$(await r.newStream(this.multicodecs,{runOnLimitedConnection:this.runOnLimitedConnection}),c=>{this.log.error("outbound pipe error",c)},{maxBufferSize:this.opts.maxOutboundBufferSize});this.log("create outbound stream %p",e),this.streamsOutbound.set(s,o);const a=o.protocol;a===v3&&this.floodsubPeers.add(s),(i=this.metrics)==null||i.peersPerProtocol.inc({protocol:a},1),this.subscriptions.size>0&&(this.log("send subscriptions to",s),this.sendSubscriptions(s,Array.from(this.subscriptions),!0))}catch(o){this.log.error("createOutboundStream error",o)}}createInboundStream(e,r){if(!this.isStarted())return;const s=e.toString();if(!this.peers.has(s))return;const i=this.streamsInbound.get(s);i!==void 0&&(this.log("replacing existing inbound steam %s",s),i.close().catch(a=>{this.log.error(a)})),this.log("create inbound stream %s",s);const o=new $$(r,{maxDataLength:this.opts.maxInboundDataLength});this.streamsInbound.set(s,o),this.pipePeerReadStream(e,o.source).catch(a=>{this.log(a)})}addPeer(e,r,s){const i=e.toString();if(!this.peers.has(i)){this.log("new peer %p",e),this.peers.add(i),this.score.addPeer(i);const o=Y$(s);o!==null?this.score.addIP(i,o):this.log("Added peer has no IP in current address %s %s",i,s.toString()),this.outbound.has(i)||this.outbound.set(i,r==="outbound")}}removePeer(e){var o,a;const r=e.toString();if(!this.peers.has(r))return;this.log("delete peer %p",e),this.peers.delete(r);const s=this.streamsOutbound.get(r),i=this.streamsInbound.get(r);s!=null&&((o=this.metrics)==null||o.peersPerProtocol.inc({protocol:s.protocol},-1)),s==null||s.close().catch(c=>{this.log.error(c)}),i==null||i.close().catch(c=>{this.log.error(c)}),this.streamsOutbound.delete(r),this.streamsInbound.delete(r);for(const c of this.topics.values())c.delete(r);for(const[c,l]of this.mesh)l.delete(r)&&((a=this.metrics)==null||a.onRemoveFromMesh(c,un.Dc,1));for(const c of this.fanout.values())c.delete(r);this.floodsubPeers.delete(r),this.gossip.delete(r),this.control.delete(r),this.outbound.delete(r),this.idontwantCounts.delete(r),this.idontwants.delete(r),this.score.removePeer(r),this.acceptFromWhitelist.delete(r)}get started(){return this.status.code===lr.started}getMeshPeers(e){const r=this.mesh.get(e);return r!=null?Array.from(r):[]}getSubscribers(e){const r=this.topics.get(e);return(r!=null?Array.from(r):[]).map(s=>ut(s))}getTopics(){return Array.from(this.subscriptions)}async pipePeerReadStream(e,r){var s;try{await It(r,async i=>{var o,a,c;for await(const l of i)try{const h=l.subarray(),d=si.decode(h,{limits:{subscriptions:this.decodeRpcLimits.maxSubscriptions,messages:this.decodeRpcLimits.maxMessages,control$:{ihave:this.decodeRpcLimits.maxIhaveMessageIDs,iwant:this.decodeRpcLimits.maxIwantMessageIDs,graft:this.decodeRpcLimits.maxControlMessages,prune:this.decodeRpcLimits.maxControlMessages,prune$:{peers:this.decodeRpcLimits.maxPeerInfos},idontwant:this.decodeRpcLimits.maxControlMessages,idontwant$:{messageIDs:this.decodeRpcLimits.maxIdontwantMessageIDs}}}});if((o=this.metrics)==null||o.onRpcRecv(d,h.length),this.opts.awaitRpcHandler)try{await this.handleReceivedRpc(e,d)}catch(f){(a=this.metrics)==null||a.onRpcRecvError(),this.log(f)}else this.handleReceivedRpc(e,d).catch(f=>{var g;(g=this.metrics)==null||g.onRpcRecvError(),this.log(f)})}catch(h){(c=this.metrics)==null||c.onRpcDataError(),this.log(h)}})}catch(i){(s=this.metrics)==null||s.onPeerReadStreamError(),this.handlePeerReadStreamError(i,e)}}handlePeerReadStreamError(e,r){this.log.error(e),this.onPeerDisconnected(r)}async handleReceivedRpc(e,r){var h;if(!this.acceptFrom(e.toString())){this.log("received message from unacceptable peer %p",e),(h=this.metrics)==null||h.rpcRecvNotAccepted.inc();return}const s=r.subscriptions!=null?r.subscriptions.length:0,i=r.messages!=null?r.messages.length:0;let o=0,a=0,c=0,l=0;if(r.control!=null&&(r.control.ihave!=null&&(o=r.control.ihave.length),r.control.iwant!=null&&(a=r.control.iwant.length),r.control.graft!=null&&(c=r.control.graft.length),r.control.prune!=null&&(l=r.control.prune.length)),this.log(`rpc.from ${e.toString()} subscriptions ${s} messages ${i} ihave ${o} iwant ${a} graft ${c} prune ${l}`),r.subscriptions!=null&&r.subscriptions.length>0){const d=[];r.subscriptions.forEach(f=>{const g=f.topic,y=f.subscribe===!0;if(g!=null){if(this.allowedTopics!=null&&!this.allowedTopics.has(g))return;this.handleReceivedSubscription(e,g,y),d.push({topic:g,subscribe:y})}}),this.safeDispatchEvent("subscription-change",{detail:{peerId:e,subscriptions:d}})}for(const d of r.messages){if(this.allowedTopics!=null&&!this.allowedTopics.has(d.topic))continue;const f=this.handleReceivedMessage(e,d).catch(g=>{var y;(y=this.metrics)==null||y.onMsgRecvError(d.topic),this.log(g)});this.opts.awaitRpcMessageHandler&&await f}r.control!=null&&await this.handleControlMessage(e.toString(),r.control)}handleReceivedSubscription(e,r,s){this.log("subscription update from %p topic %s",e,r);let i=this.topics.get(r);i==null&&(i=new Set,this.topics.set(r,i)),s?i.add(e.toString()):i.delete(e.toString())}async handleReceivedMessage(e,r){var o,a,c;(o=this.metrics)==null||o.onMsgRecvPreValidation(r.topic);const s=await this.validateReceivedMessage(e,r);(a=this.metrics)==null||a.onPrevalidationResult(r.topic,s.code);const i=s.code;switch(i){case Zt.duplicate:this.score.duplicateMessage(e.toString(),s.msgIdStr,r.topic),this.gossipTracer.deliverMessage(s.msgIdStr,!0),this.mcache.observeDuplicate(s.msgIdStr,e.toString());return;case Zt.invalid:if(s.msgIdStr!=null){const l=s.msgIdStr;this.score.rejectMessage(e.toString(),l,r.topic,s.reason),this.gossipTracer.rejectMessage(l,s.reason)}else this.score.rejectInvalidMessage(e.toString(),r.topic);(c=this.metrics)==null||c.onMsgRecvInvalid(r.topic,s);return;case Zt.valid:this.score.validateMessage(s.messageId.msgIdStr),this.gossipTracer.deliverMessage(s.messageId.msgIdStr),this.mcache.put(s.messageId,r,!this.opts.asyncValidation),this.subscriptions.has(r.topic)&&(!this.components.peerId.equals(e)||this.opts.emitSelf)&&(super.dispatchEvent(new CustomEvent("gossipsub:message",{detail:{propagationSource:e,msgId:s.messageId.msgIdStr,msg:s.msg}})),super.dispatchEvent(new CustomEvent("message",{detail:s.msg}))),this.opts.asyncValidation||this.forwardMessage(s.messageId.msgIdStr,r,e.toString());break;default:throw new Error(`Invalid validation result: ${i}`)}}async validateReceivedMessage(e,r){var f,g,y,p;const s=(f=this.fastMsgIdFn)==null?void 0:f.call(this,r),i=s!==void 0?(g=this.fastMsgIdCache)==null?void 0:g.get(s):void 0;if(i!=null)return{code:Zt.duplicate,msgIdStr:i};const o=await H$(this.globalSignaturePolicy,r);if(!o.valid)return{code:Zt.invalid,reason:Hr.Error,error:o.error};const a=o.message;try{this.dataTransform!=null&&(a.data=this.dataTransform.inboundTransform(r.topic,a.data))}catch(w){return this.log("Invalid message, transform failed",w),{code:Zt.invalid,reason:Hr.Error,error:Yt.TransformFailed}}const c=await this.msgIdFn(a),l=this.msgIdToStrFn(c),h={msgId:c,msgIdStr:l};if(s!==void 0&&this.fastMsgIdCache!=null&&this.fastMsgIdCache.put(s,l)&&((y=this.metrics)==null||y.fastMsgIdCacheCollision.inc()),this.seenCache.has(l))return{code:Zt.duplicate,msgIdStr:l};this.seenCache.put(l),(((p=r.data)==null?void 0:p.length)??0)>=this.opts.idontwantMinDataSize&&this.sendIDontWants(c,r.topic,e.toString());const d=this.topicValidators.get(r.topic);if(d!=null){let w;try{w=await d(e,a)}catch(v){const x=v.code;x===u$&&(w=xr.Ignore),x===l$?w=xr.Reject:w=xr.Ignore}if(w!==xr.Accept)return{code:Zt.invalid,reason:_3(w),msgIdStr:l}}return{code:Zt.valid,messageId:h,msg:a}}getScore(e){return this.score.score(e)}sendSubscriptions(e,r,s){this.sendRpc(e,{subscriptions:r.map(i=>({topic:i,subscribe:s})),messages:[]})}async handleControlMessage(e,r){var l,h,d,f,g,y,p;if(r===void 0)return;const s=((l=r.ihave)==null?void 0:l.length)>0?this.handleIHave(e,r.ihave):[],i=((h=r.iwant)==null?void 0:h.length)>0?this.handleIWant(e,r.iwant):[],o=((d=r.graft)==null?void 0:d.length)>0?await this.handleGraft(e,r.graft):[];if(((f=r.prune)==null?void 0:f.length)>0&&await this.handlePrune(e,r.prune),((g=r.idontwant)==null?void 0:g.length)>0&&this.handleIdontwant(e,r.idontwant),s.length===0&&i.length===0&&o.length===0)return;const a=this.sendRpc(e,jr(i,{iwant:s,prune:o})),c=(y=s[0])==null?void 0:y.messageIDs;c!=null&&(a?this.gossipTracer.addPromise(e,c):(p=this.metrics)==null||p.iwantPromiseUntracked.inc(1))}acceptFrom(e){if(this.direct.has(e))return!0;const r=Date.now(),s=this.acceptFromWhitelist.get(e);if(s!=null&&s.messagesAccepted<d$&&s.acceptUntil>=r)return s.messagesAccepted+=1,!0;const i=this.score.score(e);return i>=h$?this.acceptFromWhitelist.set(e,{messagesAccepted:0,acceptUntil:r+f$}):this.acceptFromWhitelist.delete(e),i>=this.opts.scoreThresholds.graylistThreshold}handleIHave(e,r){var h,d,f;if(r.length===0)return[];const s=this.score.score(e);if(s<this.opts.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",e,s),(h=this.metrics)==null||h.ihaveRcvIgnored.inc({reason:Ta.LowScore}),[];const i=(this.peerhave.get(e)??0)+1;if(this.peerhave.set(e,i),i>i$)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",e,i),(d=this.metrics)==null||d.ihaveRcvIgnored.inc({reason:Ta.MaxIhave}),[];const o=this.iasked.get(e)??0;if(o>=Fi)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",e,o),(f=this.metrics)==null||f.ihaveRcvIgnored.inc({reason:Ta.MaxIasked}),[];const a=new Map;if(r.forEach(({topicID:g,messageIDs:y})=>{var w;if(g==null||y==null||!this.mesh.has(g))return;let p=0;y.forEach(v=>{const x=this.msgIdToStrFn(v);this.seenCache.has(x)||(a.set(x,v),p++)}),(w=this.metrics)==null||w.onIhaveRcv(g,y.length,p)}),a.size===0)return[];let c=a.size;c+o>Fi&&(c=Fi-o),this.log("IHAVE: Asking for %d out of %d messages from %s",c,a.size,e);let l=Array.from(a.values());return Sn(l),l=l.slice(0,c),this.iasked.set(e,o+c),[{messageIDs:l}]}handleIWant(e,r){var c;if(r.length===0)return[];const s=this.score.score(e);if(s<this.opts.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",e,s),[];const i=new Map,o=new Map;let a=0;return r.forEach(({messageIDs:l})=>{l==null||l.forEach(h=>{const d=this.msgIdToStrFn(h),f=this.mcache.getWithIWantCount(d,e);if(f==null){a++;return}if(o.set(f.msg.topic,1+(o.get(f.msg.topic)??0)),f.count>GU){this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",e,h);return}i.set(d,f.msg)})}),(c=this.metrics)==null||c.onIwantRcv(o,a),i.size===0?(this.log("IWANT: Could not provide any wanted messages to %s",e),[]):(this.log("IWANT: Sending %d messages to %s",i.size,e),Array.from(i.values()))}async handleGraft(e,r){const s=[],i=this.score.score(e),o=Date.now();let a=this.opts.doPX;if(r.forEach(({topicID:l})=>{var f,g;if(l==null)return;const h=this.mesh.get(l);if(h==null){a=!1;return}if(h.has(e))return;const d=(f=this.backoff.get(l))==null?void 0:f.get(e);if(this.direct.has(e))this.log("GRAFT: ignoring request from direct peer %s",e),s.push(l),a=!1;else if(typeof d=="number"&&o<d){this.log("GRAFT: ignoring backed off peer %s",e),this.score.addPenalty(e,1,Aa.GraftBackoff),a=!1;const y=d+this.opts.graftFloodThreshold-this.opts.pruneBackoff;o<y&&this.score.addPenalty(e,1,Aa.GraftBackoff),this.addBackoff(e,l),s.push(l)}else i<0?(this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",e,i,l),s.push(l),a=!1,this.addBackoff(e,l)):h.size>=this.opts.Dhi&&!(this.outbound.get(e)??!1)?(s.push(l),this.addBackoff(e,l)):(this.log("GRAFT: Add mesh link from %s in %s",e,l),this.score.graft(e,l),h.add(e),(g=this.metrics)==null||g.onAddToMesh(l,jt.Subscribed,1));this.safeDispatchEvent("gossipsub:graft",{detail:{peerId:e,topic:l,direction:"inbound"}})}),s.length===0)return[];const c=!1;return Promise.all(s.map(async l=>this.makePrune(e,l,a,c)))}async handlePrune(e,r){var i;const s=this.score.score(e);for(const{topicID:o,backoff:a,peers:c}of r){if(o==null)continue;const l=this.mesh.get(o);if(l==null)return;this.log("PRUNE: Remove mesh link to %s in %s",e,o),this.score.prune(e,o),l.has(e)&&(l.delete(e),(i=this.metrics)==null||i.onRemoveFromMesh(o,un.Prune,1)),typeof a=="number"&&a>0?this.doAddBackoff(e,o,a*1e3):this.addBackoff(e,o),c!=null&&c.length>0&&(s<this.opts.scoreThresholds.acceptPXThreshold?this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",e,s,o):await this.pxConnect(c)),this.safeDispatchEvent("gossipsub:prune",{detail:{peerId:e,topic:o,direction:"inbound"}})}}handleIdontwant(e,r){var l;let s=this.idontwantCounts.get(e)??0;if(s>=this.opts.idontwantMaxMessages)return;const i=s;let o=this.idontwants.get(e);o==null&&(o=new Map,this.idontwants.set(e,o));let a=0;e:for(const{messageIDs:h}of r)for(const d of h){if(s>=this.opts.idontwantMaxMessages)break e;s++;const f=this.msgIdToStrFn(d);o.set(f,this.heartbeatTicks),this.mcache.msgs.has(f)||a++}this.idontwantCounts.set(e,s);const c=s-i;(l=this.metrics)==null||l.onIdontwantRcv(c,a)}addBackoff(e,r){this.doAddBackoff(e,r,this.opts.pruneBackoff)}doAddBackoff(e,r,s){let i=this.backoff.get(r);i==null&&(i=new Map,this.backoff.set(r,i));const o=Date.now()+s;(i.get(e)??0)<o&&i.set(e,o)}applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach((e,r)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",r,e),this.score.addPenalty(r,e,Aa.BrokenPromise)})}clearBackoff(){if(this.heartbeatTicks%jU!==0)return;const e=Date.now();this.backoff.forEach((r,s)=>{r.forEach((i,o)=>{i+p$*this.opts.heartbeatInterval<e&&r.delete(o)}),r.size===0&&this.backoff.delete(s)})}async directConnect(){const e=[];this.direct.forEach(r=>{this.streamsOutbound.has(r)||e.push(r)}),await Promise.all(e.map(async r=>this.connect(r)))}async pxConnect(e){e.length>this.opts.prunePeers&&(Sn(e),e=e.slice(0,this.opts.prunePeers));const r=[];await Promise.all(e.map(async s=>{if(s.peerID==null)return;const i=pr(bt(s.peerID)),o=i.toString();if(!this.peers.has(o)){if(s.signedPeerRecord==null){r.push(o);return}try{if(!await this.components.peerStore.consumePeerRecord(s.signedPeerRecord,i)){this.log("bogus peer record obtained through px: could not add peer record to address book");return}r.push(o)}catch{this.log("bogus peer record obtained through px: invalid signature or not a peer record")}}})),r.length!==0&&await Promise.all(r.map(async s=>this.connect(s)))}async connect(e){var i;this.log("Initiating connection with %s",e);const r=ut(e),s=await this.components.connectionManager.openConnection(r);for(const o of this.multicodecs)for(const a of this.components.registrar.getTopologies(o))(i=a.onConnect)==null||i.call(a,r,s)}subscribe(e){if(this.status.code!==lr.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(e)){this.subscriptions.add(e);for(const r of this.peers.keys())this.sendSubscriptions(r,[e],!0)}this.join(e)}unsubscribe(e){if(this.status.code!==lr.started)throw new Error("Pubsub is not started");const r=this.subscriptions.delete(e);if(this.log("unsubscribe from %s - am subscribed %s",e,r),r)for(const s of this.peers.keys())this.sendSubscriptions(s,[e],!1);this.leave(e)}join(e){var o,a,c;if(this.status.code!==lr.started)throw new Error("Gossipsub has not started");if(this.mesh.has(e))return;this.log("JOIN %s",e),(o=this.metrics)==null||o.onJoin(e);const r=new Set,s=this.backoff.get(e),i=this.fanout.get(e);if(i!=null&&(this.fanout.delete(e),this.fanoutLastpub.delete(e),i.forEach(l=>{!this.direct.has(l)&&this.score.score(l)>=0&&(s==null?void 0:s.has(l))!==!0&&r.add(l)}),(a=this.metrics)==null||a.onAddToMesh(e,jt.Fanout,r.size)),r.size<this.opts.D){const l=r.size;this.getRandomGossipPeers(e,this.opts.D,d=>!r.has(d)&&!this.direct.has(d)&&this.score.score(d)>=0&&(s==null?void 0:s.has(d))!==!0).forEach(d=>{r.add(d)}),(c=this.metrics)==null||c.onAddToMesh(e,jt.Random,r.size-l)}this.mesh.set(e,r),r.forEach(l=>{this.log("JOIN: Add mesh link to %s in %s",l,e),this.sendGraft(l,e)})}leave(e){var s;if(this.status.code!==lr.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",e),(s=this.metrics)==null||s.onLeave(e);const r=this.mesh.get(e);r!=null&&(Promise.all(Array.from(r).map(async i=>{this.log("LEAVE: Remove mesh link to %s in %s",i,e),await this.sendPrune(i,e)})).catch(i=>{this.log("Error sending prunes to mesh peers",i)}),this.mesh.delete(e))}selectPeersToForward(e,r,s){const i=new Set,o=this.topics.get(e);o!=null&&(this.direct.forEach(c=>{o.has(c)&&r!==c&&!((s==null?void 0:s.has(c))??!1)&&i.add(c)}),this.floodsubPeers.forEach(c=>{o.has(c)&&r!==c&&!((s==null?void 0:s.has(c))??!1)&&this.score.score(c)>=this.opts.scoreThresholds.publishThreshold&&i.add(c)}));const a=this.mesh.get(e);return a!=null&&a.size>0&&a.forEach(c=>{r!==c&&!((s==null?void 0:s.has(c))??!1)&&i.add(c)}),i}selectPeersToPublish(e){const r=new Set,s={direct:0,floodsub:0,mesh:0,fanout:0},i=this.topics.get(e);if(i!=null)if(this.opts.floodPublish)i.forEach(o=>{this.direct.has(o)?(r.add(o),s.direct++):this.score.score(o)>=this.opts.scoreThresholds.publishThreshold&&(r.add(o),s.floodsub++)});else{this.direct.forEach(a=>{i.has(a)&&(r.add(a),s.direct++)}),this.floodsubPeers.forEach(a=>{i.has(a)&&this.score.score(a)>=this.opts.scoreThresholds.publishThreshold&&(r.add(a),s.floodsub++)});const o=this.mesh.get(e);if(o!=null&&o.size>0)o.forEach(a=>{r.add(a),s.mesh++}),o.size<this.opts.D&&this.getRandomGossipPeers(e,this.opts.D-o.size,c=>!o.has(c)&&!this.direct.has(c)&&!this.floodsubPeers.has(c)&&this.score.score(c)>=this.opts.scoreThresholds.publishThreshold).forEach(c=>{r.add(c),s.mesh++});else{const a=this.fanout.get(e);if(a!=null&&a.size>0)a.forEach(c=>{r.add(c),s.fanout++});else{const c=this.getRandomGossipPeers(e,this.opts.D,l=>this.score.score(l)>=this.opts.scoreThresholds.publishThreshold);c.size>0&&(this.fanout.set(e,c),c.forEach(l=>{r.add(l),s.fanout++}))}this.fanoutLastpub.set(e,Date.now())}}return{tosend:r,tosendCount:s}}forwardMessage(e,r,s,i){var a;s!=null&&this.score.deliverMessage(s,e,r.topic);const o=this.selectPeersToForward(r.topic,s,i);o.forEach(c=>{this.sendRpc(c,jr([r]))}),(a=this.metrics)==null||a.onForwardMsg(r.topic,o.size)}async publish(e,r,s){var S,I;const i=Date.now(),o=this.dataTransform!=null?this.dataTransform.outboundTransform(e,r):r;if(this.publishConfig==null)throw Error("PublishError.Uninitialized");const{raw:a,msg:c}=await V$(this.publishConfig,e,r,o),l=await this.msgIdFn(c),h=this.msgIdToStrFn(l),d=(s==null?void 0:s.ignoreDuplicatePublishError)??this.opts.ignoreDuplicatePublishError;if(this.seenCache.has(h)){if(d)return(S=this.metrics)==null||S.onPublishDuplicateMsg(e),{recipients:[]};throw Error("PublishError.Duplicate")}const{tosend:f,tosendCount:g}=this.selectPeersToPublish(e),y=this.opts.emitSelf&&this.subscriptions.has(e),p=(s==null?void 0:s.allowPublishToZeroTopicPeers)??this.opts.allowPublishToZeroTopicPeers;if(f.size===0&&!p&&!y)throw Error("PublishError.NoPeersSubscribedToTopic");this.seenCache.put(h),this.mcache.put({msgId:l,msgIdStr:h},a,!0),this.publishedMessageIds.put(h);const w=(s==null?void 0:s.batchPublish)??this.opts.batchPublish,v=jr([a]);if(w)this.sendRpcInBatch(f,v);else for(const P of f)this.sendRpc(P,v)||f.delete(P);const x=Date.now()-i;return(I=this.metrics)==null||I.onPublishMsg(e,g,f.size,a.data!=null?a.data.length:0,x),y&&(f.add(this.components.peerId.toString()),super.dispatchEvent(new CustomEvent("gossipsub:message",{detail:{propagationSource:this.components.peerId,msgId:h,msg:c}})),super.dispatchEvent(new CustomEvent("message",{detail:c}))),{recipients:Array.from(f.values()).map(P=>ut(P))}}sendRpcInBatch(e,r){var o;const s=si.encode(r),i=X0.single(s);for(const a of e){const c=this.streamsOutbound.get(a);if(c==null){this.log(`Cannot send RPC to ${a} as there is no open stream to it available`),e.delete(a);continue}try{c.pushPrefixed(i)}catch(l){e.delete(a),this.log.error(`Cannot send rpc to ${a}`,l)}(o=this.metrics)==null||o.onRpcSent(r,s.length)}}reportMessageValidationResult(e,r,s){var a;let i;if(s===xr.Accept){if(i=this.mcache.validate(e),i!=null){const{message:c,originatingPeers:l}=i;this.score.deliverMessage(r,e,c.topic),this.forwardMessage(e,i.message,r,l)}}else if(i=this.mcache.remove(e),i!=null){const c=_3(s),{message:l,originatingPeers:h}=i;this.score.rejectMessage(r,e,l.topic,c);for(const d of h)this.score.rejectMessage(d,e,l.topic,c)}const o=this.score.messageFirstSeenTimestampMs(e);(a=this.metrics)==null||a.onReportValidation(i,s,o)}sendGraft(e,r){const i=jr([],{graft:[{topicID:r}]});this.sendRpc(e,i)}async sendPrune(e,r){const i=[await this.makePrune(e,r,this.opts.doPX,!0)],o=jr([],{prune:i});this.sendRpc(e,o)}sendIDontWants(e,r,s){var c;const i=this.mesh.get(r);if(i==null)return;const o=new Set(i);o.delete(s);for(const l of o)((c=this.streamsOutbound.get(l))==null?void 0:c.protocol)!==Ad&&o.delete(l);const a=jr([],{idontwant:[{messageIDs:[e]}]});this.sendRpcInBatch(o,a)}sendRpc(e,r){var c,l,h,d,f;const s=this.streamsOutbound.get(e);if(s==null)return this.log(`Cannot send RPC to ${e} as there is no open stream to it available`),!1;const i=this.control.get(e);i!=null&&(this.piggybackControl(e,r,i),this.control.delete(e));const o=this.gossip.get(e);o!=null&&(this.piggybackGossip(e,r,o),this.gossip.delete(e));const a=si.encode(r);try{s.push(a)}catch(g){return this.log.error(`Cannot send rpc to ${e}`,g),i!=null&&this.control.set(e,i),o!=null&&this.gossip.set(e,o),!1}if((c=this.metrics)==null||c.onRpcSent(r,a.length),((l=r.control)==null?void 0:l.graft)!=null)for(const g of(h=r.control)==null?void 0:h.graft)g.topicID!=null&&this.safeDispatchEvent("gossipsub:graft",{detail:{peerId:e,topic:g.topicID,direction:"outbound"}});if(((d=r.control)==null?void 0:d.prune)!=null)for(const g of(f=r.control)==null?void 0:f.prune)g.topicID!=null&&this.safeDispatchEvent("gossipsub:prune",{detail:{peerId:e,topic:g.topicID,direction:"outbound"}});return!0}piggybackControl(e,r,s){var o,a;const i=A3(r);for(const c of s.graft)c.topicID!=null&&(((o=this.mesh.get(c.topicID))==null?void 0:o.has(e))??!1)&&i.control.graft.push(c);for(const c of s.prune)c.topicID!=null&&!(((a=this.mesh.get(c.topicID))==null?void 0:a.has(e))??!1)&&i.control.prune.push(c)}piggybackGossip(e,r,s){const i=A3(r);i.control.ihave=s}async sendGraftPrune(e,r,s){const i=this.opts.doPX,o=!1;for(const[a,c]of e){const l=c.map(f=>({topicID:f}));let h=[];const d=r.get(a);d!=null&&(h=await Promise.all(d.map(async f=>this.makePrune(a,f,i&&!(s.get(a)??!1),o))),r.delete(a)),this.sendRpc(a,jr([],{graft:l,prune:h}))}for(const[a,c]of r){const l=await Promise.all(c.map(async h=>this.makePrune(a,h,i&&!(s.get(a)??!1),o)));this.sendRpc(a,jr([],{prune:l}))}}emitGossip(e){const r=this.mcache.getGossipIDs(new Set(e.keys()));for(const[s,i]of e)this.doEmitGossip(s,i,r.get(s)??[])}doEmitGossip(e,r,s){if(s.length===0||(Sn(s),s.length>Fi&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",s.length),r.size===0))return;let i=this.opts.Dlazy;const a=this.opts.gossipFactor*r.size;let c=r;a>i&&(i=a),i>c.size?i=c.size:c=Sn(Array.from(c)).slice(0,i),c.forEach(l=>{let h=s;s.length>Fi&&(h=Sn(h.slice()).slice(0,Fi)),this.pushGossip(l,{topicID:e,messageIDs:h})})}flush(){for(const[e,r]of this.gossip.entries())this.gossip.delete(e),this.sendRpc(e,jr([],{ihave:r}));for(const[e,r]of this.control.entries()){this.control.delete(e);const s=jr([],{graft:r.graft,prune:r.prune});this.sendRpc(e,s)}}pushGossip(e,r){this.log("Add gossip to %s",e);const s=this.gossip.get(e)??[];this.gossip.set(e,s.concat(r))}async makePrune(e,r,s,i){var h;if(this.score.prune(e,r),((h=this.streamsOutbound.get(e))==null?void 0:h.protocol)===E3)return{topicID:r,peers:[]};const o=i?this.opts.unsubcribeBackoff:this.opts.pruneBackoff,a=o/1e3;if(this.doAddBackoff(e,r,o),!s)return{topicID:r,peers:[],backoff:a};const c=this.getRandomGossipPeers(r,this.opts.prunePeers,d=>d!==e&&this.score.score(d)>=0),l=await Promise.all(Array.from(c).map(async d=>{const f=ut(d);let g;try{g=await this.components.peerStore.get(f)}catch(y){if(y.name!=="NotFoundError")throw y}return{peerID:f.toMultihash().bytes,signedPeerRecord:g==null?void 0:g.peerRecordEnvelope}}));return{topicID:r,peers:l,backoff:a}}async heartbeat(){var p,w;const{D:e,Dlo:r,Dhi:s,Dscore:i,Dout:o,fanoutTTL:a}=this.opts;this.heartbeatTicks++;const c=new Map,l=v=>{let x=c.get(v);return x===void 0&&(x=this.score.score(v),c.set(v,x)),x},h=new Map,d=new Map,f=new Map;this.clearBackoff(),this.peerhave.clear(),(p=this.metrics)==null||p.cacheSize.set({cache:"iasked"},this.iasked.size),this.iasked.clear(),this.applyIwantPenalties(),this.idontwantCounts.clear();for(const v of this.idontwants.values())for(const[x,S]of v)this.heartbeatTicks-S>=this.opts.mcacheLength&&v.delete(x);this.heartbeatTicks%this.opts.directConnectTicks===0&&await this.directConnect(),(w=this.fastMsgIdCache)==null||w.prune(),this.seenCache.prune(),this.gossipTracer.prune(),this.publishedMessageIds.prune();const g=new Map;this.mesh.forEach((v,x)=>{const S=this.topics.get(x),I=new Set,P=new Set;if(g.set(x,P),S!=null){const T=Sn(Array.from(S)),k=this.backoff.get(x);for(const N of T){const $=this.streamsOutbound.get(N);if($!=null&&this.multicodecs.includes($.protocol)&&!v.has(N)&&!this.direct.has(N)){const z=l(N);(k==null?void 0:k.has(N))!==!0&&z>=0&&I.add(N),z>=this.opts.scoreThresholds.gossipThreshold&&P.add(N)}}}const A=(T,k)=>{var $;this.log("HEARTBEAT: Remove mesh link to %s in %s",T,x),this.addBackoff(T,x),v.delete(T),l(T)>=this.opts.scoreThresholds.gossipThreshold&&P.add(T),($=this.metrics)==null||$.onRemoveFromMesh(x,k,1);const N=d.get(T);N==null?d.set(T,[x]):N.push(x)},C=(T,k)=>{var $;this.log("HEARTBEAT: Add mesh link to %s in %s",T,x),this.score.graft(T,x),v.add(T),P.delete(T),($=this.metrics)==null||$.onAddToMesh(x,k,1);const N=h.get(T);N==null?h.set(T,[x]):N.push(x)};if(v.forEach(T=>{const k=l(T);k<0&&(this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s",T,k,x),A(T,un.BadScore),f.set(T,!0))}),v.size<r){const T=e-v.size;C$(I,T).forEach(N=>{C(N,jt.NotEnough)})}if(v.size>s){let T=Array.from(v);T.sort((N,$)=>l($)-l(N)),T=T.slice(0,i).concat(Sn(T.slice(i)));let k=0;if(T.slice(0,e).forEach(N=>{(this.outbound.get(N)??!1)&&k++}),k<o){const N=z=>{const q=T[z];for(let U=z;U>0;U--)T[U]=T[U-1];T[0]=q};if(k>0){let z=k;for(let q=1;q<e&&z>0;q++)(this.outbound.get(T[q])??!1)&&(N(q),z--)}let $=e-k;for(let z=e;z<T.length&&$>0;z++)(this.outbound.get(T[z])??!1)&&(N(z),$--)}T.slice(e).forEach(N=>{A(N,un.Excess)})}if(v.size>=r){let T=0;if(v.forEach(k=>{(this.outbound.get(k)??!1)&&T++}),T<o){const k=o-T;rf(I,k,$=>this.outbound.get($)===!0).forEach($=>{C($,jt.Outbound)})}}if(this.heartbeatTicks%this.opts.opportunisticGraftTicks===0&&v.size>1){const T=Array.from(v).sort(($,z)=>l($)-l(z)),k=Math.floor(v.size/2),N=l(T[k]);if(N<this.opts.scoreThresholds.opportunisticGraftThreshold){const $=this.opts.opportunisticGraftPeers,z=rf(I,$,q=>l(q)>N);for(const q of z)this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s",q,x),C(q,jt.Opportunistic)}}});const y=Date.now();this.fanoutLastpub.forEach((v,x)=>{v+a<y&&(this.fanout.delete(x),this.fanoutLastpub.delete(x))}),this.fanout.forEach((v,x)=>{const S=this.topics.get(x);v.forEach(C=>{(!((S==null?void 0:S.has(C))??!1)||l(C)<this.opts.scoreThresholds.publishThreshold)&&v.delete(C)});const I=this.topics.get(x),P=[],A=new Set;if(g.set(x,A),I!=null){const C=Sn(Array.from(I));for(const T of C){const k=this.streamsOutbound.get(T);if(k!=null&&this.multicodecs.includes(k.protocol)&&!v.has(T)&&!this.direct.has(T)){const N=l(T);N>=this.opts.scoreThresholds.publishThreshold&&P.push(T),N>=this.opts.scoreThresholds.gossipThreshold&&A.add(T)}}}if(v.size<e){const C=e-v.size;P.slice(0,C).forEach(T=>{v.add(T),A==null||A.delete(T)})}}),this.emitGossip(g),await this.sendGraftPrune(h,d,f),this.flush(),this.mcache.shift(),this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"))}getRandomGossipPeers(e,r,s=()=>!0){const i=this.topics.get(e);if(i==null)return new Set;let o=[];return i.forEach(a=>{const c=this.streamsOutbound.get(a);c!=null&&this.multicodecs.includes(c.protocol)&&s(a)&&o.push(a)}),o=Sn(o),r>0&&o.length>r&&(o=o.slice(0,r)),new Set(o)}onScrapeMetrics(e){var l,h;e.mcacheSize.set(this.mcache.size),e.mcacheNotValidatedCount.set(this.mcache.notValidatedCount),e.cacheSize.set({cache:"direct"},this.direct.size),e.cacheSize.set({cache:"seenCache"},this.seenCache.size),e.cacheSize.set({cache:"fastMsgIdCache"},((l=this.fastMsgIdCache)==null?void 0:l.size)??0),e.cacheSize.set({cache:"publishedMessageIds"},this.publishedMessageIds.size),e.cacheSize.set({cache:"mcache"},this.mcache.size),e.cacheSize.set({cache:"score"},this.score.size),e.cacheSize.set({cache:"gossipTracer.promises"},this.gossipTracer.size),e.cacheSize.set({cache:"gossipTracer.requests"},this.gossipTracer.requestMsByMsgSize),e.cacheSize.set({cache:"topics"},this.topics.size),e.cacheSize.set({cache:"subscriptions"},this.subscriptions.size),e.cacheSize.set({cache:"mesh"},this.mesh.size),e.cacheSize.set({cache:"fanout"},this.fanout.size),e.cacheSize.set({cache:"peers"},this.peers.size),e.cacheSize.set({cache:"streamsOutbound"},this.streamsOutbound.size),e.cacheSize.set({cache:"streamsInbound"},this.streamsInbound.size),e.cacheSize.set({cache:"acceptFromWhitelist"},this.acceptFromWhitelist.size),e.cacheSize.set({cache:"gossip"},this.gossip.size),e.cacheSize.set({cache:"control"},this.control.size),e.cacheSize.set({cache:"peerhave"},this.peerhave.size),e.cacheSize.set({cache:"outbound"},this.outbound.size);let r=0;const s=Date.now();e.connectedPeersBackoffSec.reset();for(const d of this.backoff.values()){r+=d.size;for(const[f,g]of d.entries())this.peers.has(f)&&e.connectedPeersBackoffSec.observe(Math.max(0,g-s)/1e3)}e.cacheSize.set({cache:"backoff"},r);let i=0;for(const d of this.idontwants.values())i+=d.size;e.cacheSize.set({cache:"idontwants"},i);for(const[d,f]of this.topics)e.topicPeersCount.set({topicStr:d},f.size);for(const[d,f]of this.mesh)e.meshPeerCounts.set({topicStr:d},f.size);const o=[],a=new Map;e.behaviourPenalty.reset();for(const d of this.peers.keys()){const f=this.score.score(d);o.push(f),a.set(d,f),e.behaviourPenalty.observe(((h=this.score.peerStats.get(d))==null?void 0:h.behaviourPenalty)??0)}e.registerScores(o,this.opts.scoreThresholds),e.registerScorePerMesh(this.mesh,a);const c=F$(this.peers.keys(),this.score.peerStats,this.score.params,this.score.peerIPs,e.topicStrToLabel);e.registerScoreWeights(c)}}u(ly,"multicodec",Ad);function X$(n={}){return t=>new ly(t,n)}let rl=null,la=null;const Z$=["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt"],J$=async()=>{if(la)return la;try{return la=await R9({addresses:{listen:["/webrtc"]},transports:[f9(),d9()],streamMuxers:[j7()],connectionEncrypters:[],peerDiscovery:[lm({list:Z$})],services:{identify:bm(),pubsub:X$({allowPublishToZeroTopicPeers:!0,emitSelf:!0})}}),console.log("Libp2p node created with PeerID:",la.peerId.toString()),la}catch(n){return console.error("Failed to create libp2p node:",n),null}},Sc=async()=>{if(rl)return rl;try{const n=new M8,t=new p0,e=await J$();if(!e)throw new Error("Failed to create libp2p node");return rl=await fO({blockstore:n,datastore:t,libp2p:e}),console.log("Helia node created successfully"),rl}catch(n){return console.error("Failed to create Helia node:",n),null}},j$=async()=>{const n=await Sc();return n?mO(n):null},j0=async()=>{const n=await Sc();return n?wO(n):null},ez=async()=>{const n=await Sc();return n?DU(n):null},e2=async()=>{const n=await Sc();return n?n.libp2p:null},Wz=async n=>{try{const t=await j0();if(!t)throw new Error("JSON utility not available");const e=await t.add(n);return console.log("Message stored with CID:",e.toString()),e.toString()}catch(t){throw console.error("Error storing message:",t),t}},Kz=async n=>{try{const t=await j0();if(!t)throw new Error("JSON utility not available");const e=te.parse(n);return await t.get(e)}catch(t){throw console.error("Error retrieving message:",t),t}},Gz=async(n,t)=>{try{const e=await e2();if(!e)throw new Error("Libp2p not available");e.pubsub.subscribe(n),e.pubsub.addEventListener("message",r=>{if(r.detail.topic===n)try{const s=JSON.parse(new TextDecoder().decode(r.detail.data));t(s)}catch(s){console.error("Error parsing message:",s)}}),console.log(`Subscribed to topic: ${n}`)}catch(e){throw console.error("Error subscribing to messages:",e),e}},Qz=async(n,t)=>{try{const e=await e2();if(!e)throw new Error("Libp2p not available");const r=new TextEncoder().encode(JSON.stringify(t));await e.pubsub.publish(n,r),console.log(`Published message to topic: ${n}`)}catch(e){throw console.error("Error publishing message:",e),e}},tz=async()=>{try{const n=await e2();if(!n)throw new Error("Libp2p not available");return n.peerId.toString()}catch(n){throw console.error("Error getting peer ID:",n),n}},uy=Ze.createContext(null),Yz=({children:n,fallback:t=null})=>{const[e,r]=Ze.useState(null),[s,i]=Ze.useState(!1),[o,a]=Ze.useState(null),[c,l]=Ze.useState(null),[h,d]=Ze.useState(null),[f,g]=Ze.useState("");return Ze.useEffect(()=>{let y=!0;return(async()=>{try{const w=await Sc();if(!w||!y)return;r(w);const v=await j$(),x=await j0(),S=await ez(),I=await tz();if(!y)return;a(v),l(x),d(S),g(I),i(!0),console.log("IPFS initialized successfully with peer ID:",I),localStorage.setItem("peerId",I),localStorage.getItem("walletAddress")||localStorage.setItem("walletAddress",I)}catch(w){console.error("Failed to initialize IPFS:",w)}})(),()=>{y=!1}},[]),s?Or.jsx(uy.Provider,{value:{ipfs:e,isReady:s,stringHelper:o,jsonHelper:c,unixFsHelper:h,peerId:f},children:n}):Or.jsx(Or.Fragment,{children:t})},Xz=()=>{const n=Ze.useContext(uy);if(!n)throw new Error("useIPFS must be used within an IPFSProvider");return n};export{iz as C,Yz as I,sz as S,Py as a,Wz as b,Qz as p,Kz as r,Gz as s,Xz as u};
